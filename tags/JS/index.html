<!DOCTYPE>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>小白妹妹写代码 | 一个废话很多的程序媛</title>
  <meta name="description" content="我这么可爱一定是男孩子">
  
  <meta name="author" content="Sabrina">

  <meta http-equiv="Cache-Control" content="no-siteapp">
  <link rel="shortcut icon" type="image/ico" href="/favicon.ico">
  <link rel="stylesheet"
        href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
  <link rel="stylesheet"
        href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
</head>
<body>
<nav class="navbar navbar-default">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#menu_mobile_collapse" aria-expanded="false">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="#"><i class="fa fa-github" style="font-size:30px;"></i></a>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="menu_mobile_collapse">
      <form class="navbar-form navbar-left" role="search">
        <div class="form-group">
          <div class="input-group">
            <span class="input-group-addon" id="sizing-addon2">This website</span>
            <input type="text" class="form-control" placeholder="search">
          </div>
        </div>
      </form>
      <ul class="nav navbar-nav">
        <li class="active"><a href="/tech/">Home</a></li>
        <li><a href="#">Archieve</a></li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
          <a href="#">
            <i class="fa fa-rss"></i>
          </a>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"><i class="fa fa-share-alt"></i> <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="github.com/sabrinaluo"><i class="fa fa-github"></i></a></li>
            <li><a href="weibo.com/206663121"><i class="fa fa-weibo"></i></a></li>
            <li role="separator" class="divider"></li>
            <li>
              <a href="#">
                <i class="fa fa-qq"></i>
              </a>
            </li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"><i class="fa fa-user"></i> <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="#">I have nothing to say</a></li>
          </ul>
        </li>
      </ul>
    </div>
    <!-- /.navbar-collapse -->
  </div>
  <!-- /.container-fluid -->
</nav>
<main class="container">
  <header>
  <div class="row" style="border-bottom: 1px solid #f5f5f5;">
    <div class="col-sm-6 ">
      <h2 style="margin-bottom:0">
        <i class="fa fa-book text-muted"></i>
        <a href="/tech/">小白妹妹写代码</a>
      </h2>
      <p class="text-muted">
        我这么可爱一定是男孩子
      </p>

    </div>
    <div class="col-sm-6 hidden-xs" style="padding-right:0">
      <div class="pull-right" style="line-height:73px;">
        <div class="btn-group btn-group-xs" role="group">
          <button type="button" class="btn info"><i class="fa fa-file-text"></i> Post</button>
          <button type="button" class="btn btn-default">
            15
          </button>
        </div>
        <div class="btn-group btn-group-xs" role="group">
          <button type="button" class="btn info"><i class="fa fa-tags"></i> Tag</button>
          <button type="button" class="btn btn-default">
            52
          </button>
        </div>
        <div class="btn-group btn-group-xs" role="group">
          <button type="button" class="btn info"><i class="fa fa-list-ul"></i> Category</button>
          <button type="button" class="btn btn-default">
            0
          </button>
        </div>
        <!--end btn-group-->

      </div>
    </div>
  </div>
</header>
  <div class="row">
    <div class="col-sm-9">
      
<h2><a href="http://sabrinaluo.com/tech/2015/12/31/understand-js-inheritance/">对JS类和继承的一些理解</a></h2>
<article>
  <p>本文只总结最常用的实现方法，不具体讨论各种实现方法的优缺点（这些具体可以看<a href="http://book.douban.com/subject/10546125/" target="_blank" rel="external">《JavaScript高级程序设计》</a>）。</p>
<p>直到ES5，JS也还是一个没有类的语言，虽然ES6中可以使用class关键字，但据说也只是语法糖。(不知道好不好吃ԅ(¯﹃¯ԅ))</p>
<h3 id="u7C7B_u7684_u5B9E_u73B0"><a href="#u7C7B_u7684_u5B9E_u73B0" class="headerlink" title="类的实现"></a>类的实现</h3><p>类的两个基本元素就是<strong>属性</strong>和<strong>方法</strong>。</p>
<p>JS中类的实现有很多种，构造函数模式、原型模式等等，各有各的优缺点，最常用的是混合了构造函数和原型模式的混合模式。<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span></span> Person(<span class="keyword">name</span>) &#123;</span><br><span class="line">  this.<span class="keyword">name</span> = <span class="keyword">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="string">'Hi, '</span> + this.<span class="keyword">name</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用构造函数来构造<strong>属性</strong>，然后往原型对象添加<strong>方法</strong>。这样的好处是：</p>
<ul>
<li>每个实例之间不用共享属性，拥有各自独立的属性。也就可以避免当属性为引用类型（数组、对象）时，修改一个实例的属性会影响到其他实例的情况。</li>
<li>每个实例之间共用原型对象上的方法，实现了函数复用。</li>
</ul>
<h3 id="u7EE7_u627F_u7684_u5B9E_u73B0"><a href="#u7EE7_u627F_u7684_u5B9E_u73B0" class="headerlink" title="继承的实现"></a>继承的实现</h3><p>JS中继承的实现也有很多种，借用构造函数，原型链等等。<br>子类继承父类，当然继承的就是父类的<strong>属性和方法</strong>。JS中继承的实现，最常用的也是混合模式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Student.prototype.constructor); <span class="comment">// Student</span></span><br><span class="line"></span><br><span class="line">Student.prototype = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(Student.prototype.constructor); <span class="comment">// Person</span></span><br><span class="line"></span><br><span class="line">Student.prototype.constructor = Student; <span class="comment">// 重写constructor</span></span><br><span class="line"></span><br><span class="line">Student.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"I'm "</span> + <span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用<strong>借用构造函数</strong>的方式来继承<strong>属性</strong>，然后使用<strong>原型链</strong>来继承<strong>方法</strong>。通过将子类的原型对象指向父类的实例，子类的实例就可以通过原型链向上查找到父类原型上的方法。</p>
<h3 id="u91CD_u5199_u5B50_u7C7B_u6784_u9020_u51FD_u6570_u7684_u610F_u4E49"><a href="#u91CD_u5199_u5B50_u7C7B_u6784_u9020_u51FD_u6570_u7684_u610F_u4E49" class="headerlink" title="重写子类构造函数的意义"></a>重写子类构造函数的意义</h3><p><code>Student.prototype = new Person();</code>这一步完全改变了Student原型对象的引用，<code>Student.prototype.constructor</code> 变为了Person原型对象的constructor。<br>个人觉得重写<code>Student.prototype.constructor = Student;</code>没有什么实际意义，可能只是<strong>约定俗成的一种潜规则</strong>。<br>人们通常可能已经习惯了使用new操作符的时候，构造函数的一致性<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Student.prototype.constructor = Student; 在上面的代码中注释掉这一句</span></span><br><span class="line"><span class="keyword">var</span> xiaobai = <span class="keyword">new</span> Student(<span class="string">'小白妹妹'</span>, <span class="number">10</span>);</span><br><span class="line">xiaobai.<span class="keyword">constructor</span>; <span class="comment">// Person</span></span><br></pre></td></tr></table></figure></p>
<p>当你在代码中遇到上面这种情况，如果不去查看之前的代码的话，肯定会觉得奇怪，为什么明明通过Student构造函数new了一个Student实例，而这个实例，却说自己的构造函数是Person？！？！WTF？！</p>
<h3 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h3><p>[1] <a href="http://stackoverflow.com/questions/4012998/what-it-the-significance-of-the-javascript-constructor-property" target="_blank" rel="external">http://stackoverflow.com/questions/4012998/what-it-the-significance-of-the-javascript-constructor-property</a></p>

</article>

<div class="duoshuo">
  <!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="" data-title="对JS类和继承的一些理解"
       data-url="http://sabrinaluo.com/tech/2015/12/31/understand-js-inheritance/"></div>
  <!-- 多说评论框 end -->
  <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
  <script type="text/javascript">
    var duoshuoQuery = {short_name: "sabrinaluo"};
    (function () {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';
      ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
  <!-- 多说公共JS代码 end -->
</div>




<h2><a href="http://sabrinaluo.com/tech/2015/12/19/understand-js-closure/">对JS闭包(Closure)的一些理解</a></h2>
<article>
  <p>昨天无聊在github上看代码，看到如下片段，反正看不太懂这是在干啥，但这就是传说中的闭包了…</p>
<pre><code>function isType(type) {
  return function(obj) {
    return {}.toString.call(obj) === &apos;[object &apos; + type + &apos;]&apos;
  }
}
</code></pre><p><em>以上来自目测是个阿里女神的repo: <a href="https://github.com/fool2fish/utilx/blob/master/lib/index.js" target="_blank" rel="external">utilx</a></em></p>
<p>很久之前就听过<strong>闭包</strong>这个概念，看了一些相关的资料，依旧无法明白到底是个什么东东。各种作用域scope，看得我头都大了。_(:з」∠)_</p>
<p>我在这里呢，也不会讲继续什么变量作用域，什么从外部读取局部变量之类的！@#￥%…的东东，我试图用最简单粗暴连隔壁卖红薯的大妈都能理解的方法，来说说我对闭包的理解。</p>
<p>###闭包长什么样子？</p>
<pre><code>function bibao(a){
  return function(b){
    return a+b;
  }
}
</code></pre><p>上面的例子就是一个闭包。<br>我的理解是，闭包有这么几个元素：</p>
<ol>
<li>最外层是一个有名字的函数，通常都需要传入参数或者在这一层定义一些变量。</li>
<li>这个有名字的函数返回一个匿名函数，通常都需要传入参数或者定义一些变量。</li>
<li>这个匿名函数返回的值通常跟上面两点中的入参或者变量有关。</li>
</ol>
<h3 id="u5982_u4F55_u4F7F_u7528_u95ED_u5305_uFF1F"><a href="#u5982_u4F55_u4F7F_u7528_u95ED_u5305_uFF1F" class="headerlink" title="如何使用闭包？"></a>如何使用闭包？</h3><p>这个问题其实也就是说，当你调用闭包的时候你其实是在调用什么？<br>我觉得搞清楚这个问题对于简单粗暴的理解闭包非常有用。</p>
<p>用上面的闭包作为例子，通常闭包是这么用的：</p>
<pre><code>//例1，分两次传入参数
var hello = bibao(&apos;你好&apos;)；
var text = hello(&apos;小白妹妹&apos;);
console.log(text); //你会看到 你好小白妹妹
</code></pre><p>上面这个例子，其实就是：</p>
<pre><code>//例2，一次传入两个参数
var text = bibao(&apos;你好&apos;)(&apos;小白妹妹&apos;)
</code></pre><p>所以基本上可以理解为，有这么一个函数<code>bibao(a)(b)</code>，调用的时候需要传入两个参数<code>a</code>和<code>b</code>，你可以<strong>分开传</strong>，也可以<strong>一起传</strong>。</p>
<p>大多数情况下，都是像例1一样，分开两次传入参数的。当你分开传的时候，第一次传入参数<code>a</code>，也就是<code>var hello = bibao(&#39;你好&#39;);</code>其实等于：</p>
<pre><code>var hello = function(b){
  return &apos;你好&apos;+b;  
}
</code></pre><p>所以当你给<code>hello()</code>传入参数<code>b</code>的时候，<code>var text = hello(&#39;小白妹妹&#39;)</code>，返回的是“你好小白妹妹”。也就等于说，当你在调用<code>hello()</code>这个函数的时候，其实访问到了bibao()这个函数中的变量<code>a</code>，值为’你好’。</p>
<p>闭包中<code>a</code>是定义在匿名函数外部的，这就是传说中的：<strong>内部函数可以访问外部函数的变量</strong>。</p>
<h3 id="u4E3A_u4EC0_u4E48_u8981_u4F7F_u7528_u95ED_u5305_uFF1F_u4F7F_u7528_u95ED_u5305_u6709_u4EC0_u4E48_u597D_u5904_uFF1F"><a href="#u4E3A_u4EC0_u4E48_u8981_u4F7F_u7528_u95ED_u5305_uFF1F_u4F7F_u7528_u95ED_u5305_u6709_u4EC0_u4E48_u597D_u5904_uFF1F" class="headerlink" title="为什么要使用闭包？使用闭包有什么好处？"></a>为什么要使用闭包？使用闭包有什么好处？</h3><p>我有一个强烈的感觉闭包是一个懒人发明的…（当然我是瞎说的_(:з」∠)_）<br>假如我的老板认识了一大堆妹子，要我写个程序跟她们每个人说早安、午安、晚安，并告诉他们昨天是几号，最后还要问候他的老婆，“吃饭了吗？亲爱的”<br>通常我会这么实现：</p>
<pre><code>function yesterday(){
 return new Date().getDate() -1;
}
function goodmorning(name){
  return &apos;早安&apos;+name + &apos;昨天是&apos; + yesterday() + &apos;号&apos;;
}
function goodafternoon(name){
  return &apos;午安&apos;+name + &apos;昨天是&apos; + yesterday() + &apos;号&apos;;
}
function goodnight(name){
  return &apos;晚安&apos;+name + &apos;昨天是&apos; + yesterday() + &apos;号&apos;;
}
//eating()这个函数不一定非要定义，可以直接console.log()也能满足需求，
//但是想到老板将来又会去问候其他的人，吃饭了吗？xxx，
//所以定义了一个函数，以便将来可以偷懒
function eating(name){
  return &apos;吃饭了吗？&apos; + name;
}
var list = [&apos;小白妹妹&apos;,&apos;小红妹妹&apos;,&apos;小黑妹妹&apos;,&apos;小灰妹妹&apos;];
list.forEach(function(item){
  console.log(goodmorning(item));
  console.log(goodafternoon(item));
  console.log(goodnight(item));
});
console.log(eating(&apos;亲爱的&apos;))
</code></pre><p>使用闭包这么实现：</p>
<pre><code>function yesterday(){
 return new Date().getDate()-1;
}
function bibao(greeting){
  return function(name){
    return greeting + name +&apos;昨天是&apos; + yesterday() + &apos;号&apos;;
  }
}
var goodmorning = bibao(&apos;早安&apos;);
var goodafternoon = bibao(&apos;午安&apos;);
var goodnight = bibao(&apos;晚安&apos;);
var list = [&apos;小白妹妹&apos;,&apos;小红妹妹&apos;,&apos;小黑妹妹&apos;,&apos;小灰妹妹&apos;];
list.forEach(function(item){
  console.log(goodmorning(item));
  console.log(goodafternoon(item));
  console.log(goodnight(item));
});
var eating = bibao(&apos;吃饭了吗？&apos;);
console.log(eating(&apos;亲爱的&apos;));
</code></pre><p>可以看到，使用了闭包就不用重复定义<strong>行为类似</strong>的函数，<code>+ name +&#39;昨天是&#39; + yesterday() + &#39;号&#39;;</code>这个也只用写一遍就可以了，免去了很多重复劳动，看起来简洁了很多，最重要是…显得逼格高…</p>
<h3 id="u4EC0_u4E48_u65F6_u5019_u7528_u95ED_u5305_uFF1F"><a href="#u4EC0_u4E48_u65F6_u5019_u7528_u95ED_u5305_uFF1F" class="headerlink" title="什么时候用闭包？"></a>什么时候用闭包？</h3><p>我自己的感觉是，当你需要定义很多行为类似的函数的，重复写很多基本类似的内容的时候，就可以考虑用闭包来让整个代码的结构更加简洁。（总觉得使用闭包，可读性就不那么强了，毕竟我这种小白还是不太一眼就看得出来一个闭包到底输入啥返回啥的…）</p>
<p>另外就也不太清楚具体的使用场景了，反正我平时很少用到…少用到的可能有这么几个：</p>
<ul>
<li>对闭包的理解不够深入，其实还是不太知道这个东东到底干啥用的</li>
<li>通常用别的简单粗暴的方法来代替闭包实现的功能，简单的来说比如一个人不知道switch，但是知道if else，于是用if else来实现跟switch一样的功能</li>
</ul>
<p>我不知道有没有什么情况是除了闭包就没办法解决的…如果没有…那么用其他方法代替实现就可以了，实在搞不明白也没什么关系…</p>
<p>###使用闭包的坏处？<br>据说是可能出现内存泄露的问题<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript#内存泄露" target="_blank" rel="external">^1</a>，这个就更高深了…以后有了深入的理解再来补充吧</p>

</article>

<div class="duoshuo">
  <!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="" data-title="对JS闭包(Closure)的一些理解"
       data-url="http://sabrinaluo.com/tech/2015/12/19/understand-js-closure/"></div>
  <!-- 多说评论框 end -->
  <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
  <script type="text/javascript">
    var duoshuoQuery = {short_name: "sabrinaluo"};
    (function () {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';
      ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
  <!-- 多说公共JS代码 end -->
</div>




    </div>
    <div class="col-sm-3">
      
  <div class="row">
    <div class="col-sm-12">
      <h4>About Me</h4>
      <p>
        123
      </p>
    </div>
  </div>
  <div class="row">
    <div class="col-sm-12">
      <h4>Recent Post</h4>
    </div>
  </div>


  <div class="row" style="border:1px solid #f5f5f5;border-radius:3px;">

    <div class="col-sm-12">
      <h4>Categories</h4> 123

    </div>
  </div>
  <div class="row">
    <div class="col-sm-12">
      <h4>Tags</h4>
    </div>
  </div>


    </div>
  </div>
  <footer>
theme <a href="https://github.com/sabrinaluo/hexo-theme-replica">Replica</a> by <a href="http://github.com/sabrinaluo">sabrinaluo</a> | powered by Hexo
</footer>

</main>
</body>
<script src="http://code.jquery.com/jquery-1.11.3.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-52574938-4', 'auto');
  ga('send', 'pageview');
</script>



<script>
  var _hmt = _hmt || [];
  (function(){var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?2111ca472933b76e6b2089677e5bc4c1";
    var s = document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm, s);})();
</script>



</html>