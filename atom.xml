<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[小白妹妹写代码]]></title>
  <subtitle><![CDATA[一个废话很多的程序媛 | 我这么可爱一定是男孩子]]></subtitle>
  <link href="/tech/atom.xml" rel="self"/>
  <link href="http://sabrinaluo.github.io/tech/"/>
  <updated>2015-12-11T12:51:38.930Z</updated>
  <id>http://sabrinaluo.github.io/tech/</id>
  
  <author>
    <name><![CDATA[Sabrina]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[X-WSSE验证中关于SHA1编码方式的一些坑]]></title>
    <link href="http://sabrinaluo.github.io/tech/2015/12/11/x-wsse/"/>
    <id>http://sabrinaluo.github.io/tech/2015/12/11/x-wsse/</id>
    <published>2015-12-11T09:08:38.000Z</published>
    <updated>2015-12-11T12:51:38.930Z</updated>
    <content type="html"><![CDATA[<p>不知道为什么，关于X-WSSE验证的中文资料很少，英文资料也不是很多，能搜到的资料年代都非常久远，最早可追溯到2003年<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，可能这种验证方式太古老而且存在什么弊端，所以在随后的很多年里人们发现、发明了其他更常用的验证方式？</p>
<p>关于HTTP的各种验证方式我其实一种都不知道…X-WSSE这一种奇怪的方式是我在整合Emarsys的API时了解到的。由于自身比较懒，就到Github上搜搜有没有现成的能够生成UsernameToken的包可以用，以省去重复发明轮子的功夫，然而掉进了坑里，与<a href="https://github.com/bouzuya/node-wsse" target="_blank" rel="external">node-wsse</a>的作者大战了好几个回合…</p>
<hr>
<p>此文章不讨论验证的原理，只讨论X-WSSE UsernameToken的生成方式，其中主要是生成<strong>passwordDigest</strong>。
验证嘛，用户名username，密码password肯定是少不了的，此外还需要nonce，timeStamp，有了这几样再按照下面的步骤一步步就可以生成符合WSSE标准的token了。</p>
<p>UsernameToken的生成一共需要<strong>5个步骤</strong>：</p>
<ol>
<li>生成一个随机字符串nonce。不同公司的API对这个nonce的要求可能会不同，有一些要求采用<code>base64</code>编码方式，比如<a href="http://symfony.com/doc/current/cookbook/security/custom_authentication_provider.html#the-authentication-provider" target="_blank" rel="external">symfony给出的例子</a>；</li>
<li>时间戳（timeStamp）。对于时间戳，统一采用<a href="http://baike.baidu.com/view/931641.htm" target="_blank" rel="external">ISO-8601</a>格式的字符串，但是不同公司的API对时区（timezone）的要求可能会不同，比如Emarsys要求UTC，Adobe要求GMT；</li>
<li>把nonce，timeStamp，password这三个字符串按顺序连接起来形成一个新的字符串，并将这个字符串按照<a href="http://baike.baidu.com/view/1228622.htm" target="_blank" rel="external">SHA1</a>方法加密。
<strong>坑来啦，坑来啦，坑来啦！！！</strong>
一个字符串通常加密之后密码摘要默认是binary的，比如Adobe<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，但有些公司可能要求以hex方式生成摘要…比如万恶的Emarsys<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>…而关于这个摘要到底应该是binary还是hex，据说业界也是模糊不清的，只能由着各家公司按自身情况使用两种方式中的某一种来实现验证<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>；</li>
<li>把上一步得到的密码摘要按照<code>base64</code>进行编码，就能得到passwordDigest；</li>
<li>按照以下方式拼接字符串，把各个双引号内换成上面步骤所提到的值，即可得到UsernameToken，看起来长这样：</li>
</ol>
<pre><code>UsernameToken Username=&quot;username&quot;, PasswordDigest=&quot;passwordDigest&quot;, Nonce=&quot;nonce&quot;, Created=&quot;timeStamp&quot;
</code></pre>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>http://www.xml.com/pub/a/2003/12/17/dive.html <a href="#fnref1" class="footnote-backref">↩</a></p>
</li>
<li id="fn2" class="footnote-item"><p>https://marketing.adobe.com/developer/cn/documentation/authentication-1/wsse-authentication-2 <a href="#fnref2" class="footnote-backref">↩</a></p>
</li>
<li id="fn3" class="footnote-item"><p>http://documentation.emarsys.com/resource/developers/api/getting-started/authentication/ <a href="#fnref3" class="footnote-backref">↩</a></p>
</li>
<li id="fn4" class="footnote-item"><p>http://book.soundonair.ru/web/web2apps-CHP-11-SECT-1.html#web2apps-CHP-11-SECT-1.8 <a href="#fnref4" class="footnote-backref">↩</a></p>
</li>
</ol>
</section>
]]></content>
    <summary type="html">
    <![CDATA[<p>不知道为什么，关于X-WSSE验证的中文资料很少，英文资料也不是很多，能搜到的资料年代都非常久远，最早可追溯到2003年<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，可能这种验证方式太古]]>
    </summary>
    
      <category term="SHA1" scheme="http://sabrinaluo.github.io/tech/tags/SHA1/"/>
    
      <category term="WSSE" scheme="http://sabrinaluo.github.io/tech/tags/WSSE/"/>
    
      <category term="X-WSSE" scheme="http://sabrinaluo.github.io/tech/tags/X-WSSE/"/>
    
      <category term="auth" scheme="http://sabrinaluo.github.io/tech/tags/auth/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[版本控制及git常用基本命令]]></title>
    <link href="http://sabrinaluo.github.io/tech/2015/12/04/git-basic/"/>
    <id>http://sabrinaluo.github.io/tech/2015/12/04/git-basic/</id>
    <published>2015-12-04T03:40:04.000Z</published>
    <updated>2015-12-11T12:51:38.929Z</updated>
    <content type="html"><![CDATA[<p>（此文章适合听说过git，大概知道git是什么东东，但是又不会git命令的童鞋阅读。
时间充裕的童鞋可以到<a href="https://www.codecademy.com/learn/learn-git" target="_blank" rel="external">codecademy</a>跟着教程一步步走）</p>
<p><a href="https://git-scm.com/" target="_blank" rel="external">Git</a>是一个分布式的版本管理(<a href="https://git-scm.com/book/en/v2/Getting-Started-About-Version-Control" target="_blank" rel="external">Version Control</a>)工具。</p>
<p>版本管理这个概念很多童鞋可能不是很清楚，但其实在代码创作的过程中很可能已经使用过了一些传统的方法，比如我初中高中的时候创作博客模板的时候，对同一个模板想做一些不同的调整，同时又担心调整后原来的功能啊显示啊的会受到影响，那时候还不知道github之类的东东，于是<s>机智地</s></p>
<blockquote>
<ol>
<li>创建了很多文件夹来放不同的模板</li>
</ol>
</blockquote>
<ol start="2">
<li>不停的备份</li>
<li>如果调整后正常运行和显示，那就使用最新的版本</li>
<li>如果调整后不能正常运行同时又找不出问题所在，就是用备份的上一个版本来重新创作</li>
</ol>
<p>以上对应到版本控制系统分别是：</p>
<blockquote>
<ol>
<li>创建分支(branch)</li>
</ol>
</blockquote>
<ol start="2">
<li>提交代码(commit)</li>
<li>合并分支(merge)</li>
<li>版本回滚(checkout)</li>
</ol>
<p>关于git的概念及使用流程这里不详细讨论，暂时只讨论一些最基本的常用的git命令</p>
<ul>
<li><code>git init</code> 初始化一个git仓库，生成<code>.git</code>隐藏文件</li>
<li><code>git status</code> 查看git仓库的状态，将会返回<strong>当前分支</strong>, <strong>文件状态</strong>等信息，可以使用<code>-s</code>参数查看只有文件状态的简洁版信息</li>
<li><code>git clone &lt;repo location&gt; &lt;repo name&gt;</code> 将远程分支克隆到本地，<code>&lt;repo name&gt;</code>参数可选，为本地repo命名，若省略，则本地repo与远程同名</li>
<li><code>git add &lt;file name&gt;</code> 将文件变为staged状态，也就是告诉git哪些新的文件和修改过的文件是之后要提交的；文件名支持正则表达式</li>
<li><code>git rm &lt;file name&gt;</code> 将文件删除同时告诉git从git仓库中删除文件，可以使用 <code>--cached</code> 参数实现只从git仓库中删除而不删除本地文件</li>
<li><code>git diff &lt;file name&gt;</code> 查看git仓库文件与本地文件的区别</li>
<li><code>git commit -m &quot;some comment&quot;</code> 将修改提交到git仓库</li>
<li><code>git show HEAD</code> 显示HEAD版本的相关信息，包括<strong>author</strong>，<strong>date</strong>，<strong>comment</strong>，<strong>diff</strong></li>
<li><code>git log</code> 查看提交记录，包括提交的时间、作者、评论</li>
<li><code>git reset SHA</code> 将git仓库回退到某个版本，其中<code>SHA</code>为版本log中commi后的一长串字符的前7位字符</li>
<li><code>git reset HEAD &lt;file name&gt;</code> 将某个文件重置为git仓库的HEAD版本</li>
<li><code>git checkout HEAD</code> 使用git仓库中的文件覆盖当前的整个working copy，可以在修改了某些文件但想舍弃这些修改的时候使用这个命令</li>
<li><code>git branch</code> 查看分支信息，使用<code>-r</code>参数查看远程分支信息</li>
<li><code>git branch &lt;branch name&gt;</code> 添加新的分支</li>
<li><code>git brand -d &lt;branch name&gt;</code> 删除分支</li>
<li><code>git checkout &lt;branch name&gt;</code> 切换分支</li>
<li><code>git fetch</code> 获取远程origin/master分支最新版本，需要手动与本地文件merge</li>
<li><code>git pull</code> 获取远程的最新版本并与本地merge</li>
</ul>
<blockquote>
<p>需要注意 <code>git fetch</code> 与 <code>git pull</code> 的不同，通常如果本地文件有改动，则应该先fetch在 <code>git merge origin/master</code></p>
</blockquote>
<ul>
<li><code>git merge &lt;branch name&gt;</code> 合并分支，将指定分支与当前分支合并</li>
</ul>
<blockquote>
<p><code>origin/master</code>分支为远程主分支</p>
</blockquote>
<ul>
<li><code>git push origin &lt;branch name&gt;</code> 把分支推送到远程</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>（此文章适合听说过git，大概知道git是什么东东，但是又不会git命令的童鞋阅读。
时间充裕的童鞋可以到<a href="https://www.codecademy.com/learn/learn-git" target="_blank" rel="external">]]>
    </summary>
    
      <category term="git" scheme="http://sabrinaluo.github.io/tech/tags/git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我所理解的Promise]]></title>
    <link href="http://sabrinaluo.github.io/tech/2015/12/01/promise/"/>
    <id>http://sabrinaluo.github.io/tech/2015/12/01/promise/</id>
    <published>2015-12-01T10:46:26.000Z</published>
    <updated>2015-12-11T14:03:01.386Z</updated>
    <content type="html"><![CDATA[<p>（嫌我话多的可以直接看分割线之后的部分…）
以前高中的时候自己捣腾博客，一直也就只会用JQuery写点按钮事件什么的，连表单提交都没写过，后来误打误撞做了前端码农旧觉得JS的异步模式实在是太坑爹，当你搞清楚异步回调的时候，又会发现<a href="http://callbackhell.com/" target="_blank" rel="external">回调地狱(Callback Hell)</a>太坑爹…
为什么觉得异步坑爹？看看下面这个例子：</p>
<pre><code class="language-javascript">//以下用setTimeout()模拟一个请求
function getName() {
  return &quot;小白妹妹&quot;;
}

function greeting(name) {
  console.log(&quot;你好，&quot; + name);
}

//生成一个0到1000的随机数，模拟不确定的等待时间0-1秒
var randomTime = function () {
  return Math.random() * 1000;
};

var name = &quot;&quot;;
//1秒之内给name赋值为 小白妹妹，但不知道具体时间
setTimeout(function () {
  name = getName();
}, randomTime());

greeting(name); //以为得到name之后就可以开心的去打招呼啦，然而…
</code></pre>
<h3>这是错的！这是错的！这是错的！</h3>
<p>可能很多新手都犯过这个错误，错的时候还不知道为啥错了…深究原因的话跟JS的机制有关，长篇大论的就不在这里多说了（其实是我说不清楚…）</p>
<p>再有点经验，就会知道，应该把 <code>greeting(name)</code> 写在回调函数里，这样就能保证在得到数据之后才运行 <code>greeting()</code> 函数，于是…当你有多个请求并且之间是有这种依赖关系的时候，可怕的回调地狱就出现了！
而解决回调地狱其中一个很优雅的方法，就是使用传说中的promise！</p>
<p>关于promise这个概念我前前后后看了有一年了，周围也没有认识的人可以给我讲，只能自己看看网上的文章，然而…<s>并没有什么卵用</s>…网上的文章都是众说纷纭，有一上来就defer的<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，也有一上来就说如果你还在用defer你就理解错了Promise的<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，就所以我到现在也不知道究竟什么样的理解才是对的…</p>
<p>关于<a href="http://segmentfault.com/a/1190000002452115" target="_blank" rel="external">Promise以及A+规范</a>就不在此详述了，那些概念的东东，我也还没完全理解。我想做的是让跟我一样的小白都能明白Promise最基本的用法。</p>
<hr>
<p>举个栗子…
有一个第三方提供的API，访问API能够得到一些用户数据（每访问一次得到一页，假设由于某些限制一页只返回3个用户）以及下一页的index；除了第一页之外，其他的页面都需要下一页的index参数才能访问到。（先不管这个API设计的合不合理…Facebook就有这样的API）
http://example.com/user  <em>--&gt;访问第一页的用户数据</em>
http://example.com/user?next=xzmca  <em>--&gt;访问第二页的用户数据</em>
请求第一页时返回结果如下：</p>
<pre><code class="language-json">{
&quot;items&quot; : [{
  &quot;name&quot; : &quot;小白妹妹&quot;,
   &quot;age&quot; : 10
  }, 
  {...},
  {...}],
&quot;nextPage&quot; : &quot;xzmca&quot;,
&quot;lastPage&quot; : null
}
</code></pre>
<p>你可能会有这样的需求：你的APP一次需要显示6个甚至更多个的用户数据。而根据之前的API，一次只能拿到3个数据，那么就只能发出两次请求，并且<strong>第二次请求依赖于第一次请求的结果</strong>，由于异步的原因我们并不知道第一个请求什么时候才完成，<s>而我最初入坑时是让程序发完第一个请求后强制等2秒再发第二个请求我会告诉你们吗…</s></p>
<p>下面为了方便，使用<code>setTimeout()</code>函数和<a href="http://bluebirdjs.com/" target="_blank" rel="external">bluebird</a>库进行说明:</p>
<pre><code class="language-javascript">//生成一个0到3000的随机数，模拟不确定的等待时间0-3秒
var randomTime = function () {
  return Math.random() * 3000;
};

//只考虑最简单的情况promise被resolve，暂时不考虑promise被reject的情况
function req1() {
  return new Promise(function (resolve) {
    //使用setTimeout()来模拟发送请求，data为请求得到的数据
    setTimeout(function () {
      var data = {
        &quot;items&quot;: [{
          &quot;name&quot;: &quot;小白妹妹&quot;,
          &quot;age&quot;: 10
        }, {
          &quot;name&quot;: &quot;小白&quot;,
          &quot;age&quot;: 100
        }, {
          &quot;name&quot;: &quot;妹妹&quot;,
          &quot;age&quot;: 111
        }],
        &quot;nextPage&quot;: &quot;asdfa&quot;,
        &quot;lastPage&quot;: null
      };
      resolve(data);
      console.log(&quot;请求1完成&quot;);
    }, randomTime());
  })
}

function req2(dataFromReq1) {
  return new Promise(function (resolve) {
    setTimeout(function () {
      var data = {
        &quot;items&quot;: [{
          &quot;name&quot;: &quot;小黑姐姐&quot;,
          &quot;age&quot;: 20
        }, {
          &quot;name&quot;: &quot;小黑&quot;,
          &quot;age&quot;: 233
        }, {
          &quot;name&quot;: &quot;姐姐&quot;,
          &quot;age&quot;: 250
        }],
        &quot;nextPage&quot;: &quot;gwdfx&quot;,
        &quot;lastPage&quot;: &quot;asdfa&quot;
      };
      console.log(dataFromReq1);
      var finalUserData = dataFromReq1.items.concat(data.items); //将两次得到的用户数据合并
      resolve(finalUserData);
      console.log(&quot;请求2完成&quot;);
    }, randomTime());
  })
}

//让数据在promise链上欢快的传递吧～
req1().then(req2).then(function (data) {
  console.log(data);
});
</code></pre>
<ul>
<li>
<p>Q: 什么时候需要返回一个promise呢？
A: 当你的需求逻辑是，XXX的执行需要依赖OOO的结果，此时OOO就应该返回一个promise</p>
</li>
<li>
<p>Q: 为什么req1要打括号，而req2不打括号？
A:这个我也没太搞清楚XD，我的理解是，<code>req1()</code>打括号执行后才会返回promise，不打括号就只是一个没有执行的函数，<code>req2</code>不打括号是因为then的入参只能是一个<strong>函数</strong>，如果打了括号执行后就不是函数了。</p>
</li>
<li>
<p>Q: 最后一个then的function(data) data是哪里来的？
A: <code>req2</code>的定义中，有一句<code>resolve(finalUserData)</code>，在Promise Chain中，每个then的入参的入参也就是function(data)中的data都是由前一个promise resolve时传递而来的</p>
</li>
</ul>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>https://github.com/alsotang/node-lessons/tree/master/lesson17 <a href="#fnref1" class="footnote-backref">↩</a></p>
</li>
<li id="fn2" class="footnote-item"><p>http://web.jobbole.com/82601/ <a href="#fnref2" class="footnote-backref">↩</a></p>
</li>
</ol>
</section>
]]></content>
    <summary type="html">
    <![CDATA[<p>（嫌我话多的可以直接看分割线之后的部分…）
以前高中的时候自己捣腾博客，一直也就只会用JQuery写点按钮事件什么的，连表单提交都没写过，后来误打误撞做了前端码农旧觉得JS的异步模式实在是太坑爹，当你搞清楚异步回调的时候，又会发现<a href="http://callba]]>
    </summary>
    
      <category term="promise" scheme="http://sabrinaluo.github.io/tech/tags/promise/"/>
    
  </entry>
  
</feed>
