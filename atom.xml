<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小白妹妹写代码</title>
  <subtitle>一个废话很多的程序媛</subtitle>
  <link href="/tech/atom.xml" rel="self"/>
  
  <link href="http://sabrinaluo.com/tech/"/>
  <updated>2016-02-17T07:55:27.154Z</updated>
  <id>http://sabrinaluo.com/tech/</id>
  
  <author>
    <name>Sabrina</name>
    <email>luohaojing@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>jQuery中利用JSONP进行跨域GET请求</title>
    <link href="http://sabrinaluo.com/tech/2016/02/17/using-jQuery-to-handle-CORS-with-jsonp/"/>
    <id>http://sabrinaluo.com/tech/2016/02/17/using-jQuery-to-handle-CORS-with-jsonp/</id>
    <published>2016-02-17T04:31:55.000Z</published>
    <updated>2016-02-17T07:55:27.154Z</updated>
    
    <content type="html">&lt;p&gt;每次遇到跨域的问题真是！@#￥%&lt;/p&gt;
&lt;p&gt;我对&lt;code&gt;JSONP&lt;/code&gt;的一些浅显的理解就是，有时候会看到类似&lt;code&gt;http://xxx.xx.com/?callback=xxx&lt;/code&gt;这样的请求（&lt;code&gt;callback=&lt;/code&gt;也可能是&lt;code&gt;jsonp=&lt;/code&gt;也可能是&lt;code&gt;jsonpcallback=&lt;/code&gt;，这个取决于服务器端是怎么实现jsonp的），这样的请求做的事情简单的来说就是等得到所有数据之后就执行回调函数。&lt;/p&gt;
&lt;p&gt;由于这个回调函数已经发给了服务器，返回的结果其实是一个函数，函数的入参是获取的数据。&lt;/p&gt;
&lt;p&gt;jQuery的ajax请求其实能很简单的在客户端进行跨域GET请求，具体如下：&lt;br&gt;&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; options = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  url: &#39;http://xx.xx.com/xxx&#39;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;method&lt;/span&gt;: &#39;&lt;span class=&quot;type&quot;&gt;GET&lt;/span&gt;&#39;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  dataType: &#39;jsonp&#39;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //jsonp: &#39;callback&#39;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  success: function(data)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; something here;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$.ajax(options);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其中需要注意的是，一定要声明&lt;strong&gt;&lt;code&gt;dataType&lt;/code&gt;&lt;/strong&gt;，然后把回调函数写在success后面就可以了。&lt;br&gt;另外一开始提到，服务器端对jsonp的实现可能不同，所以在&lt;code&gt;options&lt;/code&gt;中，有时候需要声明&lt;code&gt;jsonp&lt;/code&gt;对应的字符串，默认是&lt;code&gt;&amp;quot;callback&amp;quot;&lt;/code&gt;。例如：如果服务器实现jsonp是通过&lt;code&gt;http://xxx.xx.com/?jsonpcallback=xxx&lt;/code&gt;，那么就需要在&lt;code&gt;options&lt;/code&gt;中声明&lt;code&gt;jsonp:&amp;#39;jsonpcallback&amp;#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;原理据说和&lt;code&gt;&amp;lt;script src=&amp;quot;...&amp;quot;&amp;gt;&lt;/code&gt;差不多，我现在还不是很明白=，=&lt;/p&gt;
&lt;p&gt;参考&lt;br&gt;&lt;a href=&quot;http://www.runoob.com/json/json-jsonp.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.runoob.com/json/json-jsonp.html&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;每次遇到跨域的问题真是！@#￥%&lt;/p&gt;
&lt;p&gt;我对&lt;code&gt;JSONP&lt;/code&gt;的一些浅显的理解就是，有时候会看到类似&lt;code&gt;http://xxx.xx.com/?callback=xxx&lt;/code&gt;这样的请求（&lt;code&gt;callback=&lt;/code&gt;也可
    
    </summary>
    
    
      <category term="CORS" scheme="http://sabrinaluo.com/tech/tags/CORS/"/>
    
      <category term="JSONP" scheme="http://sabrinaluo.com/tech/tags/JSONP/"/>
    
      <category term="jQuery" scheme="http://sabrinaluo.com/tech/tags/jQuery/"/>
    
      <category term="跨域" scheme="http://sabrinaluo.com/tech/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>谷歌地图 Google Map API 初体验</title>
    <link href="http://sabrinaluo.com/tech/2016/02/03/experiencing-google-map-js-api/"/>
    <id>http://sabrinaluo.com/tech/2016/02/03/experiencing-google-map-js-api/</id>
    <published>2016-02-03T10:32:51.000Z</published>
    <updated>2016-02-17T07:55:27.154Z</updated>
    
    <content type="html">&lt;p&gt;一直都想把自己去过的地方做个地图标记，然而现在能找到的各种现成的地图产品都不太喜欢，所以就用谷歌地图自己写了一个。&lt;br&gt;总结以下常见的问题和坑：&lt;/p&gt;
&lt;h3 id=&quot;自动缩放-auto-zoom&quot;&gt;&lt;a href=&quot;#自动缩放-auto-zoom&quot; class=&quot;headerlink&quot; title=&quot;自动缩放(auto zoom)&quot;&gt;&lt;/a&gt;自动缩放(auto zoom)&lt;/h3&gt;&lt;p&gt;使用场景大多数时候是有很多marker，想要全部显示这些marker，同时zoom当然越大越清晰。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先需要一个marker的位置列表 &lt;code&gt;markerList&lt;/code&gt;，单个元素长这样&lt;code&gt;{lat:xxx,lng:xxx}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;遍历列表，把元素传入&lt;code&gt;google.maps.LatLngBounds&lt;/code&gt;实例的&lt;code&gt;extend&lt;/code&gt;方法&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; latlngbounds = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; google.maps.LatLngBounds();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;markerList.&lt;span class=&quot;keyword&quot;&gt;forEach&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(item)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  latlngbounds.extend(item);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;map.fitBounds(latlngbounds);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然而这有一个很多人提到的问题，就是缩放效果不平滑。(smooth这个词，我还是百度了smooth scroll才写的出字面意思来，我现在中文是有多差…)&lt;br&gt;这个暂时没什么解决方法，API本身就是这样的。据说谷歌本身的地图是h5的canvas绘制的，但通过API生成的地图不是同样的原理…谷歌居然自己都不用自己的API …&lt;/p&gt;
&lt;p&gt;另一个问题是，缩放&lt;strong&gt;太大力&lt;/strong&gt;怎么办？答案是，在&lt;code&gt;MapOptions&lt;/code&gt;中设置&lt;code&gt;maxZoom&lt;/code&gt;值&lt;/p&gt;
&lt;h3 id=&quot;动画效果切换&quot;&gt;&lt;a href=&quot;#动画效果切换&quot; class=&quot;headerlink&quot; title=&quot;动画效果切换&quot;&gt;&lt;/a&gt;动画效果切换&lt;/h3&gt;&lt;p&gt;API提供三种效果：&lt;code&gt;BOUNCE&lt;/code&gt; &lt;code&gt;DROP&lt;/code&gt; &lt;code&gt;NULL&lt;/code&gt;&lt;br&gt;使用场景大多数时候是在NULL和BOUNCE之间切换&lt;/p&gt;
&lt;p&gt;动画比较坑爹的是，每个动画都要持续700ms，之后才能改变状态。&lt;/p&gt;
&lt;p&gt;比如这样一个例子：有两组marker，&lt;strong&gt;有交集&lt;/strong&gt;。想要让第一组先BOUNCE，之后停止第一组，让第二组BOUNCE。很容易想到的方法是，通过遍历，把第一组的动画全部设置为NULL，再把第二组动画全部设置为BOUNCE。然而交集的这一部分只会BOUNCE一次然后就停了…因为计算速度很快，从NULL到BOUNCE不到700ms，动画其实还处于NULL状态。&lt;/p&gt;
&lt;p&gt;可以参考官方的这个例子，&lt;a href=&quot;https://developers.google.com/maps/documentation/javascript/examples/marker-animations&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developers.google.com/maps/documentation/javascript/examples/marker-animations&lt;/a&gt; ，当你双击marker的时候，其实就是模拟了快速切换状态，但动画效果并不如预期…&lt;/p&gt;
&lt;p&gt;解决方案：求差集，也就是把交集的部分去掉，在设置动画为NULL&lt;/p&gt;
&lt;h3 id=&quot;自定义地图样式&quot;&gt;&lt;a href=&quot;#自定义地图样式&quot; class=&quot;headerlink&quot; title=&quot;自定义地图样式&quot;&gt;&lt;/a&gt;自定义地图样式&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://snazzymaps.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://snazzymaps.com/&lt;/a&gt; 这个网站有很多已经设计好的样式，选喜欢的直接复制代码放到&lt;code&gt;StyledMapType()&lt;/code&gt;方法中即可，然后给这个样式取个名字，下例中我使用了&lt;a href=&quot;https://snazzymaps.com/style/134/light-dream&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;light dream&lt;/a&gt; 这个样式&lt;br&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; mapStyle = &lt;span class=&quot;built_in&quot;&gt;new&lt;/span&gt; google.maps.StyledMapType([....])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;map&lt;/span&gt;.mapTypes.set(&lt;span class=&quot;string&quot;&gt;&#39;lightDream&#39;&lt;/span&gt;, mapStyle);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;map&lt;/span&gt;.setMapTypeId(&lt;span class=&quot;string&quot;&gt;&#39;lightDream&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;遍历添加-event-listener-同时又需要传参数给-google-maps-event-addListener-的回调函数&quot;&gt;&lt;a href=&quot;#遍历添加-event-listener-同时又需要传参数给-google-maps-event-addListener-的回调函数&quot; class=&quot;headerlink&quot; title=&quot;遍历添加 event listener 同时又需要传参数给 google.maps.event.addListener() 的回调函数&quot;&gt;&lt;/a&gt;遍历添加 event listener 同时又需要传参数给 &lt;code&gt;google.maps.event.addListener()&lt;/code&gt; 的回调函数&lt;/h3&gt;&lt;p&gt;不太理解event.addListener的工作原理，但根据我踩的坑推测这是一个异步的方法（否则为什么有回调函数？！）&lt;/p&gt;
&lt;p&gt;这个时候就要用到高大上的&lt;strong&gt;闭包&lt;/strong&gt;。下面这个例子中，如果不把&lt;code&gt;addListener&lt;/code&gt;包起来，每次cityHandler收到的city都是遍历的最后一个city。因为遍历速度太快，而回调还没有执行，等回调执行的时候city已经遍历到最后一个了…&lt;/p&gt;
&lt;p&gt;不用闭包的话，用promise应该也能解决这个问题，但是感觉promise需要写的code会比较多一些。&lt;/p&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; cityList=[&amp;#123;marker:googleMapMarker,city:&lt;span class=&quot;string&quot;&gt;&#39;Beijing&#39;&lt;/span&gt;&amp;#125;,...];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cityList.&lt;span class=&quot;keyword&quot;&gt;forEach&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(item)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(marker, city)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    google.maps.event.addListener(marker, &lt;span class=&quot;string&quot;&gt;&#39;click&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(e)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      cityHandler(city);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;)(item.marker, item.city)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;原生marker图标&quot;&gt;&lt;a href=&quot;#原生marker图标&quot; class=&quot;headerlink&quot; title=&quot;原生marker图标&quot;&gt;&lt;/a&gt;原生marker图标&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://mabp.kiev.ua/2010/01/12/google-map-markers/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://mabp.kiev.ua/2010/01/12/google-map-markers/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;参考：&quot;&gt;&lt;a href=&quot;#参考：&quot; class=&quot;headerlink&quot; title=&quot;参考：&quot;&gt;&lt;/a&gt;参考：&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://developers.google.com/maps/documentation/javascript/reference&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developers.google.com/maps/documentation/javascript/reference&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;一直都想把自己去过的地方做个地图标记，然而现在能找到的各种现成的地图产品都不太喜欢，所以就用谷歌地图自己写了一个。&lt;br&gt;总结以下常见的问题和坑：&lt;/p&gt;
&lt;h3 id=&quot;自动缩放-auto-zoom&quot;&gt;&lt;a href=&quot;#自动缩放-auto-zoom&quot; class=&quot;he
    
    </summary>
    
    
      <category term="Google Map" scheme="http://sabrinaluo.com/tech/tags/Google-Map/"/>
    
      <category term="Google Map API" scheme="http://sabrinaluo.com/tech/tags/Google-Map-API/"/>
    
      <category term="谷歌地图" scheme="http://sabrinaluo.com/tech/tags/%E8%B0%B7%E6%AD%8C%E5%9C%B0%E5%9B%BE/"/>
    
      <category term="谷歌地图API" scheme="http://sabrinaluo.com/tech/tags/%E8%B0%B7%E6%AD%8C%E5%9C%B0%E5%9B%BEAPI/"/>
    
  </entry>
  
  <entry>
    <title>git如何ignore已经track的文件</title>
    <link href="http://sabrinaluo.com/tech/2016/02/01/git-how-to-ignore-tracked-files/"/>
    <id>http://sabrinaluo.com/tech/2016/02/01/git-how-to-ignore-tracked-files/</id>
    <published>2016-02-01T06:01:03.000Z</published>
    <updated>2016-02-17T07:55:27.154Z</updated>
    
    <content type="html">&lt;p&gt;我也不想中英文混杂的取标题……但我实在翻译无能…_(:з」∠)_&lt;/p&gt;
&lt;h3 id=&quot;基本知识&quot;&gt;&lt;a href=&quot;#基本知识&quot; class=&quot;headerlink&quot; title=&quot;基本知识&quot;&gt;&lt;/a&gt;基本知识&lt;/h3&gt;&lt;p&gt;在git中文件有两类，共三种状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;untracked&lt;/li&gt;
&lt;li&gt;tracked&lt;ul&gt;
&lt;li&gt;changes not staged for commit&lt;/li&gt;
&lt;li&gt;changes to be committed&lt;br&gt;我们都知道，在&lt;code&gt;.gitignore&lt;/code&gt;文件里添加相应的文件夹或文件就能忽略掉不想被track的文件。&lt;br&gt;但是，&lt;code&gt;.gitignore&lt;/code&gt;文件只能忽略&lt;strong&gt;Untracked files&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;适用场景&quot;&gt;&lt;a href=&quot;#适用场景&quot; class=&quot;headerlink&quot; title=&quot;适用场景&quot;&gt;&lt;/a&gt;适用场景&lt;/h3&gt;&lt;p&gt;参考这样一个例子：&lt;br&gt;一个项目因为一些莫名其妙的原因对&lt;code&gt;node_modules&lt;/code&gt;文件夹进行了track，然后每次check out出来&lt;code&gt;npm install&lt;/code&gt;的时候，很可能这些依赖包就更新了，然后又因为一些莫名其妙的原因，始终没有人把这个文件夹移出git的index，于是你也不好意思删除这个文件夹做一次commit。然而，每次都有几十上百条&lt;code&gt;modified: node_modules/xxx&lt;/code&gt;，根本找不到自己真正修改和添加的文件…&lt;/p&gt;
&lt;p&gt;于是问题来了，怎么样才能把&lt;code&gt;node_module&lt;/code&gt; ignore，但又不commit这些change呢？&lt;/p&gt;
&lt;h3 id=&quot;解决方法&quot;&gt;&lt;a href=&quot;#解决方法&quot; class=&quot;headerlink&quot; title=&quot;解决方法&quot;&gt;&lt;/a&gt;解决方法&lt;/h3&gt;&lt;p&gt;正常情况，跑以下的命令就能忽略掉已经track的&lt;strong&gt;文件夹&lt;/strong&gt;：&lt;br&gt;&lt;figure class=&quot;highlight vim&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;keyword&quot;&gt;ls&lt;/span&gt;-&lt;span class=&quot;keyword&quot;&gt;files&lt;/span&gt; -&lt;span class=&quot;keyword&quot;&gt;z&lt;/span&gt; node_modules/ | xargs -&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; git &lt;span class=&quot;keyword&quot;&gt;update&lt;/span&gt;-&lt;span class=&quot;built_in&quot;&gt;index&lt;/span&gt; --assume-unchanged&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果只需要忽略&lt;strong&gt;单个文件&lt;/strong&gt;，则以下命令就能搞定。&lt;br&gt;&lt;figure class=&quot;highlight fortran&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git update-&lt;span class=&quot;built_in&quot;&gt;index&lt;/span&gt; --assume-unchanged &amp;lt;&lt;span class=&quot;keyword&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;因为update-index不支持递归&lt;code&gt;-r&lt;/code&gt;，所以只能通过上面提到的方法来实现忽略文件夹&lt;br&gt;（憋问我为什么不支持…我也不知道）&lt;/p&gt;
&lt;h3 id=&quot;另一种情况：将tracked文件移出index，但仍然保留在本地&quot;&gt;&lt;a href=&quot;#另一种情况：将tracked文件移出index，但仍然保留在本地&quot; class=&quot;headerlink&quot; title=&quot;另一种情况：将tracked文件移出index，但仍然保留在本地&quot;&gt;&lt;/a&gt;另一种情况：将tracked文件移出index，但仍然保留在本地&lt;/h3&gt;&lt;p&gt;终于有一天，大家想通了，决定将&lt;code&gt;node_modules&lt;/code&gt;文件夹移出git index，但是如果删除了整个文件夹commit之后，项目要跑起来，又要重新&lt;code&gt;npm install&lt;/code&gt;，懒癌患者倒地不起…&lt;/p&gt;
&lt;p&gt;下面这个命令可以解决上述问题：&lt;br&gt;&lt;figure class=&quot;highlight applescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git rm &lt;span class=&quot;comment&quot;&gt;--cached -r node_modules&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;吐槽&quot;&gt;&lt;a href=&quot;#吐槽&quot; class=&quot;headerlink&quot; title=&quot;吐槽&quot;&gt;&lt;/a&gt;吐槽&lt;/h3&gt;&lt;p&gt;我反正是无法理解把诸如npm包，bower包，composer包等等等的第三方依赖放到git里去track，那么还要package.json干啥=，=&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;我也不想中英文混杂的取标题……但我实在翻译无能…_(:з」∠)_&lt;/p&gt;
&lt;h3 id=&quot;基本知识&quot;&gt;&lt;a href=&quot;#基本知识&quot; class=&quot;headerlink&quot; title=&quot;基本知识&quot;&gt;&lt;/a&gt;基本知识&lt;/h3&gt;&lt;p&gt;在git中文件有两类，共三种状态：&lt;/p&gt;

    
    </summary>
    
    
      <category term="git" scheme="http://sabrinaluo.com/tech/tags/git/"/>
    
      <category term="gitignore" scheme="http://sabrinaluo.com/tech/tags/gitignore/"/>
    
      <category term="update index" scheme="http://sabrinaluo.com/tech/tags/update-index/"/>
    
  </entry>
  
  <entry>
    <title>Promise的顺序执行和并行执行</title>
    <link href="http://sabrinaluo.com/tech/2016/01/23/excecute-parallel-promise-and-sequential-promise/"/>
    <id>http://sabrinaluo.com/tech/2016/01/23/excecute-parallel-promise-and-sequential-promise/</id>
    <published>2016-01-23T14:52:26.000Z</published>
    <updated>2016-02-17T07:55:27.154Z</updated>
    
    <content type="html">&lt;p&gt;并行和顺序执行的前提当然是，有一堆promise等着你去执行……&lt;br&gt;通常我们把这“一堆”promise对象放到一个数组里，&lt;code&gt;[promise1, promise2, promise3, ...]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们都知道想要让promise按顺序执行，那就是一个接一个的then。然而手写很多then太累了，而嵌套的promise又是反模式，我之前蠢蠢的&lt;a href=&quot;tech/2016/01/18/sequentialize-promise-by-recursion/&quot;&gt;用递归解决了顺序执行的问题&lt;/a&gt;，后来终于在udacity习得了顺序promise的正确打开方式！&lt;/p&gt;
&lt;h3 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h3&gt;&lt;p&gt;假如我们要去拿github按关键字搜索google, amazon, facebook，每个关键字搜出的第一个用户的第一个repo的名字。&lt;br&gt;单独拿一个，比如google，过程是这样的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;请求&lt;a href=&quot;https://api.github.com/search/users?q=google&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://api.github.com/search/users?q=google&lt;/a&gt; ，得到用户列表，读取第一个用户的repos_url&lt;/li&gt;
&lt;li&gt;请求上一步读取的repous_url，获得repo列表，读取第一个repo的名字&lt;br&gt;显然，第二步是依赖于第一步的执行结果的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此，很容易想到下面几种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;等第一步全部执行完，再执行第二步（并行执行）&lt;/p&gt;
&lt;figure class=&quot;highlight gherkin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;|&lt;span class=&quot;string&quot;&gt;--------------------&lt;/span&gt;|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;google第一步          |&lt;span class=&quot;string&quot;&gt;------------------&lt;/span&gt;|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;amazon第一步        google第二步&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;facebook第一步      amazon第二步 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                   facebook第二步&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对第一步的顺序有要求，必须严格按照google, amazon, facebook的顺序执行（顺序执行）&lt;/p&gt;
&lt;figure class=&quot;highlight gherkin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;|&lt;span class=&quot;string&quot;&gt;---------&lt;/span&gt;|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;google1   |&lt;span class=&quot;string&quot;&gt;---------&lt;/span&gt;|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            google2 |&lt;span class=&quot;string&quot;&gt;---------&lt;/span&gt;|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     amazon1  |&lt;span class=&quot;string&quot;&gt;---------&lt;/span&gt;|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                              amazon2   |&lt;span class=&quot;string&quot;&gt;---------&lt;/span&gt;|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                        facebook1 |&lt;span class=&quot;string&quot;&gt;--------&lt;/span&gt;|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                  facebook2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;google1执行完就执行google1，amazon1执行完就执行amazon2，但对google, amazon, facebook的顺序没有要求&lt;/p&gt;
&lt;figure class=&quot;highlight gherkin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;|&lt;span class=&quot;string&quot;&gt;------------------&lt;/span&gt;|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;google1            |&lt;span class=&quot;string&quot;&gt;-------------&lt;/span&gt;|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                   google2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|&lt;span class=&quot;string&quot;&gt;---------&lt;/span&gt;|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;amazon1   |&lt;span class=&quot;string&quot;&gt;-----------&lt;/span&gt;|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          amazon2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|&lt;span class=&quot;string&quot;&gt;------------&lt;/span&gt;|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;facebook1    |&lt;span class=&quot;string&quot;&gt;-------------&lt;/span&gt;|&lt;span class=&quot;string&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             facebook2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Promise并行执行&quot;&gt;&lt;a href=&quot;#Promise并行执行&quot; class=&quot;headerlink&quot; title=&quot;Promise并行执行&quot;&gt;&lt;/a&gt;Promise并行执行&lt;/h3&gt;&lt;p&gt;对于场景1，主要就是用到&lt;code&gt;Promise.all&lt;/code&gt;，因为是数组，所以在处理的过程中通常会用到&lt;code&gt;.map&lt;/code&gt;或&lt;code&gt;.forEach&lt;/code&gt;&lt;br&gt;&lt;iframe width=&quot;100%&quot; height=&quot;300&quot; src=&quot;http://jsfiddle.net/HiiTea/zfjvr4pz/1/embedded/js,resources,html,css,result/light&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;br&gt;&lt;img src=&quot;http://7xow88.com1.z0.glb.clouddn.com/tech-promise1.png&quot; alt=&quot;promise例1网络请求时间线&quot;&gt;&lt;br&gt;可以看到3个user请求是同时进行（并行），3个repos请求也是同时进行（并行），由于使用了&lt;code&gt;Promise.all&lt;/code&gt;，所以repos请求等待users请求全部完成才开始。&lt;/p&gt;
&lt;h3 id=&quot;promise顺序执行的正确打开方式&quot;&gt;&lt;a href=&quot;#promise顺序执行的正确打开方式&quot; class=&quot;headerlink&quot; title=&quot;promise顺序执行的正确打开方式&quot;&gt;&lt;/a&gt;promise顺序执行的正确打开方式&lt;/h3&gt;&lt;p&gt;对于场景2，有一个小技巧，我第一次看到的时候感受是…惊为天人&lt;br&gt;按照顺序执行，容易想到的有以下几种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;then.then.then，从头then到尾…&lt;/li&gt;
&lt;li&gt;then(then(then()))，then的嵌套…&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;promise链的本质其实就是从头then到尾，但是第一种方法怎么用程序来实现，也就是上面提到的小技巧，就是值得学习的地方了。（反正我觉得太巧妙了！！！我自己就想不到…）&lt;/p&gt;
&lt;p&gt;大概跟在做求和运算时候的思想一样：&lt;br&gt;&lt;figure class=&quot;highlight fortran&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//求和的时候通常这么做，先定义一个&lt;span class=&quot;built_in&quot;&gt;sum&lt;/span&gt;，然后依次往里做加法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var &lt;span class=&quot;built_in&quot;&gt;sum&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;array.forEach(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(item)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;sum&lt;/span&gt; = &lt;span class=&quot;built_in&quot;&gt;sum&lt;/span&gt; + item;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight fortran&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//要得到一个&lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;的promise链，先定义一个已经resolve了的promise，然后依次往后&lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;…&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var &lt;span class=&quot;keyword&quot;&gt;sequence&lt;/span&gt; = Promise.resolve();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;array.forEach(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(item)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;sequence&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;sequence&lt;/span&gt;.&lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;(...)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下面给出场景2的代码：&lt;br&gt;&lt;iframe width=&quot;100%&quot; height=&quot;300&quot; src=&quot;http://jsfiddle.net/HiiTea/sq2aga08/embedded/js,resources,html,css,result/light&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;br&gt;&lt;img src=&quot;http://7xow88.com1.z0.glb.clouddn.com/tech-promise2.png&quot; alt=&quot;promise例2网络请求时间线&quot;&gt;&lt;br&gt;可以看到请求是按顺序依次发出&lt;/p&gt;
&lt;h3 id=&quot;并行执行和顺序执行混用&quot;&gt;&lt;a href=&quot;#并行执行和顺序执行混用&quot; class=&quot;headerlink&quot; title=&quot;并行执行和顺序执行混用&quot;&gt;&lt;/a&gt;并行执行和顺序执行混用&lt;/h3&gt;&lt;p&gt;场景3:&lt;br&gt;&lt;iframe width=&quot;100%&quot; height=&quot;300&quot; src=&quot;http://jsfiddle.net/HiiTea/z09xjowq/1/embedded/js,resources,html,css,result/light&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;br&gt;&lt;img src=&quot;http://7xow88.com1.z0.glb.clouddn.com/tech-promise3.png&quot; alt=&quot;promise例3网络请求时间线&quot;&gt;&lt;br&gt;可以看到users请求是并行发出，但完成时间不一样，而repos请求是在&lt;strong&gt;对应的&lt;/strong&gt;users请求完成后就立即执行&lt;/p&gt;
&lt;h3 id=&quot;混用的另一种情况&quot;&gt;&lt;a href=&quot;#混用的另一种情况&quot; class=&quot;headerlink&quot; title=&quot;混用的另一种情况&quot;&gt;&lt;/a&gt;混用的另一种情况&lt;/h3&gt;&lt;p&gt;有了以上的知识，很容易写出最后一种混用的情况，users按顺序执行，等users全部执行完之后并发执行repos。我比较懒…这个我就不写了…&lt;/p&gt;
&lt;h3 id=&quot;补充知识：&quot;&gt;&lt;a href=&quot;#补充知识：&quot; class=&quot;headerlink&quot; title=&quot;补充知识：&quot;&gt;&lt;/a&gt;补充知识：&lt;/h3&gt;&lt;h4 id=&quot;浏览器的fetch-API&quot;&gt;&lt;a href=&quot;#浏览器的fetch-API&quot; class=&quot;headerlink&quot; title=&quot;浏览器的fetch API&quot;&gt;&lt;/a&gt;浏览器的fetch API&lt;/h4&gt;&lt;p&gt;本文跟fetch不是充分必要关系，只是我太懒了不想写太多的代码来举例。你可以把它理解为是用Promise包住的&lt;code&gt;$.ajax&lt;/code&gt;，也就是fetch返回一个promise对象。关于fetch的详细用法请参考&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MDN Fetch_ API&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;如何查看请求的发送是并行还是顺序&quot;&gt;&lt;a href=&quot;#如何查看请求的发送是并行还是顺序&quot; class=&quot;headerlink&quot; title=&quot;如何查看请求的发送是并行还是顺序&quot;&gt;&lt;/a&gt;如何查看请求的发送是并行还是顺序&lt;/h4&gt;&lt;p&gt;打开chrome，按F12，选中Network选项卡，在No throttling这个下拉列表选GPRS，再运行代码，然后就能清楚的看到各个请求的时间线了。&lt;/p&gt;
&lt;p&gt;如果看到的区别不是很明显，很可能是已经缓存了，清空浏览器的缓存在重复上面的步骤就能看到比较明显的区别了。&lt;/p&gt;
&lt;h3 id=&quot;参考：&quot;&gt;&lt;a href=&quot;#参考：&quot; class=&quot;headerlink&quot; title=&quot;参考：&quot;&gt;&lt;/a&gt;参考：&lt;/h3&gt;&lt;p&gt;[1] &lt;a href=&quot;https://www.udacity.com/course/viewer#!/c-ud898&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.udacity.com/course/viewer#!/c-ud898&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;并行和顺序执行的前提当然是，有一堆promise等着你去执行……&lt;br&gt;通常我们把这“一堆”promise对象放到一个数组里，&lt;code&gt;[promise1, promise2, promise3, ...]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们都知道想要让promise按顺序
    
    </summary>
    
    
      <category term="Promise" scheme="http://sabrinaluo.com/tech/tags/Promise/"/>
    
      <category term="parallel" scheme="http://sabrinaluo.com/tech/tags/parallel/"/>
    
      <category term="sequential" scheme="http://sabrinaluo.com/tech/tags/sequential/"/>
    
      <category term="顺序执行，并行执行" scheme="http://sabrinaluo.com/tech/tags/%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%EF%BC%8C%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>对浏览器跨域问题的一些理解</title>
    <link href="http://sabrinaluo.com/tech/2016/01/22/understanding-of-CORS/"/>
    <id>http://sabrinaluo.com/tech/2016/01/22/understanding-of-CORS/</id>
    <published>2016-01-22T07:08:33.000Z</published>
    <updated>2016-02-17T07:55:27.154Z</updated>
    
    <content type="html">&lt;h3 id=&quot;问题宝宝&quot;&gt;&lt;a href=&quot;#问题宝宝&quot; class=&quot;headerlink&quot; title=&quot;问题宝宝&quot;&gt;&lt;/a&gt;问题宝宝&lt;/h3&gt;&lt;h4 id=&quot;1-移动应用开发&quot;&gt;&lt;a href=&quot;#1-移动应用开发&quot; class=&quot;headerlink&quot; title=&quot;1 移动应用开发&quot;&gt;&lt;/a&gt;1 移动应用开发&lt;/h4&gt;&lt;p&gt;之前用Ionic写mobile app，移动app自然是少不了调用RESTful API的数据。&lt;br&gt;开发的时候用浏览器进行调试，然后console里不停的出现下面的提示(&lt;strong&gt;Access-Control-Allow-Origin&lt;/strong&gt;)：&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;XMLHttpRequest cannot &lt;span class=&quot;operator&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;load&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;http&lt;/span&gt;://samlino.&lt;span class=&quot;keyword&quot;&gt;local&lt;/span&gt;/cag/get_leads. &lt;span class=&quot;keyword&quot;&gt;No&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;Access-Control-Allow-Origin&#39;&lt;/span&gt; header &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;present&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;on&lt;/span&gt; the requested &lt;span class=&quot;keyword&quot;&gt;resource&lt;/span&gt;. Origin &lt;span class=&quot;string&quot;&gt;&#39;http://localhost:63342&#39;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; therefore &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; allowed &lt;span class=&quot;keyword&quot;&gt;access&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;而我当时的解决方法是，在chrome装了一个叫&lt;a href=&quot;https://chrome.google.com/webstore/detail/allow-control-allow-origi/nlfbmbojpeacfghkpbjhddihlkkiljbi&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Allow-Control-Allow-Origin&lt;/a&gt;的扩展，启用之后就不报错了。&lt;/p&gt;
&lt;p&gt;也不知道什么什么原理，反正就这么一直用着。（不思进取）&lt;/p&gt;
&lt;h4 id=&quot;2-网络应用开发&quot;&gt;&lt;a href=&quot;#2-网络应用开发&quot; class=&quot;headerlink&quot; title=&quot;2 网络应用开发&quot;&gt;&lt;/a&gt;2 网络应用开发&lt;/h4&gt;&lt;p&gt;后来写单页应用（SPA），静态文件的js里调用各大公司的API， github、facebook什么的，反正从来没有报过上面的错…&lt;br&gt;另外还写过用NodeJS做中间层，从NodeJS去API拿数据然后渲染再发到前端，也从来没报过错…&lt;/p&gt;
&lt;p&gt;最近的一个case是，我们有用AWS API Gateway, Lambda, DynamoDB搭建的API，API被调用的时候就会trigger一系列的任务。然后有个小哥偷懒不想写PHP，想在前端直接请求AWS的API。于是问题来了…&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浏览器不停的提示No ‘Access-Control-Allow-Origin’的错误， 拿不到任何返回的数据。&lt;/li&gt;
&lt;li&gt;但是！服务器该做的job却都做了！&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这根本不科学啊！！！所以？到底是什么鬼？！&lt;/p&gt;
&lt;h3 id=&quot;同源策略-Same-Origin-Policy&quot;&gt;&lt;a href=&quot;#同源策略-Same-Origin-Policy&quot; class=&quot;headerlink&quot; title=&quot;同源策略(Same Origin Policy)&quot;&gt;&lt;/a&gt;同源策略(Same Origin Policy)&lt;/h3&gt;&lt;p&gt;同源策略就是只有访问的内容来自&lt;strong&gt;相同协议、相同主机、相同端口&lt;/strong&gt;的内容&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;^1&lt;/a&gt;时，才会加载访问得到的内容。&lt;strong&gt;浏览器是同源策略的一种实现&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;协议：&lt;code&gt;location.protocol&lt;/code&gt;，http和https是两种不同的协议&lt;/li&gt;
&lt;li&gt;主机：&lt;code&gt;location.host&lt;/code&gt;，不同子域名之间都算跨域，例如www.baidu.com, tieba.baidu.com是两个不同的源&lt;/li&gt;
&lt;li&gt;端口：&lt;code&gt;location.port&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;CORS&quot;&gt;&lt;a href=&quot;#CORS&quot; class=&quot;headerlink&quot; title=&quot;CORS&quot;&gt;&lt;/a&gt;CORS&lt;/h3&gt;&lt;p&gt;之前脑子里大概有个&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CORS&lt;/a&gt;的概念，然后一直以为是服务器拒绝从浏览器跨域访问…因为要解决自己call自己不同域名下的API问题，就是去服务器设置一下header…但其实是都是浏览器在作怪…&lt;/p&gt;
&lt;p&gt;在浏览器中，允许跨域访问的资源的一些例子&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy#Cross-origin_network_access&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;^2&lt;/a&gt;：&lt;br&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;...&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;br&gt;&lt;code&gt;&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;...&amp;quot;&amp;gt;&lt;/code&gt;&lt;br&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;br&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;br&gt;&lt;code&gt;@font-face&lt;/code&gt;&lt;br&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;Response-Headers&quot;&gt;&lt;a href=&quot;#Response-Headers&quot; class=&quot;headerlink&quot; title=&quot;Response Headers&quot;&gt;&lt;/a&gt;Response Headers&lt;/h3&gt;&lt;p&gt;先看看可以在浏览器中跨域请求的别人家(github)的API返回的header：&lt;br&gt;&lt;figure class=&quot;highlight tp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Access-Control-Allow-Credentials:true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Access-Control-Allow-Origin:*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Access-Control-Expose-Headers:ETag, Link, &lt;span class=&quot;keyword&quot;&gt;X&lt;/span&gt;-GitHub-OTP, &lt;span class=&quot;keyword&quot;&gt;X&lt;/span&gt;-RateLimit-Limit, &lt;span class=&quot;keyword&quot;&gt;X&lt;/span&gt;-RateLimit-Remaining, &lt;span class=&quot;keyword&quot;&gt;X&lt;/span&gt;-RateLimit-Reset, &lt;span class=&quot;keyword&quot;&gt;X&lt;/span&gt;-OAuth-Scopes, &lt;span class=&quot;keyword&quot;&gt;X&lt;/span&gt;-Accepted-OAuth-Scopes, &lt;span class=&quot;keyword&quot;&gt;X&lt;/span&gt;-Poll-Interval&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;看看自家API返回的header&lt;br&gt;&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;Connection&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:keep-alive&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;Content&lt;/span&gt;-&lt;span class=&quot;constant&quot;&gt;Encoding&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:gzip&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;Content&lt;/span&gt;-&lt;span class=&quot;constant&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:text/html&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:Fri&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;22&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;Jan&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2016&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;07&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;07&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;01&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;GMT&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;差别就在于别人家的API返回了&lt;strong&gt;Access-Control-Allow-Origin:*&lt;/strong&gt;&lt;br&gt;浏览器读到这个头部之后，才会加载请求的结果。&lt;/p&gt;
&lt;h3 id=&quot;跨域的时候服务器收到请求了吗？&quot;&gt;&lt;a href=&quot;#跨域的时候服务器收到请求了吗？&quot; class=&quot;headerlink&quot; title=&quot;跨域的时候服务器收到请求了吗？&quot;&gt;&lt;/a&gt;跨域的时候服务器收到请求了吗？&lt;/h3&gt;&lt;p&gt;服务器当然收到请求了，不然怎么能返回头部…而且我上面举的诡异的例子中，请求trigger的job都完成了。&lt;/p&gt;
&lt;p&gt;所以也就是说，服务器其实收到了你的请求，并且给你返回了全部的数据，但是浏览器看到头部就把body藏起来了，然后抛出错误提示…&lt;/p&gt;
&lt;h3 id=&quot;为什么浏览器不允许跨域访问？&quot;&gt;&lt;a href=&quot;#为什么浏览器不允许跨域访问？&quot; class=&quot;headerlink&quot; title=&quot;为什么浏览器不允许跨域访问？&quot;&gt;&lt;/a&gt;为什么浏览器不允许跨域访问？&lt;/h3&gt;&lt;p&gt;当然是为了安全……但是这个有点不太好理解，api拿点数据有什么不安全的？！&lt;/p&gt;
&lt;p&gt;下面这个例子比较清楚的说明同源策略是如何避免安全问题的：&lt;a href=&quot;http://stackoverflow.com/questions/9222822/why-do-browser-apis-restrict-cross-domain-requests&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;^3&lt;/a&gt;&lt;br&gt;网站A：一个看起来跟银行网站几乎一样的假网站&lt;br&gt;网站B：真正的银行网站&lt;br&gt;如果没有同源策略：&lt;br&gt;1.当用户来到A网站，以为是真的银行网站，然后输入自己的账号、密码（此时用户的账号、密码已经被网站A获取了）&lt;br&gt;2.网站A利用ajax把账号密码发到真正的银行网站B，然后银行网站返回一个带有token的form需要用户输入手机验证码。&lt;br&gt;3.网站A获得这个form之后显示出来，让用户填入手机验证码……至此，网站A获得了账号、密码、手机验证码，已经可以登陆用户的账号了。&lt;/p&gt;
&lt;p&gt;而当有同源策略时，到第2步的时候，网站A根本无法获取银行网站返回的带token的form，所以就算有了账户和密码，也无法操作用户的账户。&lt;/p&gt;
&lt;p&gt;当然啦，银行的加密机制肯定没有我描述的这么弱智，不然还要U盾之类的东东干嘛，这只是一个为了方便理解安全问题而杜撰的例子…&lt;/p&gt;
&lt;h3 id=&quot;好奇宝宝&quot;&gt;&lt;a href=&quot;#好奇宝宝&quot; class=&quot;headerlink&quot; title=&quot;好奇宝宝&quot;&gt;&lt;/a&gt;好奇宝宝&lt;/h3&gt;&lt;p&gt;不知道chrome的这个插件&lt;a href=&quot;https://chrome.google.com/webstore/detail/allow-control-allow-origi/nlfbmbojpeacfghkpbjhddihlkkiljbi&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Allow-Control-Allow-Origin&lt;/a&gt;，是怎么实现允许跨域请求的。&lt;br&gt;之前发现启用插件的时候，github上的小图标全都不显示了…&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题宝宝&quot;&gt;&lt;a href=&quot;#问题宝宝&quot; class=&quot;headerlink&quot; title=&quot;问题宝宝&quot;&gt;&lt;/a&gt;问题宝宝&lt;/h3&gt;&lt;h4 id=&quot;1-移动应用开发&quot;&gt;&lt;a href=&quot;#1-移动应用开发&quot; class=&quot;headerlink&quot; title=&quot;1
    
    </summary>
    
    
      <category term="CORS" scheme="http://sabrinaluo.com/tech/tags/CORS/"/>
    
      <category term="corss domain" scheme="http://sabrinaluo.com/tech/tags/corss-domain/"/>
    
      <category term="同源策略" scheme="http://sabrinaluo.com/tech/tags/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"/>
    
      <category term="浏览器" scheme="http://sabrinaluo.com/tech/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="跨域" scheme="http://sabrinaluo.com/tech/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>递归实现按顺序执行Promise</title>
    <link href="http://sabrinaluo.com/tech/2016/01/18/sequentialize-promise-by-recursion/"/>
    <id>http://sabrinaluo.com/tech/2016/01/18/sequentialize-promise-by-recursion/</id>
    <published>2016-01-18T09:23:18.000Z</published>
    <updated>2016-02-17T07:55:27.154Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;2016-01-24更新&lt;/strong&gt;&lt;br&gt;我还是觉得嵌套多层的promise是反模式，不推荐使用，机智的我学会了另一种不嵌套不递归的方法，请看这里：&lt;br&gt;(Promise的顺序执行和并行执行](tech/2016/01/23/excecute-parallel-promise-and-sequential-promise)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以下为原文：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之前我一直有个疑问，当我有一堆promise的时候，怎么按顺序执行它们呢？&lt;/p&gt;
&lt;p&gt;网上搜到的大多数教程都是建一个数组&lt;code&gt;array&lt;/code&gt;，把promise对象放到数组里，然后数组中的promise全部执行完毕时调用&lt;code&gt;Promise.all(array)&lt;/code&gt;。然而这只适用于数组中的&lt;strong&gt;promise对象不互相依赖&lt;/strong&gt;的情况。&lt;/p&gt;
&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;我之前提到过一个典型的例子是Facebook的Graph API 中的分页问题（ &lt;a href=&quot;https://developers.facebook.com/docs/graph-api/using-graph-api#paging&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Cursor-based Pagination&lt;/a&gt;），API的Response如下：&lt;br&gt;&lt;figure class=&quot;highlight json&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &quot;&lt;span class=&quot;attribute&quot;&gt;data&lt;/span&gt;&quot;: &lt;span class=&quot;value&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     ... Endpoint data is here&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ]&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &quot;&lt;span class=&quot;attribute&quot;&gt;paging&lt;/span&gt;&quot;: &lt;span class=&quot;value&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &quot;&lt;span class=&quot;attribute&quot;&gt;cursors&lt;/span&gt;&quot;: &lt;span class=&quot;value&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &quot;&lt;span class=&quot;attribute&quot;&gt;after&lt;/span&gt;&quot;: &lt;span class=&quot;value&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;MTAxNTExOTQ1MjAwNzI5NDE=&quot;&lt;/span&gt;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &quot;&lt;span class=&quot;attribute&quot;&gt;before&lt;/span&gt;&quot;: &lt;span class=&quot;value&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;NDMyNzQyODI3OTQw&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&amp;#125;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &quot;&lt;span class=&quot;attribute&quot;&gt;previous&lt;/span&gt;&quot;: &lt;span class=&quot;value&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;https://graph.facebook.com/me/albums?limit=25&amp;amp;amp;before=NDMyNzQyODI3OTQw&quot;&lt;/span&gt;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &quot;&lt;span class=&quot;attribute&quot;&gt;next&lt;/span&gt;&quot;: &lt;span class=&quot;value&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;https://graph.facebook.com/me/albums?limit=25&amp;amp;amp;after=MTAxNTExOTQ1MjAwNzI5NDE=&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;简单的一个例子是，当我想要获取一个人的完整好友列表（Friend List），但是这个人好友太多了，分成了很多页。显然这些结果是互相依赖的。我必须先拿到第一页的&lt;code&gt;paging.next&lt;/code&gt;，才能进行下一次请求。（别跟我说改query string &lt;code&gt;limit&lt;/code&gt;后面的值，limit是有最大限制的=，=）&lt;/p&gt;
&lt;h3 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;解决方案&lt;/h3&gt;&lt;h5 id=&quot;当知道总共有多少页的时候&quot;&gt;&lt;a href=&quot;#当知道总共有多少页的时候&quot; class=&quot;headerlink&quot; title=&quot;当知道总共有多少页的时候&quot;&gt;&lt;/a&gt;当知道总共有多少页的时候&lt;/h5&gt;&lt;p&gt;(假设request是一个返回promise对象的函数,resolve的是上面的json)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;普通程序员这么做&lt;figure class=&quot;highlight lua&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var url = &lt;span class=&quot;string&quot;&gt;&#39;http://xxx&#39;&lt;/span&gt;; //first page&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;request(url)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .&lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(data)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; request(data.&lt;span class=&quot;built_in&quot;&gt;next&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .&lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(data)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; request(data.&lt;span class=&quot;built_in&quot;&gt;next&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;) //....&lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其实这么一直then下去也是可以的…&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二逼程序员这么做&lt;br&gt;回调函数层层嵌套…Callback Hell。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;当不知道总共多少页的时候&quot;&gt;&lt;a href=&quot;#当不知道总共多少页的时候&quot; class=&quot;headerlink&quot; title=&quot;当不知道总共多少页的时候&quot;&gt;&lt;/a&gt;当不知道总共多少页的时候&lt;/h5&gt;&lt;p&gt;不停then的方法就不行了，于是有了文艺的程序员&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文艺程序员这么做&lt;br&gt;首先要知道的一点是，当没有下一页的时候，返回的&lt;code&gt;next=null&lt;/code&gt;，于是我们就有了递归的终止条件。&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(url)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!url) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (url) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; request(url).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(data)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      run(data.paging.next);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; url = &lt;span class=&quot;string&quot;&gt;&#39;http://xxx&#39;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// first page&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;run(url);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;瞎扯&quot;&gt;&lt;a href=&quot;#瞎扯&quot; class=&quot;headerlink&quot; title=&quot;瞎扯&quot;&gt;&lt;/a&gt;瞎扯&lt;/h3&gt;&lt;p&gt;嵌套的Promise其实&lt;strong&gt;可能&lt;/strong&gt;是反模式（anti-pattern）&lt;a href=&quot;http://taoofcode.net/promise-anti-patterns/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;^1&lt;/a&gt;，但是本文中的情况，如果不递归用嵌套的promise，我实在想不出别的办法来了（ (๑•́ ₃ •̀)宝宝心里苦，但宝宝不说）&lt;/p&gt;
&lt;p&gt;为什么说可能是呢，因为谷歌一搜“promise anti pattern nesting”，总能搜出一大堆关于嵌套promise是反模式的文章。然而bluebird的wiki&lt;a href=&quot;https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;^2&lt;/a&gt;中，并没有提到嵌套的promise是反模式。&lt;/p&gt;
&lt;p&gt;所以到底是不是反模式，我也不知道=，=大概的想法是，在能不嵌套的时候就不要嵌套，否则还不如用callback。&lt;/p&gt;
&lt;p&gt;能不嵌套的情况是说，then的都是完全不同的promise，如果都是then类似的promise，那么，懒人还是递归吧…&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;2016-01-24更新&lt;/strong&gt;&lt;br&gt;我还是觉得嵌套多层的promise是反模式，不推荐使用，机智的我学会了另一种不嵌套不递归的方法，请看这里：&lt;br&gt;(Promise的顺序执行和并行执行](tech/2016/01/23/excecute-pa
    
    </summary>
    
    
      <category term="promise" scheme="http://sabrinaluo.com/tech/tags/promise/"/>
    
      <category term="递归" scheme="http://sabrinaluo.com/tech/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>对generator和yield的一些理解</title>
    <link href="http://sabrinaluo.com/tech/2016/01/12/ES6-generator-yield/"/>
    <id>http://sabrinaluo.com/tech/2016/01/12/ES6-generator-yield/</id>
    <published>2016-01-12T09:11:28.000Z</published>
    <updated>2016-02-17T07:55:27.154Z</updated>
    
    <content type="html">&lt;p&gt;于是也是入了ES6的坑，为什么只有babel这种ES6转ES5的工具，而没有ES5转ES6的工具呢？可能有，但是我不知道。如果有的话，就能把5转成6，起码看起来逼格高了一大截，也能让我这种还不习惯ES6的小白假装会写ES6…&lt;/p&gt;
&lt;p&gt;简单的看了一下相关的概念，觉得还不太理解…就好像最开始看&lt;em&gt;原型链&lt;/em&gt;一样，花了一年多才慢慢理解继承啊什么的，但&lt;code&gt;constructor&lt;/code&gt;和&lt;code&gt;__proto__&lt;/code&gt;之类的东东我也还（4声）没整明白…真是资质愚钝QAQ&lt;/p&gt;
&lt;h3 id=&quot;generator-function&quot;&gt;&lt;a href=&quot;#generator-function&quot; class=&quot;headerlink&quot; title=&quot;generator function&quot;&gt;&lt;/a&gt;generator function&lt;/h3&gt;&lt;p&gt;一个generator函数大概长这样：&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;function* &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.&lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;111&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  yield &lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.&lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;222&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  yield &lt;span class=&quot;number&quot;&gt;456&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.&lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;333&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var a = foo(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;//此时函数不会执行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a.next(); &lt;span class=&quot;comment&quot;&gt;//此时函数执行到第一句含有yield的语句时就暂停了，也就是只打印了 111&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a.next(); &lt;span class=&quot;comment&quot;&gt;//此时函数执行到第二句含有yield的语句时暂停，打印了 222&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a.next(); &lt;span class=&quot;comment&quot;&gt;//已经没有yield语句了，将会打印333，函数执行完毕&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a.next(); &lt;span class=&quot;comment&quot;&gt;//已经没有yiedl语句了，什么也不会打印&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义的时候多加一个星星号&lt;strong&gt;function*&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;generator函数中通常都会有yield，如果没有yield那就定义一个普通函数就好了&lt;/li&gt;
&lt;li&gt;函数不会立即执行，使用&lt;code&gt;.next()&lt;/code&gt;方法时，函数才会执行；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;yield&quot;&gt;&lt;a href=&quot;#yield&quot; class=&quot;headerlink&quot; title=&quot;yield&quot;&gt;&lt;/a&gt;yield&lt;/h3&gt;&lt;p&gt;yield到底是一个什么东东呢？操作符？对象？还是别的什么，这个我还没搞明白。&lt;/p&gt;
&lt;p&gt;看看阮一峰老师的这个例子，有助于理解参数的一些问题：&lt;br&gt;&lt;figure class=&quot;highlight crystal&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function* foo(x) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  var y = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; * (&lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; (x + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  var z = &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; (y / &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (x + y + z);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var a = foo(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a.&lt;span class=&quot;keyword&quot;&gt;next&lt;/span&gt;(); &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;Object&lt;/span&gt;&amp;#123;&lt;span class=&quot;symbol&quot;&gt;value:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;done:&lt;/span&gt;&lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a.&lt;span class=&quot;keyword&quot;&gt;next&lt;/span&gt;(); &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;Object&lt;/span&gt;&amp;#123;&lt;span class=&quot;symbol&quot;&gt;value:&lt;/span&gt;&lt;span class=&quot;constant&quot;&gt;NaN&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;done:&lt;/span&gt;&lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a.&lt;span class=&quot;keyword&quot;&gt;next&lt;/span&gt;(); &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;Object&lt;/span&gt;&amp;#123;&lt;span class=&quot;symbol&quot;&gt;value:&lt;/span&gt;&lt;span class=&quot;constant&quot;&gt;NaN&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;done:&lt;/span&gt;&lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var b = foo(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b.&lt;span class=&quot;keyword&quot;&gt;next&lt;/span&gt;(); &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt; &amp;#123; &lt;span class=&quot;symbol&quot;&gt;value:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;done:&lt;/span&gt;&lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt; &amp;#125; ，此时x=&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;，var y还没执行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b.&lt;span class=&quot;keyword&quot;&gt;next&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;); &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt; &amp;#123; &lt;span class=&quot;symbol&quot;&gt;value:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;done:&lt;/span&gt;&lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt; &amp;#125;，此时x=&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;，y=&lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;，var z还没执行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b.&lt;span class=&quot;keyword&quot;&gt;next&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;13&lt;/span&gt;); &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt; &amp;#123; &lt;span class=&quot;symbol&quot;&gt;value:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;done:&lt;/span&gt;&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt; &amp;#125;，此时x=&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;，y=&lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;，&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当上面的函数运行&lt;code&gt;b.next(12)&lt;/code&gt;这一句时，x=5，y=24，var z还没执行，返回对象为{ value:8, done:false }&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Q: 为什么y=24？&lt;br&gt;A: 因为第二个next方法的参数传给&lt;em&gt;上一个yield&lt;/em&gt;，也就是第一个yield，所以var y = 2 * 12&lt;/p&gt;
&lt;p&gt;Q: 为什么返回对象value为8？&lt;br&gt;A: 因为第二个yield后面跟的表达式是 y/3，y=24，所以返回的对象value为8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;yield是一个&lt;strong&gt;暂停的标记&lt;/strong&gt;，使用&lt;code&gt;.next()&lt;/code&gt;方法运行函数时，遇到yield就会暂停&lt;/li&gt;
&lt;li&gt;yield用在表达式中必须加括号扩起来，比如这样&lt;code&gt;var a = 1 + (yield 1+1)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;.next()&lt;/code&gt;方法时会返回一个对象，长这样：&lt;code&gt;{ value: xxx, done: false }&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;有两个key，一个是value，一个是done&lt;/li&gt;
&lt;li&gt;value的值是，该次暂停遇到的这个&lt;code&gt;yield&lt;/code&gt; 后面跟的表达式的值。比如上面的例子中第一次调用&lt;code&gt;b.next()&lt;/code&gt;时，遇到第一个yield而暂停，&lt;code&gt;var y = 2 * (yield (x + 1));&lt;/code&gt;，yield后面跟的表达式是(x+1)，所以返回的对象value是6&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;done&lt;/code&gt;为&lt;code&gt;true&lt;/code&gt;说明后面没有yield了，之后再调用&lt;code&gt;.next()&lt;/code&gt;方法返回的value都是&lt;code&gt;undefined&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果generator函数没有返回值，那么最后一个yield之后再调用的&lt;code&gt;.next()&lt;/code&gt;方法返回的就是&lt;code&gt;{ value:undefined, done: true }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果generator函数有返回值，那么最后一个yield之后再调用&lt;code&gt;.next()&lt;/code&gt;方法返回的对象value是函数的返回值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;.next()&lt;/code&gt;方法时，可以传入参数&lt;ul&gt;
&lt;li&gt;该参数是传给&lt;strong&gt;上一个yield&lt;/strong&gt;，所以第一次调用&lt;code&gt;.next()&lt;/code&gt;时不能传入参数。&lt;em&gt;可能会报错，也可能参数会被忽略，取决于浏览器是怎么实现的&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不传入参数时，yield语句返回的值为&lt;code&gt;undefined&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;瞎扯&quot;&gt;&lt;a href=&quot;#瞎扯&quot; class=&quot;headerlink&quot; title=&quot;瞎扯&quot;&gt;&lt;/a&gt;瞎扯&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;感觉yield像一个“函数”，执行的时候遇到这个函数就会暂停&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这个函数返回的值等于&lt;code&gt;.next(xxx)&lt;/code&gt;调用时传入的参数xxx，如果没有参数，返回值就是&lt;code&gt;undefined&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function* foo() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.log(&lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.log(&lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var a=foo();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a.&lt;span class=&quot;keyword&quot;&gt;next&lt;/span&gt;(); &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt; 遇到第一个&lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt;暂停，什么也不打印&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a.&lt;span class=&quot;keyword&quot;&gt;next&lt;/span&gt;(); &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt; 遇到第二个&lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt;暂停，打印上一句console.log(&lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt;)，由于没有传入参数，&lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt;返回undefined&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a.&lt;span class=&quot;keyword&quot;&gt;next&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;hello&#39;&lt;/span&gt;); &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt;后面没有&lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt;了，函数执行完毕，打印第二个console.log，由于传入参数，将会打印出hello&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;yield用在表达式中必须加括号扩起来，比如这样&lt;code&gt;var a = 1 + (yield 1+1)&lt;/code&gt;，有点类似于把一个函数写到表达式中要用括号括起来&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; + (&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;&amp;#125;());&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;好奇宝宝&quot;&gt;&lt;a href=&quot;#好奇宝宝&quot; class=&quot;headerlink&quot; title=&quot;好奇宝宝&quot;&gt;&lt;/a&gt;好奇宝宝&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;往&lt;code&gt;next()&lt;/code&gt;里传入参数的用法，在什么场景下适用？&lt;/li&gt;
&lt;li&gt;通常是不是都通过&lt;code&gt;.next().value&lt;/code&gt;来获取当前暂停的&lt;code&gt;yield&lt;/code&gt;后面的表达式？&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;于是也是入了ES6的坑，为什么只有babel这种ES6转ES5的工具，而没有ES5转ES6的工具呢？可能有，但是我不知道。如果有的话，就能把5转成6，起码看起来逼格高了一大截，也能让我这种还不习惯ES6的小白假装会写ES6…&lt;/p&gt;
&lt;p&gt;简单的看了一下相关的概念，觉得还不
    
    </summary>
    
    
      <category term="ES6" scheme="http://sabrinaluo.com/tech/tags/ES6/"/>
    
      <category term="generator" scheme="http://sabrinaluo.com/tech/tags/generator/"/>
    
      <category term="yield" scheme="http://sabrinaluo.com/tech/tags/yield/"/>
    
  </entry>
  
  <entry>
    <title>对JS类和继承的一些理解</title>
    <link href="http://sabrinaluo.com/tech/2015/12/31/understand-js-inheritance/"/>
    <id>http://sabrinaluo.com/tech/2015/12/31/understand-js-inheritance/</id>
    <published>2015-12-31T03:36:54.000Z</published>
    <updated>2016-02-17T07:55:27.154Z</updated>
    
    <content type="html">&lt;p&gt;本文只总结最常用的实现方法，不具体讨论各种实现方法的优缺点（这些具体可以看&lt;a href=&quot;http://book.douban.com/subject/10546125/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《JavaScript高级程序设计》&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;直到ES5，JS也还是一个没有类的语言，虽然ES6中可以使用class关键字，但据说也只是语法糖。(不知道好不好吃ԅ(¯﹃¯ԅ))&lt;/p&gt;
&lt;h3 id=&quot;类的实现&quot;&gt;&lt;a href=&quot;#类的实现&quot; class=&quot;headerlink&quot; title=&quot;类的实现&quot;&gt;&lt;/a&gt;类的实现&lt;/h3&gt;&lt;p&gt;类的两个基本元素就是&lt;strong&gt;属性&lt;/strong&gt;和&lt;strong&gt;方法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;JS中类的实现有很多种，构造函数模式、原型模式等等，各有各的优缺点，最常用的是混合了构造函数和原型模式的混合模式。&lt;br&gt;&lt;figure class=&quot;highlight fortran&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;/span&gt; Person(&lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  this.&lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Person.prototype.sayHi = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.&lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;Hi, &#39;&lt;/span&gt; + this.&lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;使用构造函数来构造&lt;strong&gt;属性&lt;/strong&gt;，然后往原型对象添加&lt;strong&gt;方法&lt;/strong&gt;。这样的好处是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个实例之间不用共享属性，拥有各自独立的属性。也就可以避免当属性为引用类型（数组、对象）时，修改一个实例的属性会影响到其他实例的情况。&lt;/li&gt;
&lt;li&gt;每个实例之间共用原型对象上的方法，实现了函数复用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;继承的实现&quot;&gt;&lt;a href=&quot;#继承的实现&quot; class=&quot;headerlink&quot; title=&quot;继承的实现&quot;&gt;&lt;/a&gt;继承的实现&lt;/h3&gt;&lt;p&gt;JS中继承的实现也有很多种，借用构造函数，原型链等等。&lt;br&gt;子类继承父类，当然继承的就是父类的&lt;strong&gt;属性和方法&lt;/strong&gt;。JS中继承的实现，最常用的也是混合模式。&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Student&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;name, age&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Person.call(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age = age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(Student.prototype.constructor); &lt;span class=&quot;comment&quot;&gt;// Student&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Student.prototype = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(Student.prototype.constructor); &lt;span class=&quot;comment&quot;&gt;// Person&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Student.prototype.constructor = Student; &lt;span class=&quot;comment&quot;&gt;// 重写constructor&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Student.prototype.sayAge = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;I&#39;m &quot;&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;strong&gt;借用构造函数&lt;/strong&gt;的方式来继承&lt;strong&gt;属性&lt;/strong&gt;，然后使用&lt;strong&gt;原型链&lt;/strong&gt;来继承&lt;strong&gt;方法&lt;/strong&gt;。通过将子类的原型对象指向父类的实例，子类的实例就可以通过原型链向上查找到父类原型上的方法。&lt;/p&gt;
&lt;h3 id=&quot;重写子类构造函数的意义&quot;&gt;&lt;a href=&quot;#重写子类构造函数的意义&quot; class=&quot;headerlink&quot; title=&quot;重写子类构造函数的意义&quot;&gt;&lt;/a&gt;重写子类构造函数的意义&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Student.prototype = new Person();&lt;/code&gt;这一步完全改变了Student原型对象的引用，&lt;code&gt;Student.prototype.constructor&lt;/code&gt; 变为了Person原型对象的constructor。&lt;br&gt;个人觉得重写&lt;code&gt;Student.prototype.constructor = Student;&lt;/code&gt;没有什么实际意义，可能只是&lt;strong&gt;约定俗成的一种潜规则&lt;/strong&gt;。&lt;br&gt;人们通常可能已经习惯了使用new操作符的时候，构造函数的一致性&lt;br&gt;&lt;figure class=&quot;highlight oxygene&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Student.prototype.constructor = Student; 在上面的代码中注释掉这一句&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; xiaobai = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Student(&lt;span class=&quot;string&quot;&gt;&#39;小白妹妹&#39;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;xiaobai.&lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// Person&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当你在代码中遇到上面这种情况，如果不去查看之前的代码的话，肯定会觉得奇怪，为什么明明通过Student构造函数new了一个Student实例，而这个实例，却说自己的构造函数是Person？！？！WTF？！&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;p&gt;[1] &lt;a href=&quot;http://stackoverflow.com/questions/4012998/what-it-the-significance-of-the-javascript-constructor-property&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://stackoverflow.com/questions/4012998/what-it-the-significance-of-the-javascript-constructor-property&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文只总结最常用的实现方法，不具体讨论各种实现方法的优缺点（这些具体可以看&lt;a href=&quot;http://book.douban.com/subject/10546125/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《JavaScript高级程序设计》
    
    </summary>
    
    
      <category term="JS" scheme="http://sabrinaluo.com/tech/tags/JS/"/>
    
      <category term="prototype" scheme="http://sabrinaluo.com/tech/tags/prototype/"/>
    
      <category term="原型" scheme="http://sabrinaluo.com/tech/tags/%E5%8E%9F%E5%9E%8B/"/>
    
      <category term="继承" scheme="http://sabrinaluo.com/tech/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>利用travis自动部署hexo搭建在github的博客</title>
    <link href="http://sabrinaluo.com/tech/2015/12/28/travis-github-hexo/"/>
    <id>http://sabrinaluo.com/tech/2015/12/28/travis-github-hexo/</id>
    <published>2015-12-28T04:00:56.000Z</published>
    <updated>2016-02-17T07:55:27.154Z</updated>
    
    <content type="html">&lt;p&gt;这篇应该属于不务正业系列…&lt;br&gt;自从知道了持续集成（Continuous Integration）这个概念之后感觉开启了新世界的大门。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://travis-ci.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Travis&lt;/a&gt;是一套持续集成的服务器解决方案，也就是等于把jenkins能够实现的都放在了云端，不用自己搭服务器安装了，懒人的福音～&lt;/p&gt;
&lt;p&gt;最初知道travis是因为总在github商看到这种小图标，虽然不知道是什么东东，但是觉得逼格特别高…&lt;br&gt;&lt;a href=&quot;https://travis-ci.org/sabrinaluo/tech&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://travis-ci.org/sabrinaluo/tech.svg?branch=master&quot; alt=&quot;Build Status&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于Hexo和github page这里就不讨论了，教程网上一搜一大堆。用travis属于进阶内容了，能搜到这篇文章的，应该也都具备了最基础的知识。&lt;/p&gt;
&lt;p&gt;为什么需要travis来自动部署博客呢，像我这种废话多的人，倾诉欲随时随地会喷发…然后如果当时手边没有电脑，或者有电脑了但不是我的电脑，欲火就被一盆水浇灭了…而有了travis之后呢，只要给我一台能上网的电脑，分分钟就能发博客并且更新到自己的网站…&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zespia.tw/blog/2015/01/21/continuous-deployment-to-github-with-travis/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;具体教程（来自Hexo的作者Tommy）&lt;/a&gt;网上已经有一些了，但不是很多，这里主要说一说其中容易遇到的坑。&lt;/p&gt;
&lt;h3 id=&quot;Prerequisite&quot;&gt;&lt;a href=&quot;#Prerequisite&quot; class=&quot;headerlink&quot; title=&quot;Prerequisite&quot;&gt;&lt;/a&gt;Prerequisite&lt;/h3&gt;&lt;p&gt;注册一个travis账号，绑定github，并为相应的repo开启travis服务&lt;br&gt;在repo中添加&lt;code&gt;.travis.yml&lt;/code&gt;文件，下面是我个人的配置。我是将source和public放在同一个repo的不同分支里，源文件放在master分支，生成后的网页放在gh-pages分支。&lt;br&gt;&lt;script src=&quot;//gist.github.com/d905eeed53d9368fdee6.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## 目录结构如下，其中.travis文件夹用于存放github的sshkey加密文件，以及ssh的相关配置
└── blog
    ├── _config.yml
    ├── package.json
    ├── README.md
    ├── scaffolds
    ├── source
    │   └── _posts
    ├── .travis
    │   ├── id_rsa.enc
    │   └── ssh_config
    └── .travis.yml
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;注意事项&quot;&gt;&lt;a href=&quot;#注意事项&quot; class=&quot;headerlink&quot; title=&quot;注意事项&quot;&gt;&lt;/a&gt;注意事项&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;before_install:
- openssl aes-256-cbc -K $encrypted_e011a6d7eebf_key -iv $encrypted_e011a6d7eebf_iv -in .travis/id_rsa.enc -out ~/.ssh/id_rsa -d
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;$encrypted_e011a6d7eebf_key&lt;/strong&gt;这一串加密的key每个人都不同，请不要直接复制。请使用&lt;br&gt;&lt;code&gt;$ travis encrypt-file ssh_key --add&lt;/code&gt; 这条命令将相应的key写入&lt;code&gt;.travis.yml&lt;/code&gt;中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;记得检查&lt;code&gt;.travis.yml&lt;/code&gt;文件&lt;/strong&gt;，因为在自动写入文件的过程中很可能出现了&lt;strong&gt;自动换行&lt;/strong&gt;的问题（我是linuxmint 用webstorm遇到了这个问题），如果有换行的问题把换行符删除即可，否则会导致travis在命令跑到这里的时候出问题使得building failed。&lt;/li&gt;
&lt;li&gt;另外如果有将相应的文件移到相应的文件夹中，请记得在命令中修改相应的path&lt;/li&gt;
&lt;li&gt;如果你最后deploy的不是master分支，请在&lt;code&gt;packag.json&lt;/code&gt;中使用下面的依赖&lt;pre&gt;&lt;code&gt;&amp;quot;hexo-deployer-git&amp;quot;: &amp;quot;hexojs/hexo-deployer-git#495fc6d&amp;quot;
&lt;/code&gt;&lt;/pre&gt;hexo-deployer-git在0.0.4及之前的版本都是hardcode了默认使用master分支来deploy，当使用非master分支来进行deploy时（本文例子中使用gh-pages分支中的内容）则会报错，上述版本修复了该问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;travis-yml文件解释&quot;&gt;&lt;a href=&quot;#travis-yml文件解释&quot; class=&quot;headerlink&quot; title=&quot;.travis.yml文件解释&quot;&gt;&lt;/a&gt;&lt;code&gt;.travis.yml&lt;/code&gt;文件解释&lt;/h3&gt;&lt;p&gt;整个配置其实是告诉travis：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用node 4.0版本来build我的程序&lt;/li&gt;
&lt;li&gt;只有当master分支有commit的时候才自动部署&lt;/li&gt;
&lt;li&gt;在安装之前先解密ssh key以便获得github的写权限（这样才能push到gh-pages分支）；全局安装hexo（这样才能直接执行hexo命令）；配置git设定（这样才能用git）&lt;/li&gt;
&lt;li&gt;克隆主题&lt;blockquote&gt;
&lt;p&gt;（如果想省略这一步，你可以把主题&lt;code&gt;themes&lt;/code&gt;文件夹也放在博客repo的master分支中）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;克隆gh-pages分支到&lt;code&gt;.deploy_git&lt;/code&gt;文件夹&lt;blockquote&gt;
&lt;p&gt;（hexo 默认会将生成的用于deploy的文件都放在这个文件夹；如果不需要gh-pages分支的相关commit记录，这一步可以省略。省略后该分支永远只有最近的一次commit…）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;跑一下&lt;code&gt;hexo g&lt;/code&gt;命令，看看是否会有错&lt;blockquote&gt;
&lt;p&gt;请注意，这一步并不能保证博客生成的样式问题，只是查看主题是否有错误。如果你每次都是克隆主题，并不能保证你克隆的版本每次都能顺利生成所有文件，可能会存在bug&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;如果能够顺利生成网页则执行&lt;code&gt;hexo d&lt;/code&gt;，将博客push到gh-pages分支 &lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这篇应该属于不务正业系列…&lt;br&gt;自从知道了持续集成（Continuous Integration）这个概念之后感觉开启了新世界的大门。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://travis-ci.org&quot; target=&quot;_blank&quot; rel=&quot;external
    
    </summary>
    
    
      <category term="github" scheme="http://sabrinaluo.com/tech/tags/github/"/>
    
      <category term="hexo" scheme="http://sabrinaluo.com/tech/tags/hexo/"/>
    
      <category term="travis" scheme="http://sabrinaluo.com/tech/tags/travis/"/>
    
      <category term="博客" scheme="http://sabrinaluo.com/tech/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="持续集成" scheme="http://sabrinaluo.com/tech/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
      <category term="自动部署" scheme="http://sabrinaluo.com/tech/tags/%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>git merge commits 如何合并多个提交为一个</title>
    <link href="http://sabrinaluo.com/tech/2015/12/24/how-to-merge-commits-with-git-rebase/"/>
    <id>http://sabrinaluo.com/tech/2015/12/24/how-to-merge-commits-with-git-rebase/</id>
    <published>2015-12-24T07:08:49.000Z</published>
    <updated>2016-02-17T07:55:27.154Z</updated>
    
    <content type="html">&lt;p&gt;因为我是那种经常改一个错别字就忙着要提交一次的人…所以总是会产生很多无意义的提交，于是合并多个提交为一个就成了我的刚性需求。&lt;/p&gt;
&lt;p&gt;关于合并多个提交，主要是要搞清楚&lt;code&gt;rebase&lt;/code&gt;的用法。&lt;/p&gt;
&lt;h3 id=&quot;查看提交历史，git-log&quot;&gt;&lt;a href=&quot;#查看提交历史，git-log&quot; class=&quot;headerlink&quot; title=&quot;查看提交历史，git log&quot;&gt;&lt;/a&gt;查看提交历史，git log&lt;/h3&gt;&lt;p&gt;首先你要知道自己想合并的是哪几个提交，可以使用&lt;code&gt;git log&lt;/code&gt;命令来查看提交历史，假如最近4条历史如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;commit ada2cd944fc81cf0051c6b6cac62fad9ae6830d3
commit 0e25f1237eeaf9ae02b5b48b888a844ed288e7e3
commit ddbd8fd1d52aec0bbedc65a1a0add159344d4ae2
commit 2aad0182a613b2e73b44ebbf0d5536126f714cb9
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;历史记录是按照时间排序的，时间近的排在前面。&lt;/p&gt;
&lt;h3 id=&quot;git-rebase&quot;&gt;&lt;a href=&quot;#git-rebase&quot; class=&quot;headerlink&quot; title=&quot;git rebase&quot;&gt;&lt;/a&gt;git rebase&lt;/h3&gt;&lt;p&gt;想要合并1-3条，有两个方法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从HEAD版本开始往过去数3个版本&lt;pre&gt;&lt;code&gt;git rebase -i HEAD~3
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;指名要合并的版本之前的版本号&lt;pre&gt;&lt;code&gt;git rebase -i 2aad018
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;请注意&lt;strong&gt;2aad018&lt;/strong&gt;这个版本是不参与合并的，可以把它当做一个坐标&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;选取要合并的提交&quot;&gt;&lt;a href=&quot;#选取要合并的提交&quot; class=&quot;headerlink&quot; title=&quot;选取要合并的提交&quot;&gt;&lt;/a&gt;选取要合并的提交&lt;/h3&gt;&lt;p&gt;执行了rebase命令之后，会弹出一个窗口，头几行如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pick ada2cd9
pick 0e25f12
pick ddbd8fd
...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将&lt;code&gt;pick&lt;/code&gt;改为&lt;code&gt;squash&lt;/code&gt;或者&lt;code&gt;s&lt;/code&gt;，之后保存并关闭文本编辑窗口即可。改完之后文本内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;s ada2cd9
s 0e25f12
s ddbd8fd
...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参考：&lt;br&gt;[1] &lt;a href=&quot;https://git-scm.com/docs/git-rebase&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://git-scm.com/docs/git-rebase&lt;/a&gt;&lt;br&gt;[2] &lt;a href=&quot;http://blog.csdn.net/yangcs2009/article/details/47166361&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/yangcs2009/article/details/47166361&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;因为我是那种经常改一个错别字就忙着要提交一次的人…所以总是会产生很多无意义的提交，于是合并多个提交为一个就成了我的刚性需求。&lt;/p&gt;
&lt;p&gt;关于合并多个提交，主要是要搞清楚&lt;code&gt;rebase&lt;/code&gt;的用法。&lt;/p&gt;
&lt;h3 id=&quot;查看提交历史，git-log&quot;
    
    </summary>
    
    
      <category term="git" scheme="http://sabrinaluo.com/tech/tags/git/"/>
    
      <category term="merge commits" scheme="http://sabrinaluo.com/tech/tags/merge-commits/"/>
    
      <category term="合并提交" scheme="http://sabrinaluo.com/tech/tags/%E5%90%88%E5%B9%B6%E6%8F%90%E4%BA%A4/"/>
    
  </entry>
  
  <entry>
    <title>git merge repo 如何合并两个仓库</title>
    <link href="http://sabrinaluo.com/tech/2015/12/24/how-to-merge-repos-with-git/"/>
    <id>http://sabrinaluo.com/tech/2015/12/24/how-to-merge-repos-with-git/</id>
    <published>2015-12-24T06:58:32.000Z</published>
    <updated>2016-02-17T07:55:27.154Z</updated>
    
    <content type="html">&lt;p&gt;为什么我每天都会有一些奇奇怪怪的需求…&lt;/p&gt;
&lt;p&gt;我之前在github上用hexo搭了一个静态博客，每次hexo deploy的时候，就会在gh-pages分支提交一个commit。但是由于hexo-deployer-git本身的逻辑是，每次都是强推&lt;code&gt;push -f&lt;/code&gt;，于是每当我换电脑（比如从家里换到公司里）的时候，我的commit记录就会丢失…但是像我这种虚荣心强的人，一个错别字都要commit一次来增加我在github commit的次数…所以，我家里的电脑和公司的电脑，两个repo的commit log都不能丢！！一个都不能少！！&lt;/p&gt;
&lt;h3 id=&quot;如何合并两个仓库&quot;&gt;&lt;a href=&quot;#如何合并两个仓库&quot; class=&quot;headerlink&quot; title=&quot;如何合并两个仓库&quot;&gt;&lt;/a&gt;如何合并两个仓库&lt;/h3&gt;&lt;p&gt;假设现在有两个repo：repo1，repo2，每个repo中都已经有一堆提交记录了，现在想把repo2中的记录合并到repo1中，命令如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; repo1
git remote add other ../repo2
git fetch other
git checkout -b repo2 other/master
git checkout master
git merge repo2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解释：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进入repo1文件夹&lt;/li&gt;
&lt;li&gt;添加repo2作为repo1的远程仓库，并命名为other&lt;/li&gt;
&lt;li&gt;将repo2的内容获取到repo1&lt;blockquote&gt;
&lt;p&gt;注意，使用fetch而不是pull，关于fetch和pull的区别&lt;a href=&quot;https://stackoverflow.com/questions/292357/what-are-the-differences-between-git-pull-and-git-fetch&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;请戳这里&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;在repo1中创建名为repo2的新分支，同时切换到该分支，并且使用上一步获取的内容中的master分支的内容&lt;/li&gt;
&lt;li&gt;切换到repo1的master分支&lt;/li&gt;
&lt;li&gt;将repo2分支的内容合并到master分支&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;一句话总结&quot;&gt;&lt;a href=&quot;#一句话总结&quot; class=&quot;headerlink&quot; title=&quot;一句话总结&quot;&gt;&lt;/a&gt;一句话总结&lt;/h3&gt;&lt;p&gt;将一个仓库的内容checkout到另一个仓库的一个分支，将该分支与master分支合并&lt;/p&gt;
&lt;p&gt;参考：&lt;br&gt;[1] &lt;a href=&quot;http://blog.csdn.net/gouboft/article/details/8450696&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/gouboft/article/details/8450696&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;为什么我每天都会有一些奇奇怪怪的需求…&lt;/p&gt;
&lt;p&gt;我之前在github上用hexo搭了一个静态博客，每次hexo deploy的时候，就会在gh-pages分支提交一个commit。但是由于hexo-deployer-git本身的逻辑是，每次都是强推&lt;code&gt;push
    
    </summary>
    
    
      <category term="git" scheme="http://sabrinaluo.com/tech/tags/git/"/>
    
      <category term="merge repo" scheme="http://sabrinaluo.com/tech/tags/merge-repo/"/>
    
      <category term="合并仓库" scheme="http://sabrinaluo.com/tech/tags/%E5%90%88%E5%B9%B6%E4%BB%93%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>对Promise中的resolve，reject，catch的理解</title>
    <link href="http://sabrinaluo.com/tech/2015/12/22/understand-resolve-reject-catch-of-promise/"/>
    <id>http://sabrinaluo.com/tech/2015/12/22/understand-resolve-reject-catch-of-promise/</id>
    <published>2015-12-22T03:36:07.000Z</published>
    <updated>2016-02-17T07:55:27.154Z</updated>
    
    <content type="html">&lt;p&gt;对promise这个概念之前已经有了一些浅显的理解，&lt;a href=&quot;http://sabrinaluo.com/tech/2015/12/01/promise/&quot;&gt;相关文章-&amp;gt;戳这里&lt;/a&gt;，最近又有了一些新的理解。&lt;/p&gt;
&lt;h3 id=&quot;then-的时候到底是在then什么…&quot;&gt;&lt;a href=&quot;#then-的时候到底是在then什么…&quot; class=&quot;headerlink&quot; title=&quot;.then()的时候到底是在then什么…&quot;&gt;&lt;/a&gt;.then()的时候到底是在then什么…&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;首先要理解…Promise是一个对象，有then()方法的对象&lt;/li&gt;
&lt;li&gt;then()的入参是一个函数，通常在promise链中，入参是&lt;strong&gt;一个返回promise的函数&lt;/strong&gt;，这句话好像有点拗口，就是说入参是一个函数，这个函数会return一个promise对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;如何破坏promise链&quot;&gt;&lt;a href=&quot;#如何破坏promise链&quot; class=&quot;headerlink&quot; title=&quot;如何破坏promise链&quot;&gt;&lt;/a&gt;如何破坏promise链&lt;/h3&gt;&lt;p&gt;如果有这样一个promise链：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p1().then(p2).then(p3)
  .then(function(data) {
    console.log(&amp;apos;data: &amp;apos; + data);
  })
  .catch(function(error) {
    console.log(&amp;apos;error: &amp;apos; + error);
  });

function p1() {
  return new Promise(function(resolve, reject) {
    console.log(&amp;apos;p1 resolved&amp;apos;);
    resolve(123);
  });
}

function p2() {
  return new Promise(function(resolve, reject) {
    console.log(&amp;apos;p2 rejected&amp;apos;);
    reject(456);
  });
}

function p3() {
  return new Promise(function(resolve, reject) {
    console.log(&amp;apos;p3 resolved&amp;apos;);
    resolve(789);
  });
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面这个例子，你看到的console.log会是这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p1 resolved
p2 rejected
error: 456
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;并没有看到&lt;code&gt;p3&lt;/code&gt;的log，而是看到了error message，也就是说：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在一个promise链中，只要任何一个promise被reject，promise链就被破坏了，reject之后的promise都不会再执行，而是直接调用&lt;code&gt;.catch&lt;/code&gt;方法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这也是为什么在standard practice中，一定要在最后加上&lt;code&gt;.catch&lt;/code&gt;的原因。通过&lt;code&gt;.catch&lt;/code&gt;能够清楚的判断出promise链在哪个环节出了问题。&lt;/p&gt;
&lt;h3 id=&quot;如何按顺序执行已经定义的promise&quot;&gt;&lt;a href=&quot;#如何按顺序执行已经定义的promise&quot; class=&quot;headerlink&quot; title=&quot;如何按顺序执行已经定义的promise&quot;&gt;&lt;/a&gt;如何按顺序执行已经定义的promise&lt;/h3&gt;&lt;p&gt;这个情况在什么时候会用到呢？比如你有一个队列，队列里有很多任务，这些任务并不互相依赖执行后返回的结果。每个任务完成的时间都是不确定的，并且计算资源只允许一次执行一个任务。简单的来说，就是&lt;strong&gt;做完A之后再去做B，并且AB是相互独立的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假如我现在有一堆promise对象，大概长这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//p2, p3与p1相似
//当doSomething()执行完毕的时候，调用resolve()
//使得当前promise状态转变为fulfilled即可
var p1 = new Promise(function(resolve, reject) {
  //do something here
  //when do something done
  resolve();
});

p1.then(function() {
    return p2
  })
  .then(function() {
    return p3
  })
  .catch()
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;请注意，前一部破坏Promise链中分定义的p1 p2 p3是&lt;strong&gt;函数&lt;/strong&gt;，而此部分定义的p1 p2 p3是&lt;strong&gt;对象！对象！对象！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;如前面提到，promise是一个有then方法的对象，因此p1可以直接调用then&lt;br&gt;Q:为什么开头调用不是&lt;code&gt;p1().then&lt;/code&gt;？&lt;br&gt;A: 因为p1是一个对象啊！！！对象啊！！！象啊！！！啊！！！&lt;/li&gt;
&lt;li&gt;然而promise链中then方法的入参是&lt;strong&gt;一个返回promise对象的函数&lt;/strong&gt;，p2并不是一个函数，因此不能then(p2)；&lt;/li&gt;
&lt;li&gt;但p2是一个promise对象，已经满足了then方法入参的一半需求，那么写一个函数并且返回p2，就满足了入参的全部需求&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;对promise这个概念之前已经有了一些浅显的理解，&lt;a href=&quot;http://sabrinaluo.com/tech/2015/12/01/promise/&quot;&gt;相关文章-&amp;gt;戳这里&lt;/a&gt;，最近又有了一些新的理解。&lt;/p&gt;
&lt;h3 id=&quot;then-的时候到底是在
    
    </summary>
    
    
      <category term="promise chain" scheme="http://sabrinaluo.com/tech/tags/promise-chain/"/>
    
      <category term="promise链" scheme="http://sabrinaluo.com/tech/tags/promise%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>JS变量提升(Hoisting)</title>
    <link href="http://sabrinaluo.com/tech/2015/12/21/hoisting/"/>
    <id>http://sabrinaluo.com/tech/2015/12/21/hoisting/</id>
    <published>2015-12-21T02:24:02.000Z</published>
    <updated>2016-02-17T07:55:27.154Z</updated>
    
    <content type="html">&lt;p&gt;写了无数JS也依旧没听过变量提升…&lt;/p&gt;
&lt;p&gt;变量提升(Hoisting)这个概念，我第一次见到是在万人膜拜的&lt;a href=&quot;https://github.com/airbnb/javascript&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Airbnb JS 代码风格&lt;/a&gt;中见到。看完这一节大概明白是在说什么，然后觉得非常奇怪，这个概念平时写代码什么情况下用的到呢？&lt;/p&gt;
&lt;p&gt;我写了这么久JS，从来也不会先用变量后定义的呀，而且别的语言好像根本没有这个概念，难怪我从来没有遇到相关问题，难怪我没听过这个概念。难怪写强类型语言的各大神都是JS一生黑…&lt;/p&gt;
&lt;p&gt;后来大概问了问各种前辈，纷纷表示，这个概念在面试的时候和检查别人Bug的时候才会用到… (︶︿︶)&lt;/p&gt;
&lt;p&gt;解释器是什么东东我还没搞明白…但是变量提升其实可以转换成另一个问题：&lt;br&gt;当你在定义一个变量的时候，解释器是怎么解析的？&lt;/p&gt;
&lt;p&gt;先看一个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function test(){
  console.log(a);
  var a = 123;
}
test(); //调用这个函数，你会看到console中输出的是undefined
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;function test(){
  var a = 123;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的代码，解释器是这么理解的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function test(){
  var a; 
  a = 123;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而最开始的例子中，解释器是这么理解的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function test(){
  var a;
  console.log(a);
  a = 123;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一句话总结：变量提升就是JS解释器在解析JS的时候会把所有变量的&lt;strong&gt;声明&lt;/strong&gt;提升到该变量作用域的最顶端。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请注意：&lt;strong&gt;只提升声明，不提升赋值&lt;/strong&gt;！&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;写了无数JS也依旧没听过变量提升…&lt;/p&gt;
&lt;p&gt;变量提升(Hoisting)这个概念，我第一次见到是在万人膜拜的&lt;a href=&quot;https://github.com/airbnb/javascript&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Ai
    
    </summary>
    
    
      <category term="hoisting" scheme="http://sabrinaluo.com/tech/tags/hoisting/"/>
    
      <category term="变量提升" scheme="http://sabrinaluo.com/tech/tags/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>对JS闭包(Closure)的一些理解</title>
    <link href="http://sabrinaluo.com/tech/2015/12/19/understand-js-closure/"/>
    <id>http://sabrinaluo.com/tech/2015/12/19/understand-js-closure/</id>
    <published>2015-12-19T11:22:27.000Z</published>
    <updated>2016-02-17T07:55:27.154Z</updated>
    
    <content type="html">&lt;p&gt;昨天无聊在github上看代码，看到如下片段，反正看不太懂这是在干啥，但这就是传说中的闭包了…&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function isType(type) {
  return function(obj) {
    return {}.toString.call(obj) === &amp;apos;[object &amp;apos; + type + &amp;apos;]&amp;apos;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;以上来自目测是个阿里女神的repo: &lt;a href=&quot;https://github.com/fool2fish/utilx/blob/master/lib/index.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;utilx&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;很久之前就听过&lt;strong&gt;闭包&lt;/strong&gt;这个概念，看了一些相关的资料，依旧无法明白到底是个什么东东。各种作用域scope，看得我头都大了。_(:з」∠)_&lt;/p&gt;
&lt;p&gt;我在这里呢，也不会讲继续什么变量作用域，什么从外部读取局部变量之类的！@#￥%…的东东，我试图用最简单粗暴连隔壁卖红薯的大妈都能理解的方法，来说说我对闭包的理解。&lt;/p&gt;
&lt;p&gt;###闭包长什么样子？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function bibao(a){
  return function(b){
    return a+b;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的例子就是一个闭包。&lt;br&gt;我的理解是，闭包有这么几个元素：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;最外层是一个有名字的函数，通常都需要传入参数或者在这一层定义一些变量。&lt;/li&gt;
&lt;li&gt;这个有名字的函数返回一个匿名函数，通常都需要传入参数或者定义一些变量。&lt;/li&gt;
&lt;li&gt;这个匿名函数返回的值通常跟上面两点中的入参或者变量有关。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;如何使用闭包？&quot;&gt;&lt;a href=&quot;#如何使用闭包？&quot; class=&quot;headerlink&quot; title=&quot;如何使用闭包？&quot;&gt;&lt;/a&gt;如何使用闭包？&lt;/h3&gt;&lt;p&gt;这个问题其实也就是说，当你调用闭包的时候你其实是在调用什么？&lt;br&gt;我觉得搞清楚这个问题对于简单粗暴的理解闭包非常有用。&lt;/p&gt;
&lt;p&gt;用上面的闭包作为例子，通常闭包是这么用的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//例1，分两次传入参数
var hello = bibao(&amp;apos;你好&amp;apos;)；
var text = hello(&amp;apos;小白妹妹&amp;apos;);
console.log(text); //你会看到 你好小白妹妹
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面这个例子，其实就是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//例2，一次传入两个参数
var text = bibao(&amp;apos;你好&amp;apos;)(&amp;apos;小白妹妹&amp;apos;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以基本上可以理解为，有这么一个函数&lt;code&gt;bibao(a)(b)&lt;/code&gt;，调用的时候需要传入两个参数&lt;code&gt;a&lt;/code&gt;和&lt;code&gt;b&lt;/code&gt;，你可以&lt;strong&gt;分开传&lt;/strong&gt;，也可以&lt;strong&gt;一起传&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;大多数情况下，都是像例1一样，分开两次传入参数的。当你分开传的时候，第一次传入参数&lt;code&gt;a&lt;/code&gt;，也就是&lt;code&gt;var hello = bibao(&amp;#39;你好&amp;#39;);&lt;/code&gt;其实等于：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var hello = function(b){
  return &amp;apos;你好&amp;apos;+b;  
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以当你给&lt;code&gt;hello()&lt;/code&gt;传入参数&lt;code&gt;b&lt;/code&gt;的时候，&lt;code&gt;var text = hello(&amp;#39;小白妹妹&amp;#39;)&lt;/code&gt;，返回的是“你好小白妹妹”。也就等于说，当你在调用&lt;code&gt;hello()&lt;/code&gt;这个函数的时候，其实访问到了bibao()这个函数中的变量&lt;code&gt;a&lt;/code&gt;，值为’你好’。&lt;/p&gt;
&lt;p&gt;闭包中&lt;code&gt;a&lt;/code&gt;是定义在匿名函数外部的，这就是传说中的：&lt;strong&gt;内部函数可以访问外部函数的变量&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;为什么要使用闭包？使用闭包有什么好处？&quot;&gt;&lt;a href=&quot;#为什么要使用闭包？使用闭包有什么好处？&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用闭包？使用闭包有什么好处？&quot;&gt;&lt;/a&gt;为什么要使用闭包？使用闭包有什么好处？&lt;/h3&gt;&lt;p&gt;我有一个强烈的感觉闭包是一个懒人发明的…（当然我是瞎说的_(:з」∠)_）&lt;br&gt;假如我的老板认识了一大堆妹子，要我写个程序跟她们每个人说早安、午安、晚安，并告诉他们昨天是几号，最后还要问候他的老婆，“吃饭了吗？亲爱的”&lt;br&gt;通常我会这么实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function yesterday(){
 return new Date().getDate() -1;
}
function goodmorning(name){
  return &amp;apos;早安&amp;apos;+name + &amp;apos;昨天是&amp;apos; + yesterday() + &amp;apos;号&amp;apos;;
}
function goodafternoon(name){
  return &amp;apos;午安&amp;apos;+name + &amp;apos;昨天是&amp;apos; + yesterday() + &amp;apos;号&amp;apos;;
}
function goodnight(name){
  return &amp;apos;晚安&amp;apos;+name + &amp;apos;昨天是&amp;apos; + yesterday() + &amp;apos;号&amp;apos;;
}
//eating()这个函数不一定非要定义，可以直接console.log()也能满足需求，
//但是想到老板将来又会去问候其他的人，吃饭了吗？xxx，
//所以定义了一个函数，以便将来可以偷懒
function eating(name){
  return &amp;apos;吃饭了吗？&amp;apos; + name;
}
var list = [&amp;apos;小白妹妹&amp;apos;,&amp;apos;小红妹妹&amp;apos;,&amp;apos;小黑妹妹&amp;apos;,&amp;apos;小灰妹妹&amp;apos;];
list.forEach(function(item){
  console.log(goodmorning(item));
  console.log(goodafternoon(item));
  console.log(goodnight(item));
});
console.log(eating(&amp;apos;亲爱的&amp;apos;))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用闭包这么实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function yesterday(){
 return new Date().getDate()-1;
}
function bibao(greeting){
  return function(name){
    return greeting + name +&amp;apos;昨天是&amp;apos; + yesterday() + &amp;apos;号&amp;apos;;
  }
}
var goodmorning = bibao(&amp;apos;早安&amp;apos;);
var goodafternoon = bibao(&amp;apos;午安&amp;apos;);
var goodnight = bibao(&amp;apos;晚安&amp;apos;);
var list = [&amp;apos;小白妹妹&amp;apos;,&amp;apos;小红妹妹&amp;apos;,&amp;apos;小黑妹妹&amp;apos;,&amp;apos;小灰妹妹&amp;apos;];
list.forEach(function(item){
  console.log(goodmorning(item));
  console.log(goodafternoon(item));
  console.log(goodnight(item));
});
var eating = bibao(&amp;apos;吃饭了吗？&amp;apos;);
console.log(eating(&amp;apos;亲爱的&amp;apos;));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到，使用了闭包就不用重复定义&lt;strong&gt;行为类似&lt;/strong&gt;的函数，&lt;code&gt;+ name +&amp;#39;昨天是&amp;#39; + yesterday() + &amp;#39;号&amp;#39;;&lt;/code&gt;这个也只用写一遍就可以了，免去了很多重复劳动，看起来简洁了很多，最重要是…显得逼格高…&lt;/p&gt;
&lt;h3 id=&quot;什么时候用闭包？&quot;&gt;&lt;a href=&quot;#什么时候用闭包？&quot; class=&quot;headerlink&quot; title=&quot;什么时候用闭包？&quot;&gt;&lt;/a&gt;什么时候用闭包？&lt;/h3&gt;&lt;p&gt;我自己的感觉是，当你需要定义很多行为类似的函数的，重复写很多基本类似的内容的时候，就可以考虑用闭包来让整个代码的结构更加简洁。（总觉得使用闭包，可读性就不那么强了，毕竟我这种小白还是不太一眼就看得出来一个闭包到底输入啥返回啥的…）&lt;/p&gt;
&lt;p&gt;另外就也不太清楚具体的使用场景了，反正我平时很少用到…少用到的可能有这么几个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对闭包的理解不够深入，其实还是不太知道这个东东到底干啥用的&lt;/li&gt;
&lt;li&gt;通常用别的简单粗暴的方法来代替闭包实现的功能，简单的来说比如一个人不知道switch，但是知道if else，于是用if else来实现跟switch一样的功能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我不知道有没有什么情况是除了闭包就没办法解决的…如果没有…那么用其他方法代替实现就可以了，实在搞不明白也没什么关系…&lt;/p&gt;
&lt;p&gt;###使用闭包的坏处？&lt;br&gt;据说是可能出现内存泄露的问题&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript#内存泄露&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;^1&lt;/a&gt;，这个就更高深了…以后有了深入的理解再来补充吧&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;昨天无聊在github上看代码，看到如下片段，反正看不太懂这是在干啥，但这就是传说中的闭包了…&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function isType(type) {
  return function(obj) {
    return {}.toString.ca
    
    </summary>
    
    
      <category term="JS" scheme="http://sabrinaluo.com/tech/tags/JS/"/>
    
      <category term="closure" scheme="http://sabrinaluo.com/tech/tags/closure/"/>
    
      <category term="闭包" scheme="http://sabrinaluo.com/tech/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>对module.exports和exports的一些理解</title>
    <link href="http://sabrinaluo.com/tech/2015/12/16/difference-between-Module-exports-with-exports-in-NodeJS/"/>
    <id>http://sabrinaluo.com/tech/2015/12/16/difference-between-Module-exports-with-exports-in-NodeJS/</id>
    <published>2015-12-16T03:00:27.000Z</published>
    <updated>2016-02-17T07:55:27.154Z</updated>
    
    <content type="html">&lt;p&gt;可能是有史以来最简单通俗易懂的有关Module.exports和exports区别的文章了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;module.exports&lt;/code&gt;和&lt;code&gt;exports&lt;/code&gt;的区别就是&lt;code&gt;var a={}; var b=a;&lt;/code&gt;，a和b的区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;看起来木有什么太大区别，但实际用起来的时候却又有区别，这是为啥呢，请听我细细道来&lt;/p&gt;
&lt;p&gt;关于Module.exports和exports有什么区别，网上一搜一大把，但是说的都太复杂了…&lt;br&gt;听说exports是Module.exports对象的一个引用(reference)&lt;a href=&quot;https://nodejs.org/dist/latest-v4.x/docs/api/modules.html#modules_exports_alias&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;^1&lt;/a&gt;，什么是引用？！…_(:з」∠)_&lt;/p&gt;
&lt;p&gt;当然啦，如果要彻底理解这两个导出的区别，最好肯定是去看源码，看看都是怎么封装的，功力深厚的童鞋应该一看就懂了。不过，源码我也是看不懂的…(ಥ_ಥ)&lt;/p&gt;
&lt;p&gt;但是最近感觉杂七杂八看了好多文章做了好多实验之后，像是打开了任督二脉，机智的我好像有点上道了…&lt;/p&gt;
&lt;h1 id=&quot;module&quot;&gt;&lt;a href=&quot;#module&quot; class=&quot;headerlink&quot; title=&quot;module&quot;&gt;&lt;/a&gt;module&lt;/h1&gt;&lt;p&gt;首先要明确的一点，module是一个&lt;strong&gt;对象&lt;/strong&gt; &lt;code&gt;{Object}&lt;/code&gt;。&lt;br&gt;当你新建一个文件，比如mo.js，文件内容如下：&lt;br&gt;&lt;figure class=&quot;highlight coffeescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然后在CMD里执行这个文件&lt;code&gt;node mo.js&lt;/code&gt;，就能看到module其实是一个Module实例，你可以这么理解，NodeJS中定义了一个Module类，这个类中有很多属性和方法，exports是其中的一个属性：&lt;br&gt;&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;tag&quot;&gt;Module&lt;/span&gt; &lt;span class=&quot;rules&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;rule&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;id &lt;/span&gt;:&lt;span class=&quot;value&quot;&gt; &lt;span class=&quot;string&quot;&gt;&#39;blabla&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  exports : &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;blabla&lt;/span&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当每个js文件在执行或被require的时候，NodeJS其实创建了一个新的实例&lt;code&gt;var module = new Module()&lt;/code&gt;，这个实例名叫&lt;code&gt;module&lt;/code&gt;。&lt;br&gt;&lt;strong&gt;这也就是为什么你并没有定义&lt;code&gt;module&lt;/code&gt;这个变量，却能console.log出来而不会报错的原因&lt;/strong&gt;。&lt;/p&gt;
&lt;h1 id=&quot;module-exports&quot;&gt;&lt;a href=&quot;#module-exports&quot; class=&quot;headerlink&quot; title=&quot;module.exports&quot;&gt;&lt;/a&gt;module.exports&lt;/h1&gt;&lt;p&gt;假设我有一个JS文件内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;//你会看到Module中的exports为空对象{}&lt;/span&gt;
&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;.exports = {
  print : &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;{&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;number&quot;&gt;12345&lt;/span&gt;)}
}
&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;//你会看到Module中的exports对象已经有了print()方法&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有了上面的基础，很容易理解&lt;code&gt;module.export&lt;/code&gt;其实是&lt;strong&gt;给Module实例中的exports对象中添加方法/属性&lt;/strong&gt;。&lt;/p&gt;
&lt;h1 id=&quot;exports&quot;&gt;&lt;a href=&quot;#exports&quot; class=&quot;headerlink&quot; title=&quot;exports&quot;&gt;&lt;/a&gt;exports&lt;/h1&gt;&lt;p&gt;通常使用exports的时候，是这么用的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;exports.print = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;{&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;number&quot;&gt;12345&lt;/span&gt;)}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;假设我有一个JS文件内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;//你会看到Module中的exports为空对象{}&lt;/span&gt;
&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(exports); &lt;span class=&quot;comment&quot;&gt;//你会看到Module中的exports为空对象{}&lt;/span&gt;
&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;.exports = {
  print : &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;{&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;number&quot;&gt;12345&lt;/span&gt;)}
}
&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;//你会看到Module中的exports对象有了print()方法&lt;/span&gt;
exports.name = &lt;span class=&quot;string&quot;&gt;&#39;小白妹妹&#39;&lt;/span&gt;;
&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;//你会看到Module中的exports对象不仅有了print()方法，还有了name属性&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由此也能看出，传说中的&lt;strong&gt;&lt;code&gt;exports&lt;/code&gt;其实是&lt;code&gt;module.exports&lt;/code&gt;的引用&lt;/strong&gt;，你可以这么理解，NodeJS在你的代码&lt;strong&gt;之前&lt;/strong&gt;悄悄的加了以下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var module = new Module();
var exports = module.exports;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;这也就是为什么你并没有定义&lt;code&gt;exports&lt;/code&gt;这个变量，却能console.log出来而不会报错的原因&lt;/strong&gt;。&lt;/p&gt;
&lt;h1 id=&quot;require&quot;&gt;&lt;a href=&quot;#require&quot; class=&quot;headerlink&quot; title=&quot;require&quot;&gt;&lt;/a&gt;require&lt;/h1&gt;&lt;p&gt;当你从外部调用某个模块，require其实是在require什么？&lt;a href=&quot;https://nodejs.org/dist/latest-v4.x/docs/api/modules.html#modules_module_require_id&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;^2&lt;/a&gt;&lt;br&gt;require的时候NodeJS会&lt;del&gt;到处&lt;/del&gt;去找有没有这个模块，如果有，return的就是module.exports里的东东。&lt;/p&gt;
&lt;h1 id=&quot;DOs-amp-DONTs&quot;&gt;&lt;a href=&quot;#DOs-amp-DONTs&quot; class=&quot;headerlink&quot; title=&quot;DOs &amp;amp; DONTs&quot;&gt;&lt;/a&gt;DOs &amp;amp; DONTs&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;√你可以这样：&lt;pre&gt;&lt;code&gt;module.exports.name = &amp;apos;小白妹妹&amp;apos;;
exports.age = 10;
module.exports.print = function(){console.log(12345)};
&lt;/code&gt;&lt;/pre&gt;如果只是使用&lt;code&gt;.&lt;/code&gt;来添加属性和方法，&lt;code&gt;module.exports&lt;/code&gt;和&lt;code&gt;exports&lt;/code&gt;混用是完全可以的，这种情况下，感觉&lt;code&gt;exports&lt;/code&gt;就是给懒人用的…毕竟能少写几个7个字符呢！&lt;/li&gt;
&lt;li&gt;√也可以这样：&lt;pre&gt;&lt;code&gt;module.exports = {
name = &amp;apos;小白妹妹&amp;apos;;
};
exports.age = 10;
module.exports.print = function(){console.log(12345)};
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;×但不可以这样&lt;/strong&gt;：&lt;pre&gt;&lt;code&gt;module.exports = {
name = &amp;apos;小白妹妹&amp;apos;;
};
exports = {age:10}; // exports现在是{age:10}这个对象的引用，不再是module.exports的引用了
console.log(module); //你会看到Module的exports中只有name属性！！！
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;×也不可以这样&lt;/strong&gt;：&lt;pre&gt;&lt;code&gt;exports.age = 10; 
console.log(module); //你会看到Module的exports中多了age属性
module.exports = {
name = &amp;apos;小白妹妹&amp;apos;;
};
console.log(module); //你会看到Module的exports中还是只有name属性！！！
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h1&gt;还是那一句话，&lt;code&gt;module.exports&lt;/code&gt;和&lt;code&gt;exports&lt;/code&gt;的区别就是&lt;code&gt;var a={}; var b=a;&lt;/code&gt;，a和b的区别&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;改变&lt;code&gt;exports&lt;/code&gt;的指向后所添加的&lt;code&gt;exports.xxx&lt;/code&gt;都是无效的。因为require返回的只会是&lt;code&gt;module.exports&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;不能在使用了&lt;code&gt;exports.xxx&lt;/code&gt;之后，改变&lt;code&gt;module.exports&lt;/code&gt;的指向。因为&lt;code&gt;exports.xxx&lt;/code&gt;添加的属性和方法并不存在于&lt;code&gt;module.exports&lt;/code&gt;所指向的新对象中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;感觉自己说的还是挺清楚哒～&lt;br&gt;不管你清不清楚，我反正是清楚了。_(:з」∠)_&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;可能是有史以来最简单通俗易懂的有关Module.exports和exports区别的文章了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;module.exports&lt;/code&gt;和&lt;code&gt;exports&lt;/code&gt;的区别就是&lt;code&gt;var a={}; var b=
    
    </summary>
    
    
      <category term="Module.exports" scheme="http://sabrinaluo.com/tech/tags/Module-exports/"/>
    
      <category term="NodeJS" scheme="http://sabrinaluo.com/tech/tags/NodeJS/"/>
    
      <category term="exports" scheme="http://sabrinaluo.com/tech/tags/exports/"/>
    
      <category term="模块导出" scheme="http://sabrinaluo.com/tech/tags/%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>AWS API Gateway与AWS Lambda的整合及开发/测试/生产环境的设置</title>
    <link href="http://sabrinaluo.com/tech/2015/12/15/Setup-DEV-QA-PROD-Environments-forAWS-Api-Gateway-AWS-Lambda/"/>
    <id>http://sabrinaluo.com/tech/2015/12/15/Setup-DEV-QA-PROD-Environments-forAWS-Api-Gateway-AWS-Lambda/</id>
    <published>2015-12-15T02:55:13.000Z</published>
    <updated>2016-02-17T07:55:27.154Z</updated>
    
    <content type="html">&lt;p&gt;本文&lt;strong&gt;不是&lt;/strong&gt;介绍 &lt;a href=&quot;https://aws.amazon.com/api-gateway/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AWS API Gateway&lt;/a&gt; 和 &lt;a href=&quot;https://aws.amazon.com/lambda/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AWS Lambda&lt;/a&gt;的基本用法的…=(:з」∠)_&lt;/p&gt;
&lt;p&gt;简单的来说，有了AWS的API Gateway和Lambda这两样东东，再加一个数据库（&lt;em&gt;最好当然是用AWS DynamoDB啦，或者AWS EC2上装mysql，不用AWS也可以，但是访问速度可能会有一定影响，毕竟如果都用AWS的话算是走内网会快一些？！&lt;/em&gt;），不需要任何网络应用的框架你就能开发出非常RESTful的API了，简直是中小型公司提高开发效率的神器！&lt;/p&gt;
&lt;p&gt;再简单的来说，API Gateway给你提供一个URL，当这个url被访问的时候，就会调用你设置的某个Lambda函数，这个函数执行完了之后就会返回你设定的数据。也就是说，以前你在服务器端收到一个请求，然后&lt;strong&gt;“做一堆事”&lt;/strong&gt;完了之后发出响应Response的这个“做一堆事”和Response，写在一个Lambda函数里就可以了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通常如果浏览器端使用ajax访问这个URL都会存在跨域的问题，API Gateway当然很贴心的提供了enable CORS选项！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;AWS Lambda目前支持python，JAVA，NodeJS。这个Lambda函数呢，只是叫Lambda而已，实际写起来跟函数式编程也没有太大的关系，以前怎么写现在也还是一样的写…神奇的是，Lambda之间可以相互调用，另外除了API Gateway之外，很多别的跟API Gateway无关的事件event也可以作为trigger（&lt;em&gt;比如当DynamoDB的某个Table新增一条用户记录的时候，调用一个名称为&lt;code&gt;sendWelcomeEmailToUser()&lt;/code&gt;的Lambda函数，给用户发欢迎邮件&lt;/em&gt;）&lt;/p&gt;
&lt;p&gt;那么，问题来了…&lt;del&gt;挖掘机技术哪家强&lt;/del&gt;&lt;br&gt;如何设置AWS API Gateway和AWS Lambda来实现开发/测试/生产环境的需求呢？难道要同一个功能的API建3个、同一个功能的lambda建3个？！&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;以下所有内容都是在AWS的WEB UI中进行设置的。&lt;em&gt;（除了在UI中设置，还可以写Shell脚本去批量执行这些设置，当然啦，这个我还没学会…）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;哦，忘了说…首先你要有个…API，然后你还要有个Lambda。&lt;br&gt;假设：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;API endpoint是 /stageTest，方法是&lt;code&gt;GET&lt;/code&gt;。&lt;/strong&gt; &lt;em&gt;（成就GET√  =(:з」∠)_）&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Lambda名为stageTest。&lt;/strong&gt; &lt;em&gt;（endpoint的名字和lambda名字可以不同…原谅我是取名无能星人…）&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;DEV-QA-PROD-环境的设置&quot;&gt;&lt;a href=&quot;#DEV-QA-PROD-环境的设置&quot; class=&quot;headerlink&quot; title=&quot;DEV / QA / PROD 环境的设置&quot;&gt;&lt;/a&gt;DEV / QA / PROD 环境的设置&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;为API Gateway创建不同的stage&lt;a href=&quot;http://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-set-stage-variables-aws-console.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;^1&lt;/a&gt;，假设创建了3个分别是dev，qa，prod。&lt;/strong&gt; &lt;em&gt;（教程是官方英文的，点引用的链接就可以看到，憋让我翻译，我懒…我知道还有pre-prod，多加一个下面的解释就得多写好多字(ಥ_ಥ)）&lt;/em&gt;&lt;blockquote&gt;
&lt;p&gt;设置了stage之后你的api endpoin看起来大概长这样：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;aws-apiid&gt;.execute-api.&lt;aws-region&gt;.amazonaws.com/dev&lt;/aws-region&gt;&lt;/aws-apiid&gt;&lt;/li&gt;
&lt;li&gt;&lt;aws-apiid&gt;.execute-api.&lt;aws-region&gt;.amazonaws.com/qa&lt;/aws-region&gt;&lt;/aws-apiid&gt;&lt;/li&gt;
&lt;li&gt;&lt;aws-apiid&gt;.execute-api.&lt;aws-region&gt;.amazonaws.com/prod&lt;/aws-region&gt;&lt;/aws-apiid&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;为每个的Stage设置stageVariables&lt;a href=&quot;http://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-set-stage-variables-aws-console.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;^2&lt;/a&gt;，假设为每个Stage都设置了一个名为env的变量&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;dev这个stage中env变量的值为DEV&lt;/li&gt;
&lt;li&gt;qa这个stage中env变量的值为QA&lt;/li&gt;
&lt;li&gt;prod这个stage中env变量的值为PROD&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Lambda stageTest()函数创建不同的alias&lt;a href=&quot;http://docs.aws.amazon.com/lambda/latest/dg/aliases-intro.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;^3&lt;/a&gt;，假设创建了3个分别是DEV，QA，PROD，分别指向不同的版本。&lt;/strong&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;在每次deploy后，都是$LATEST版本，点action&amp;gt;publish new version发布不同的版本&lt;/li&gt;
&lt;li&gt;建议DEV指向$LATEST版本，QA和PROD指向其他稳定的版本&lt;/li&gt;
&lt;li&gt;为Lambda创建了alias之后，其实这个lambda访问的名称就有了以下四种：&lt;code&gt;stageTest&lt;/code&gt;，&lt;code&gt;stageTest:DEV&lt;/code&gt;，&lt;code&gt;stageTest:QA&lt;/code&gt;，&lt;code&gt;stageTest:PROD&lt;/code&gt;，其中&lt;code&gt;stageTest&lt;/code&gt;永远指向$LATEST版本，其他指向之前设置的各个版本&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;整合API /stageTest 的GET方法与Lambda stageTest()&lt;a href=&quot;http://docs.aws.amazon.com/apigateway/latest/developerguide/getting-started.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;^5&lt;/a&gt;&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;首先在API Gateway的界面中设置每个API方法的&lt;strong&gt;Integration Request&lt;/strong&gt;：Integration Type选择Lambda Function；Lambda Function填&lt;code&gt;stageTest:${stageVariables.env}&lt;/code&gt;，&lt;strong&gt;${stageVariables.env}&lt;/strong&gt;就是第2步中，设置的变量。&lt;/li&gt;
&lt;li&gt;设置Lambda Function名称的时候一定要记得点旁边的√保存，保存的时候，AWS会弹出一个对话框，需要给函数加上权限才能使用stageVariables变量。加的时候记得要执行三次命令，也就是在AWS给出的命令的对应的位置改成 &lt;code&gt;stageTest:DEV&lt;/code&gt;，&lt;code&gt;stageTest:QA&lt;/code&gt;，&lt;code&gt;stageTest:PROD&lt;/code&gt; 每个执行一次。&lt;/li&gt;
&lt;li&gt;执行以上命令之前，你必须：&lt;ul&gt;
&lt;li&gt;安装AWS CLI&lt;/li&gt;
&lt;li&gt;执行命令&lt;code&gt;aws configure&lt;/code&gt;，填写你的AWS ID和key，设施default region为你的lambda function所在的region&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么，问题又来了…&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果你已经部署了很多lambda和api却没有使用stage的话…似乎是不太可能手动去AWS界面上一个一个设置的&lt;/li&gt;
&lt;li&gt;就算你已经在使用stage了，似乎也不太可能每次都手动去AWS界面上一个一个deploy最新的版本以及改变alias指向的版本的…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个时候，你就必须研究&lt;a href=&quot;https://aws.amazon.com/cli/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AWS CLI&lt;/a&gt;，然后写shell以及借助其他工具来进行自动化部署了…&lt;/p&gt;
&lt;p&gt;其他参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.aws.amazon.com/apigateway/latest/developerguide/stage-variables.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://docs.aws.amazon.com/apigateway/latest/developerguide/stage-variables.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html#stagevariables-template-reference&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html#stagevariables-template-reference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文&lt;strong&gt;不是&lt;/strong&gt;介绍 &lt;a href=&quot;https://aws.amazon.com/api-gateway/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AWS API Gateway&lt;/a&gt; 和 &lt;a href=&quot;https
    
    </summary>
    
    
      <category term="API Gateway" scheme="http://sabrinaluo.com/tech/tags/API-Gateway/"/>
    
      <category term="AWS" scheme="http://sabrinaluo.com/tech/tags/AWS/"/>
    
      <category term="AWS Lambda" scheme="http://sabrinaluo.com/tech/tags/AWS-Lambda/"/>
    
      <category term="RESTful" scheme="http://sabrinaluo.com/tech/tags/RESTful/"/>
    
      <category term="开发环境" scheme="http://sabrinaluo.com/tech/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    
      <category term="测试环境" scheme="http://sabrinaluo.com/tech/tags/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83/"/>
    
      <category term="环境配置" scheme="http://sabrinaluo.com/tech/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
      <category term="生产环境" scheme="http://sabrinaluo.com/tech/tags/%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83/"/>
    
  </entry>
  
  <entry>
    <title>AWS DynamoDB的本地安装及环境配置</title>
    <link href="http://sabrinaluo.com/tech/2015/12/14/how-to-setup-dynamodb-at-local/"/>
    <id>http://sabrinaluo.com/tech/2015/12/14/how-to-setup-dynamodb-at-local/</id>
    <published>2015-12-14T06:39:35.000Z</published>
    <updated>2016-02-17T07:55:27.154Z</updated>
    
    <content type="html">&lt;p&gt;&lt;a href=&quot;http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Introduction.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DynamoDB&lt;/a&gt;是亚马逊AWS云服务提供的一个NoSQL的数据库…&lt;/p&gt;
&lt;p&gt;在这里我必须安利一下Amazon家的服务真是业界良心：前不久，可能是因为我自己蠢，英文不好没看懂免费用一年的各种限制，也不知道写了什么奇怪的东东用自己的账号测试dynamoDB被扣了几刀，写邮件去投诉说你们不是免费吗为啥扣费，然后就得到回复解释了一下为啥扣钱，说我用超过限制了，然后表示个人账号里扣了的钱会&lt;strong&gt;退退退&lt;/strong&gt;！（我说明了之后会用公司账号测试，请帮我关了我的个人账户）&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;本文是Linux环境下的安装和配置，windows下我还不会…&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装JAVA SDK&lt;/p&gt;
&lt;figure class=&quot;highlight smali&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo&lt;span class=&quot;instruction&quot;&gt; add-apt-repository &lt;/span&gt;ppa:webupd8team/java&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo apt-get update&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo apt-get install oracle-java8-installer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo apt-get install oracle-java8-set-default&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装dynamodb-local&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下载daynamodb-local：&lt;a href=&quot;http://dynamodb-local.s3-website-us-west-2.amazonaws.com/dynamodb_local_latest.tar.gz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;点这里下载&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;解压文件&lt;/li&gt;
&lt;li&gt;进入文件目录执行以下命令：&lt;pre&gt;&lt;code&gt;java -Djava.library.path=./DynamoDBLocal_lib -jar DynamoDBLocal.jar -sharedDb
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;安装awscli，执行以下命令：&lt;pre&gt;&lt;code&gt;pip install awscli
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;配置环境变量，执行以下命令：&lt;pre&gt;&lt;code&gt;aws configure
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;这时会让你输入AWS_ACCESS_KEY_ID和AWS_SECRET_ACCESS_KEY，这两个值需要&lt;strong&gt;成功注册AWS服务&lt;/strong&gt;之后在AWS的网站上会看到&lt;/li&gt;
&lt;li&gt;AWS_DEFAULT_REGION，根据需要设置，也就是你的数据库打算放在AWS的那个区就设为哪个区，如果只是测试一下，懒得去看有什么区域，那么好吧，你可以设为&lt;code&gt;us-east-1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;启动dynamodb，进入dynamodb目录（也就是你解压dynamodb的地方），执行以下命令：&lt;pre&gt;&lt;code&gt;java -Djava.library.path=./DynamoDBLocal_lib -jar DynamoDBLocal.jar -sharedDb
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考：&lt;br&gt;[1] &lt;a href=&quot;http://tecadmin.net/install-oracle-java-8-jdk-8-ubuntu-via-ppa/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://tecadmin.net/install-oracle-java-8-jdk-8-ubuntu-via-ppa/&lt;/a&gt;&lt;br&gt;[2] &lt;a href=&quot;http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Tools.DynamoDBLocal.html#Tools.DynamoDBLocal.DownloadingAndRunning&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DynamoDBLocal Downloading And Running&lt;/a&gt;&lt;br&gt;[3] &lt;a href=&quot;http://aws.amazon.com/cli/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://aws.amazon.com/cli/&lt;/a&gt;&lt;br&gt;[4] &lt;a href=&quot;http://boto3.readthedocs.org/en/latest/guide/configuration.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://boto3.readthedocs.org/en/latest/guide/configuration.html&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Introduction.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DynamoDB&lt;/a&gt;是亚
    
    </summary>
    
    
      <category term="AWS" scheme="http://sabrinaluo.com/tech/tags/AWS/"/>
    
      <category term="DynamoDB" scheme="http://sabrinaluo.com/tech/tags/DynamoDB/"/>
    
      <category term="云服务" scheme="http://sabrinaluo.com/tech/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="亚马逊" scheme="http://sabrinaluo.com/tech/tags/%E4%BA%9A%E9%A9%AC%E9%80%8A/"/>
    
      <category term="本地安装" scheme="http://sabrinaluo.com/tech/tags/%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85/"/>
    
      <category term="环境配置" scheme="http://sabrinaluo.com/tech/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>JS注释中的感叹号是干什么用的/*! */</title>
    <link href="http://sabrinaluo.com/tech/2015/12/14/JS-important-comment/"/>
    <id>http://sabrinaluo.com/tech/2015/12/14/JS-important-comment/</id>
    <published>2015-12-14T06:15:06.000Z</published>
    <updated>2016-02-17T07:55:27.154Z</updated>
    
    <content type="html">&lt;p&gt;前几天看了一个帖子&lt;a href=&quot;http://www.jianshu.com/p/fdae559d1ed5&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;我招不到想要的程序员&lt;/a&gt;，里面有一点是说&lt;strong&gt;非极端情况下，一本以下的不要&lt;/strong&gt;。本来学历这种事情大家都无所谓，毕竟我所认识的大多数都是985、211的本硕博。只有当进入了另一个不同的世界，才觉得学历还挺重要的…&lt;br&gt;我的JS基本都是靠自学，我的大神同学们都是搞后端强类型语言的，所以我只能上网搜搜，买点书看看，加几个参差不齐的QQ群问一问。然而我这种月亮处女座的强迫症细节好奇宝宝常常会有奇奇怪怪找不到答案的问题……&lt;br&gt;有一天我看代码的时候发现很多规范的JS都会有这样的注释：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * EJS&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * Copyright(c) 2012 TJ Holowaychuk &amp;lt;tj@vision-media.ca&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * MIT Licensed&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * Module dependencies.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;以上来自我的男神&lt;a href=&quot;https://github.com/tj/ejs/blob/master/ejs.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TJ写的EJS模板引擎&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我就在QQ群里问了这样一个问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;第一个注释中的感叹号是什么意思，为什么第一个有感叹号，第二个没有？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后似乎没有人知道，并且我到的回答基本都是诸如：那就是行注释没什么特别的意思、在意注释干嘛反正注释也没什么用……&lt;/p&gt;
&lt;p&gt;然后我就忽然有点明白了为什么一本以下的不要…&lt;/p&gt;
&lt;p&gt;类似这样的问题，为什么在网上很难找答案？可能是因为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;搜索引擎对于特殊符号的处理导致难以按照符号来搜索&lt;br&gt;包括google和stackoverflow中输入&lt;code&gt;/*!&lt;/code&gt;并不能搜到结果&lt;/li&gt;
&lt;li&gt;因为缺乏经验而无法正确的描述问题，无法命中问题的关键字&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;像我这样比较懒的人，最希望的就是能有一个在现实生活中认识的经验丰富的大神，这种弱鸡问题，一问就有答案了。然而我并不认识这样的大神。(ಥ_ಥ)&lt;/p&gt;
&lt;p&gt;直到后来无意中看到&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/06/sass.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;阮一峰老师的SASS教程&lt;/a&gt;，提到&lt;strong&gt;重要注释&lt;/strong&gt;这个概念，受到一点启发，然后机智的我想到把感叹号直接翻译成英文，以’exclamation js comment’作为关键字来搜索，果然我不是一个人…（嗯，我变成了一条狗）&lt;br&gt;&lt;a href=&quot;http://stackoverflow.com/questions/11248363/the-purpose-of-starting-an-initial-comment-with-in-javascript-and-css-files&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://stackoverflow.com/questions/11248363/the-purpose-of-starting-an-initial-comment-with-in-javascript-and-css-files&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我不是为了输赢，我就是认真 –罗永浩&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;对前端工程化稍微有点知识的，就会知道在最后deploy之前会有一个步骤是minify / uglify，这个过程中注释都会被删除，而这个以&lt;code&gt;/*!&lt;/code&gt;开头的重要注释则会被保留，通常重要注释是用来注释版权之类的信息&lt;a href=&quot;https://zoompf.com/blog/2009/11/jsmin-important-comments-and-copyright-violations&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;^1&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;前几天看了一个帖子&lt;a href=&quot;http://www.jianshu.com/p/fdae559d1ed5&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;我招不到想要的程序员&lt;/a&gt;，里面有一点是说&lt;strong&gt;非极端情况下，一本以下的不要&lt;/str
    
    </summary>
    
    
      <category term="js" scheme="http://sabrinaluo.com/tech/tags/js/"/>
    
      <category term="感叹号" scheme="http://sabrinaluo.com/tech/tags/%E6%84%9F%E5%8F%B9%E5%8F%B7/"/>
    
      <category term="重要注释" scheme="http://sabrinaluo.com/tech/tags/%E9%87%8D%E8%A6%81%E6%B3%A8%E9%87%8A/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Page如何绑定域名</title>
    <link href="http://sabrinaluo.com/tech/2015/12/13/set-a-custom-domain-for-github-page/"/>
    <id>http://sabrinaluo.com/tech/2015/12/13/set-a-custom-domain-for-github-page/</id>
    <published>2015-12-12T16:34:42.000Z</published>
    <updated>2016-02-17T07:55:27.154Z</updated>
    
    <content type="html">&lt;p&gt;本文假设你已经在github建立了一个yourname.github.io的网站，为了看起来逼格更高，更好记，更professional，所以要绑定域名？！&lt;br&gt;我本来的github page是&lt;a href=&quot;http://sabrinaluo.github.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;sabrinaluo.github.io&lt;/a&gt;，花了一百多大洋把这个域名变成&lt;a href=&quot;http://sabrinaluo.com&quot;&gt;sabrinaluo.com&lt;/a&gt;，github.io到.com，为了省6个字符，居然要花一百多大洋QAQ&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;del&gt;只讨论一级域名的绑定，不讨论二级域名的绑定（因为我不会呀）&lt;/del&gt;&lt;br&gt;&lt;strong&gt;先讨论一级域名的绑定，假设是www.abc.com&lt;/strong&gt; &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先…你要有一个&lt;del&gt;男盆友&lt;/del&gt;域名…没有的话就去godaddy买一个；&lt;/li&gt;
&lt;li&gt;然后打开你的cmd console，ping一下你的github page，也就是输入&lt;code&gt;ping yourname.github.io&lt;/code&gt;，你会看到你的页面所在的主机的IP地址，下面的例子IP是103.245.222.133，不知道是不是所有人的IP都一样呢。&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;C:\&amp;gt;ping yourname.github.io
正在 Ping github.map.fastly.net [103.245.222.133] 具有 32 字节的数据:
来自 103.245.222.133 的回复: 字节=32 时间=5ms TTL=58
来自 103.245.222.133 的回复: 字节=32 时间=6ms TTL=58
来自 103.245.222.133 的回复: 字节=32 时间=8ms TTL=58
来自 103.245.222.133 的回复: 字节=32 时间=12ms TTL=58
103.245.222.133 的 Ping 统计信息:
数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，
往返行程的估计时间(以毫秒为单位):
最短 = 5ms，最长 = 12ms，平均 = 7ms
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;登录你的godday账号，设置一下DNS的A记录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找到你的domain，点manage DNS&lt;/li&gt;
&lt;li&gt;进入DNS设置页面后点Add Record，在弹出的对话框选A(Host)&lt;blockquote&gt;
&lt;p&gt;RECORD TYPE: A(Host)&lt;br&gt;HOST: 这里填你在godday买的域名，例如abc.com&lt;br&gt;POINTS TO: 这里填第三步获取到的IP地址&lt;br&gt;TTL: 生效的时间，不知道最短是多久，我反正是选custom之后填了600，也就是10分钟 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然后就等等等，等10分钟左右，在浏览器里访问一下你新买的域名，如果看到github的404页面，就说明DNS的设置已经成功了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;最后，在你的yourname.github.io这个repo创建一个名为&lt;code&gt;CNAME&lt;/code&gt;的文件，没有后缀名。文件内容如下：&lt;pre&gt;&lt;code&gt;abc.com
&lt;/code&gt;&lt;/pre&gt;是的，你没看错，就是辣么简单！&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;二级域名的设置&lt;/strong&gt;&lt;br&gt;假如你有两个github page，一个是blog，一个是news，那你的两个二级域名分别就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;blog.abc.com&lt;/li&gt;
&lt;li&gt;news.abc.com&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;到godday设置两条&lt;strong&gt;A记录&lt;/strong&gt;，分别设置blog及news指向github page的IP&lt;/li&gt;
&lt;li&gt;到对应的git repo下面添加对应的CNAME文件，例如在blog这个repo下的CNAME是&lt;pre&gt;&lt;code&gt;blog.abc.com
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;整个过程其实做的事情大概可以理解为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;告诉godday，当别人访问我的域名abc.com的时候，请带他们去github&lt;/li&gt;
&lt;li&gt;告诉你的github page，当别人是被abc.com带来github的时候，没错他们都是我派来的，请接收他们的访问&lt;/li&gt;
&lt;li&gt;告诉你的github page，当别人直接访问github page，也就是yourname.github.io的时候，请穿上花了一百多大洋买的马甲abc.com…（这其实是说，当你添加了cname记录之后，访问yourname.github.io，你在浏览器里看到的域名会自动变成abc.com）&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文假设你已经在github建立了一个yourname.github.io的网站，为了看起来逼格更高，更好记，更professional，所以要绑定域名？！&lt;br&gt;我本来的github page是&lt;a href=&quot;http://sabrinaluo.github.io&quot; t
    
    </summary>
    
    
      <category term="custom domain" scheme="http://sabrinaluo.com/tech/tags/custom-domain/"/>
    
      <category term="github" scheme="http://sabrinaluo.com/tech/tags/github/"/>
    
      <category term="github page" scheme="http://sabrinaluo.com/tech/tags/github-page/"/>
    
      <category term="二级域名" scheme="http://sabrinaluo.com/tech/tags/%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D/"/>
    
      <category term="域名绑定" scheme="http://sabrinaluo.com/tech/tags/%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/"/>
    
      <category term="域名解析" scheme="http://sabrinaluo.com/tech/tags/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>X-WSSE验证中关于SHA1编码方式的一些坑</title>
    <link href="http://sabrinaluo.com/tech/2015/12/11/x-wsse/"/>
    <id>http://sabrinaluo.com/tech/2015/12/11/x-wsse/</id>
    <published>2015-12-11T09:08:38.000Z</published>
    <updated>2016-02-17T07:55:27.154Z</updated>
    
    <content type="html">&lt;p&gt;不知道为什么，关于X-WSSE验证的中文资料很少，英文资料也不是很多，能搜到的资料年代都非常久远，最早可追溯到2003年&lt;a href=&quot;http://www.xml.com/pub/a/2003/12/17/dive.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;^1&lt;/a&gt;，可能这种验证方式太古老而且存在什么弊端，所以在随后的很多年里人们发现、发明了其他更常用的验证方式？&lt;/p&gt;
&lt;p&gt;关于HTTP的各种验证方式我其实一种都不知道…X-WSSE这一种奇怪的方式是我在整合Emarsys的API时了解到的。由于自身比较懒，就到Github上搜搜有没有现成的能够生成UsernameToken的包可以用，以省去重复发明轮子的功夫，然而掉进了坑里，与&lt;a href=&quot;https://github.com/bouzuya/node-wsse&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;node-wsse&lt;/a&gt;的作者大战了好几个回合…&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;此文章不讨论验证的原理，只讨论X-WSSE UsernameToken的生成方式，其中主要是生成&lt;strong&gt;passwordDigest&lt;/strong&gt;。&lt;br&gt;验证嘛，用户名username，密码password肯定是少不了的，此外还需要nonce，timeStamp，有了这几样再按照下面的步骤一步步就可以生成符合WSSE标准的token了。&lt;/p&gt;
&lt;p&gt;UsernameToken的生成一共需要&lt;strong&gt;5个步骤&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;生成一个随机字符串nonce。不同公司的API对这个nonce的要求可能会不同，有一些要求采用&lt;code&gt;base64&lt;/code&gt;编码方式，比如&lt;a href=&quot;http://symfony.com/doc/current/cookbook/security/custom_authentication_provider.html#the-authentication-provider&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;symfony给出的例子&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;时间戳（timeStamp）。对于时间戳，统一采用&lt;a href=&quot;http://baike.baidu.com/view/931641.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ISO-8601&lt;/a&gt;格式的字符串，但是不同公司的API对时区（timezone）的要求可能会不同，比如Emarsys要求UTC，Adobe要求GMT；&lt;/li&gt;
&lt;li&gt;把nonce，timeStamp，password这三个字符串按顺序连接起来形成一个新的字符串，并将这个字符串按照&lt;a href=&quot;http://baike.baidu.com/view/1228622.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SHA1&lt;/a&gt;方法加密。&lt;br&gt;&lt;strong&gt;坑来啦，坑来啦，坑来啦！！！&lt;/strong&gt;&lt;br&gt;一个字符串通常加密之后密码摘要默认是binary的，比如Adobe&lt;a href=&quot;https://marketing.adobe.com/developer/cn/documentation/authentication-1/wsse-authentication-2&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;^2&lt;/a&gt;，但有些公司可能要求以hex方式生成摘要…比如万恶的Emarsys&lt;a href=&quot;http://documentation.emarsys.com/resource/developers/api/getting-started/authentication/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;^3&lt;/a&gt;…而关于这个摘要到底应该是binary还是hex，据说业界也是模糊不清的，只能由着各家公司按自身情况使用两种方式中的某一种来实现验证&lt;a href=&quot;http://book.soundonair.ru/web/web2apps-CHP-11-SECT-1.html#web2apps-CHP-11-SECT-1.8&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;^4&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;把上一步得到的密码摘要按照&lt;code&gt;base64&lt;/code&gt;进行编码，就能得到passwordDigest；&lt;/li&gt;
&lt;li&gt;按照以下方式拼接字符串，把各个双引号内换成上面步骤所提到的值，即可得到UsernameToken，看起来长这样：&lt;pre&gt;&lt;code&gt;UsernameToken Username=&amp;quot;username&amp;quot;, PasswordDigest=&amp;quot;passwordDigest&amp;quot;, Nonce=&amp;quot;nonce&amp;quot;, Created=&amp;quot;timeStamp&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;不知道为什么，关于X-WSSE验证的中文资料很少，英文资料也不是很多，能搜到的资料年代都非常久远，最早可追溯到2003年&lt;a href=&quot;http://www.xml.com/pub/a/2003/12/17/dive.html&quot; target=&quot;_blank&quot; rel=&quot;
    
    </summary>
    
    
      <category term="SHA1" scheme="http://sabrinaluo.com/tech/tags/SHA1/"/>
    
      <category term="WSSE" scheme="http://sabrinaluo.com/tech/tags/WSSE/"/>
    
      <category term="X-WSSE" scheme="http://sabrinaluo.com/tech/tags/X-WSSE/"/>
    
      <category term="auth" scheme="http://sabrinaluo.com/tech/tags/auth/"/>
    
  </entry>
  
</feed>
