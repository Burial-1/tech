<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小白妹妹写代码</title>
  <subtitle>一个废话很多的程序媛</subtitle>
  <link href="/tech/atom.xml" rel="self"/>
  
  <link href="http://sabrinaluo.com/tech/"/>
  <updated>2016-11-24T10:12:31.650Z</updated>
  <id>http://sabrinaluo.com/tech/</id>
  
  <author>
    <name>Sabrina</name>
    <email>luohaojing@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一些js小技巧</title>
    <link href="http://sabrinaluo.com/tech/2016/10/19/some-js-tricks/"/>
    <id>http://sabrinaluo.com/tech/2016/10/19/some-js-tricks/</id>
    <published>2016-10-19T07:08:33.000Z</published>
    <updated>2016-11-24T10:12:31.650Z</updated>
    
    <content type="html"><![CDATA[<p>一直以为这篇已经发过了，结果前两天搜的时候发现搜不到。一直扔在草稿里，今天整理一下之前和最近学到的一些JS小技巧</p>
<h3 id="利用位运算取整"><a href="#利用位运算取整" class="headerlink" title="利用位运算取整"></a>利用位运算取整</h3><p>利用位运算，与、或、异或、左右移位，<code>&amp;</code> <code>|</code> <code>^</code> <code>&gt;&gt;</code> <code>&gt;&gt;&gt;</code> <code>&lt;&lt;</code> ，舍去小数点后的数字<a href="http://www.cnblogs.com/kkun/archive/2012/01/30/2332309.html" target="_blank" rel="external">^1</a>，<a href="http://jsperf.com/coercion-vs-casting/3" target="_blank" rel="external">jsPerf</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="number">6.54321</span>;</span><br><span class="line">console.<span class="built_in">log</span>(a | <span class="number">0</span>); <span class="comment">//6</span></span><br><span class="line">console.<span class="built_in">log</span>(a &amp; <span class="number">0</span>); <span class="comment">//6</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>按位<strong>非非</strong>运算也是可以的，所以你也可以用<strong>呻吟号</strong>把代码写成这样<code>~~a</code></p>
</blockquote>
<h3 id="字符串转换为数字"><a href="#字符串转换为数字" class="headerlink" title="+ 字符串转换为数字"></a>+ 字符串转换为数字</h3><p>利用加号 <code>+</code> 将数字字符串转换为数字类型<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"56789"</span>;</span><br><span class="line"><span class="keyword">var</span> b = +a;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b); <span class="comment">//number</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//56789</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<ul>
<li>只能是十进制</li>
<li>如果<code>a</code>是非数字字符串，则会返回<code>NaN</code></li>
</ul>
</blockquote>
<h3 id="强制转换为布林类型"><a href="#强制转换为布林类型" class="headerlink" title="!! 强制转换为布林类型"></a>!! 强制转换为布林类型</h3><p>利用<code>!!</code>将变量类型强制转换为<code>boolean</code>类型</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">123</span>;</span><br><span class="line"><span class="keyword">typeof</span> a; <span class="comment">//nmuber</span></span><br><span class="line"><span class="keyword">typeof</span> !!a; <span class="comment">//boolean</span></span><br></pre></td></tr></table></figure>
<h3 id="避免can-not-read-property-‘xxx’-of-null的小技巧"><a href="#避免can-not-read-property-‘xxx’-of-null的小技巧" class="headerlink" title="避免can not read property ‘xxx’ of null的小技巧"></a>避免<code>can not read property ‘xxx’ of null</code>的小技巧</h3><p>经常会遇到的一个情况是下面的代码会报错<code>can not read property &#39;c&#39; of null</code></p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span><span class="comment">(a.b.c === 1)</span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以前自己的写法以及经常见到的写法是这样</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span><span class="comment">(a &amp;&amp; a.b &amp;&amp; a.b.c === 1)</span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前几天看到一个逼格很高的写法，不过我觉得括号太多了，容易写错，而且也没有上面的那种写法简单。不过还是要记录一下，以免以后见到不知道是什么意思。</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span><span class="comment">(((a||&#123;&#125;)</span>.b||&#123;&#125;).c === <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="设置默认值"><a href="#设置默认值" class="headerlink" title="|| 设置默认值"></a>|| 设置默认值</h3><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abc</span><span class="params">(a, b)</span><span class="comment">&#123;</span><br><span class="line">    a = a || 1; </span><br><span class="line">    b = b || 2;</span><br><span class="line"></span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title">abc</span><span class="params">()</span>;</span> <span class="comment">//3</span></span><br><span class="line">abc(<span class="number">5</span>); <span class="comment">//7</span></span><br></pre></td></tr></table></figure>
<p>有一些情况下函数中需要设置默认值，经常看到有人的写法是<code>typeof</code>先判断这个参数是不是<code>undefined</code>然后再赋值，这种写法实在是太麻烦了……上面的是懒人写法</p>
<p>感觉善用<code>||</code>和<code>&amp;&amp;</code>还是能搞出很多黑科技的。</p>
<p>以上，是为打酱油博客一篇。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直以为这篇已经发过了，结果前两天搜的时候发现搜不到。一直扔在草稿里，今天整理一下之前和最近学到的一些JS小技巧&lt;/p&gt;
&lt;h3 id=&quot;利用位运算取整&quot;&gt;&lt;a href=&quot;#利用位运算取整&quot; class=&quot;headerlink&quot; title=&quot;利用位运算取整&quot;&gt;&lt;/a&gt;利
    
    </summary>
    
    
      <category term="js" scheme="http://sabrinaluo.com/tech/tags/js/"/>
    
      <category term="js小技巧" scheme="http://sabrinaluo.com/tech/tags/js%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
      <category term="tricks" scheme="http://sabrinaluo.com/tech/tags/tricks/"/>
    
  </entry>
  
  <entry>
    <title>CSS的几个小技巧：pointer-events, transform垂直居中,nth-child</title>
    <link href="http://sabrinaluo.com/tech/2016/09/20/some-css-tricks/"/>
    <id>http://sabrinaluo.com/tech/2016/09/20/some-css-tricks/</id>
    <published>2016-09-20T08:44:46.000Z</published>
    <updated>2016-11-24T10:12:31.650Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>千万不要用没有自动保存功能的编辑器！千万不要用没有自动保存功能的编辑器！千万不要用没有自动保存功能的编辑器！:(</p>
</blockquote>
<p>好久没有写什么东西了，可能是因为最近一直做的事情都是在重复搬砖，没有什么新鲜的东西…更可能是因为太懒了…</p>
<p>总结一下前段时间学到的几个css小技巧，以免过几天又忘记了</p>
<h3 id="CSS控制超链接是否可点击：pointer-event"><a href="#CSS控制超链接是否可点击：pointer-event" class="headerlink" title="CSS控制超链接是否可点击：pointer-event"></a>CSS控制超链接是否可点击：pointer-event</h3><p>一开始我听说CSS可以disable超链接的时候我是拒绝的，因为通常在有<code>href</code>属性的时候，都是用js来禁止超链接的。<br>然鹅…CSS里居然有pointer-events<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/pointer-events" target="_blank" rel="external">^1</a>这种黑科技！</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">a</span><span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">pointer-events</span>:<span class="value"> none</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="transform-垂直居中-2"><a href="#transform-垂直居中-2" class="headerlink" title="transform 垂直居中 ^2"></a>transform 垂直居中 <a href="http://zerosixthree.se/vertical-align-anything-with-just-3-lines-of-css/" target="_blank" rel="external">^2</a></h3><p>CSS垂直居中一直是一个蛋疼的问题，常常需要用到，却没有一个所有浏览器，在所有情况下都适用的解决方案。等我以后有空了，应该专门写一篇讨论CSS垂直居中各种解决方案的博客……别问我以后是什么时候…XD<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css"></span><br><span class="line"><span class="class">.bbb</span><span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">transform</span>:<span class="value"> <span class="function">translateY</span>(-<span class="number">50%</span>)</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">50%</span></span><br><span class="line"></span></span></span>&#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"aaa"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"bbb"</span>&gt;</span>qqq<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="nth-child"><a href="#nth-child" class="headerlink" title="nth-child"></a>nth-child</h3><p>通常一个列表里，总是回遇到需要高亮某几个item的情况，CSS居然还可以通过公式来控制样式，我又涨姿势了。</p>
<p>以前只知道可以控制奇数偶数这种简单的，后来发现，只要是有规律的，能够写成an+b的公式，都可以适用<code>nth-child</code><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:nth-child" target="_blank" rel="external">^3</a></p>
<ul>
<li><code>li:nth-child(even)</code> 选中偶数</li>
<li><code>li:nth-child(odd)</code> 选中奇数</li>
<li><code>li:nth-child(3n+2)</code> 从第2个开始，每3个选中一个</li>
<li><code>li:nth-child(3)</code> 直选中第3个</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;千万不要用没有自动保存功能的编辑器！千万不要用没有自动保存功能的编辑器！千万不要用没有自动保存功能的编辑器！:(&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好久没有写什么东西了，可能是因为最近一直做的事情都是在重复搬砖，没有什么新鲜的东西…更可能是
    
    </summary>
    
    
      <category term="css" scheme="http://sabrinaluo.com/tech/tags/css/"/>
    
      <category term="tricks" scheme="http://sabrinaluo.com/tech/tags/tricks/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins集成github pull request插件</title>
    <link href="http://sabrinaluo.com/tech/2016/07/14/jenkins-github-pull-request-builder/"/>
    <id>http://sabrinaluo.com/tech/2016/07/14/jenkins-github-pull-request-builder/</id>
    <published>2016-07-14T06:41:02.000Z</published>
    <updated>2016-11-24T10:12:31.650Z</updated>
    
    <content type="html"><![CDATA[<p>前不久给bootstrap提了个<a href="https://github.com/twbs/bootstrap/issues/19997" target="_blank" rel="external">issue</a>，然后被他们的高科技自动回复机器人吓萌比了。<br>有印象之前给，某些repo提PR的时候，如果是用的Travis CI，也会有相应的提示该PR是否pass了所有test case。</p>
<p>如果使用cloud based CI，很多功能都已经整合了，所以可以很方便的使用。如上travis的例子，只要在travis配置里开启pull request选项，允许PR过来的时候自动跑测试，就可以实现。</p>
<p>然而，如果使用的是jenkins这种自己服务器上的CI，配置就稍微有点麻烦了。</p>
<h3 id="整合push和jenkins"><a href="#整合push和jenkins" class="headerlink" title="整合push和jenkins"></a>整合push和jenkins</h3><p>github repo页面 &gt; Settings &gt; webhooks &amp; services</p>
<p>这里有两个选项：</p>
<ol>
<li>add webhook，可自定义触发事件，可定制程度较高</li>
<li>add service，选好对应的服务，只填一个url即可，可定制程度较低。</li>
</ol>
<p>第一个比较复杂，但是点进去看看有哪些选项也就比较清晰明了大概用法了。<br>第二个，如果使用jenkins，需要你的jenkins服务器装有对应的插件。</p>
<p>整个流程的原理是，当github收到任何事件（比如push, pr等等），就会将对应的信息发送到你填的那个url中。这个url是你jenkins服务器用来接受信息的。Jenkins收到信息之后，就会根据job的配置做相应的事情，比如构建、测试、部署等等。</p>
<h3 id="整合pull-request"><a href="#整合pull-request" class="headerlink" title="整合pull request"></a>整合pull request</h3><p>这里重点说一下怎么整合jenkins和github的pull request，<strong>实现每当有pull request时，触发CI跑测试，并将测试结果显示在github上</strong>。</p>
<p>这里需要分别在github和jenkins做相应的设置。</p>
<p>github中的设置与上部分提到的相同，主要是填url</p>
<p>jenkins服务器中：<br>首先需要安装 <a href="https://wiki.jenkins-ci.org/display/JENKINS/GitHub+pull+request+builder+plugin" target="_blank" rel="external">github pull request builder plugin</a></p>
<p>添加用户名、密码、token等等credentials相关的需要在jenkins的管理面板添加</p>
<ul>
<li>source code management，除基本选项外，需要填写advanced选项。<ul>
<li>repo name: <code>origin</code></li>
<li>repo refspec: <code>+refs/pull/*:refs/remotes/origin/pr/*</code></li>
<li>repository browser 选择githubweb</li>
</ul>
</li>
<li>Build Triggers:<ul>
<li>勾选 Github Pull Request Builder</li>
<li>勾选 Use github hooks for build triggering</li>
<li>Admin List里可以填写github用户名，这样该用户就会有对应的权限</li>
<li>advanced选项中，需要在White List以及List of organizetions填写相应的用户名，这样PR才能被自动build，不在白名单里的用户提交的pr需要管理员审核后才会build</li>
<li>如果没有勾选 Build every pull request automatically without asking (Dangerous!)，每次有pr时，机器人账号会自动评论<em>“Can one of the admins verify this patch?”</em>，之后管理员回复相应的语句来触发Jenkins操作<ul>
<li>“ok to test” 允许该pr之后自动触发jenkins build</li>
<li>“test this please” 只build一次，该pr之后的改动不会自动触发Build</li>
<li>“add to whitelist” 将该pr的作者假如白名单</li>
<li>“retest this please” 重新bulid一次<br><strong>其他选项都保持默认不要更改！</strong></li>
</ul>
</li>
</ul>
</li>
<li>构建、环境相关的设置例如<code>npm install</code> <code>npm test</code>等，跟平时一样即可。</li>
</ul>
<p>最后保存设置，提交一个pr，如果设置都正确的话，在提交pr的页面将能看到一个“正在checking…”的提示，当测试跑完之后将能看到check passed或者check failed。另外也能够在pr overview页面看到pr后面会有个绿色的小勾或红色的小叉。</p>
<p>于是谁提交的pr不通过测试就能一目了然，再也不用帮别人fix test case啦！</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://jakubstas.com/github-and-jenkins-pull-request-checking" target="_blank" rel="external">http://jakubstas.com/github-and-jenkins-pull-request-checking</a><br><a href="http://jakubstas.com/github-and-jenkins-integration" target="_blank" rel="external">http://jakubstas.com/github-and-jenkins-integration</a><br><a href="https://www.theguild.nl/building-github-pull-requests-with-jenkins" target="_blank" rel="external">https://www.theguild.nl/building-github-pull-requests-with-jenkins</a><br><a href="https://wiki.jenkins-ci.org/display/JENKINS/GitHub+pull+request+builder+plugin" target="_blank" rel="external">https://wiki.jenkins-ci.org/display/JENKINS/GitHub+pull+request+builder+plugin</a><br><a href="https://github.com/jenkinsci/ghprb-plugin" target="_blank" rel="external">https://github.com/jenkinsci/ghprb-plugin</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前不久给bootstrap提了个&lt;a href=&quot;https://github.com/twbs/bootstrap/issues/19997&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;issue&lt;/a&gt;，然后被他们的高科技自动回复机器人吓萌比了。&lt;b
    
    </summary>
    
    
      <category term="CI" scheme="http://sabrinaluo.com/tech/tags/CI/"/>
    
      <category term="github" scheme="http://sabrinaluo.com/tech/tags/github/"/>
    
      <category term="jenkins" scheme="http://sabrinaluo.com/tech/tags/jenkins/"/>
    
      <category term="持续集成" scheme="http://sabrinaluo.com/tech/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>微博开放平台的Basic Auth和OAuth2.0认证</title>
    <link href="http://sabrinaluo.com/tech/2016/06/20/intro-of-oauth2-0/"/>
    <id>http://sabrinaluo.com/tech/2016/06/20/intro-of-oauth2-0/</id>
    <published>2016-06-20T09:59:09.000Z</published>
    <updated>2016-11-24T10:12:31.650Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章不是讲各种认证方式是怎么实现的，只是简单的介绍如何与微博进行整合。</p>
<p>微博开放平台允许使用api来开发一些与微博相关的应用，微博提供<strong>Basic Auth</strong>和<strong>OAuth2.0</strong>两种认证方式，其中Basic Auth只能用于测试环境。</p>
<h3 id="Basic-Auth"><a href="#Basic-Auth" class="headerlink" title="Basic Auth"></a>Basic Auth</h3><p>跟名字一样，就是很基本很简单。其本质是使用<code>username:password</code>进行<code>base64</code>加密之后得到一个token，然后发送的请求中添加一个header <code>Authorization: Basic token</code>。</p>
<h3 id="OAuth-2-0"><a href="#OAuth-2-0" class="headerlink" title="OAuth 2.0"></a>OAuth 2.0</h3><p>生产环境中，微博只允许使用这种认证方式，这个比起直接用用户名和密码就要复杂一些。</p>
<p>简单的来说OAuth2.0认证的流程大概是这样：</p>
<ol>
<li>首先发一个请求去微博，告诉它，我要登陆啦</li>
<li>然后微博返回一个登录页面，等待用户用微博账号登陆</li>
<li>用户登陆之后，页面会跳转到<strong>授权回调页</strong>，这个页面的url会有一个query是<code>code=</code>，后面跟着的一串code</li>
<li>当进行其他api调用时，在api后加上query<code>code=xxx</code>以及其他要求的参数，比如<code>client_id</code>，<code>client_key</code>等等即可进行调用</li>
</ol>
<ul>
<li>开放平台&gt;我的应用&gt;应用信息&gt;基本信息，这里能看到app key和 app token</li>
<li>开放平台&gt;我的应用&gt;应用信息&gt;高级信息，这里需要填写授权回调页和取消授权回调页</li>
</ul>
<p>需要注意的是，在第2步和第3步中，授权回调页的链接一定要和在申请app时填写的<strong>一！模！一！样！</strong>，否则会报错。</p>
<p>比如在app填写的是<code>http://example.com/auth/</code>，而api请求时参数写为<code>http://example.com/auth</code>，少了个斜杠都是错的…</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a href="http://open.weibo.com/wiki/Oauth2/authorize" target="_blank" rel="external">http://open.weibo.com/wiki/Oauth2/authorize</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章不是讲各种认证方式是怎么实现的，只是简单的介绍如何与微博进行整合。&lt;/p&gt;
&lt;p&gt;微博开放平台允许使用api来开发一些与微博相关的应用，微博提供&lt;strong&gt;Basic Auth&lt;/strong&gt;和&lt;strong&gt;OAuth2.0&lt;/strong&gt;两种认证方式，其
    
    </summary>
    
    
      <category term="OAuth2.0" scheme="http://sabrinaluo.com/tech/tags/OAuth2-0/"/>
    
  </entry>
  
  <entry>
    <title>利用travis进行heroku部署</title>
    <link href="http://sabrinaluo.com/tech/2016/06/02/travis-heroku/"/>
    <id>http://sabrinaluo.com/tech/2016/06/02/travis-heroku/</id>
    <published>2016-06-02T07:27:46.000Z</published>
    <updated>2016-11-24T10:12:31.646Z</updated>
    
    <content type="html"><![CDATA[<p>好久么有写东西了，总感觉一直忙的跟狗一样，身心俱疲，但是又不知道到底在忙什么。</p>
<p>最近实践了一下利用travis部署到heroku的流程，又莫名其妙的尝试了新的编辑器atom，安装了markdown-preview-plus插件，当然要来写点东西试一试， 也不知道英文的linux下到底是什么问题，webstorm和sublime居然不能打中文，所以之前每次写东西都要去简书边预览边写。</p>
<p>atom还是很好用的，可能因为我（后）天生就对JS写的东西有好感，记不住快捷键的我，不能徒手写html的我还是需要IDE的帮助，atom就用来写点简单的东西吧。</p>
<p>travis和heroku都有自己的命令行工具（CLI），尤其travis cli用起来总比徒手写.travis.yml方便许多</p>
<h3 id="安装travis-cli"><a href="#安装travis-cli" class="headerlink" title="安装travis-cli"></a>安装travis-cli</h3><p>travis-cli是ruby写的，所以安装之前需要安装ruby</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get <span class="operator"><span class="keyword">install</span> ruby-<span class="keyword">full</span></span></span><br></pre></td></tr></table></figure>
<p>详细的安装教程可以看官方的这个<a href="https://github.com/travis-ci/travis.rb#installation" target="_blank" rel="external">https://github.com/travis-ci/travis.rb#installation</a></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">gem</span> install travis -v <span class="number">1</span>.<span class="number">8</span>.<span class="number">2</span> --<span class="built_in">no</span>-rdoc --<span class="built_in">no</span>-ri</span><br></pre></td></tr></table></figure>
<h3 id="安装heroku-cli"><a href="#安装heroku-cli" class="headerlink" title="安装heroku-cli"></a>安装heroku-cli</h3><p>heroku-cli也是ruby写的……有点不懂为啥都喜欢用ruby写cli？js不是挺好的吗，有啥cli是<code>npm install -g</code> 解决不了的吗？…<br>具体的安装教程看</p>
<ul>
<li><a href="https://toolbelt.heroku.com" target="_blank" rel="external">https://toolbelt.heroku.com</a></li>
<li><a href="https://devcenter.heroku.com/articles/heroku-command#installing-the-heroku-cli" target="_blank" rel="external">https://devcenter.heroku.com/articles/heroku-command#installing-the-heroku-cli</a></li>
</ul>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O- http<span class="variable">s:</span>//toolbelt.heroku.<span class="keyword">com</span>/install-ubuntu.<span class="keyword">sh</span> | <span class="keyword">sh</span></span><br></pre></td></tr></table></figure>
<h3 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">travis</span> login</span><br></pre></td></tr></table></figure>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">heroku</span> login</span><br></pre></td></tr></table></figure>
<h3 id="travis-yml"><a href="#travis-yml" class="headerlink" title=".travis.yml"></a>.travis.yml</h3><p>在项目的根目录下执行以下命令，将会生成<code>.travis.yml</code>文件<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">travis</span> init</span><br><span class="line">travis setup heroku</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：一定要通过命令行登陆heroku，否则travis会卡住，也不报错啥的反正就一直没反应</p>
</blockquote>
<p>打开<code>.travis.yml</code>文件可以看到除了基本的信息之外，还有<code>deploy</code>相关的信息，其中比较让人疑惑的是<code>api_key</code>，这个<code>api_key</code>其实是你的heroku账户的token加密之后的一个字符串。heroku的token看起来是一个类似uuid5的字符串，可以通过以下命令查看<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">heroku</span> <span class="tag">auth</span><span class="pseudo">:token</span></span><br></pre></td></tr></table></figure></p>
<p>有一个问题我不太明白的是，之前用travis加密文件<code>travis encrypt-file path/of/file --add</code>的时候，可以在travis网站对应repo的setting里看到多出的环境变量，用来加密的key value，然后需要用<code>openssl</code>命令来解密。</p>
<p>但加密heroku的token后，并没有生成任何新的环境变量，而且也无需在<code>.travis.yml</code>中执行解密的相关操作。</p>
<p>那么用来加密的key value到底存在哪里了呢？！</p>
<h3 id="为什么要在travis做部署，而不直接利用heroku提供的github自动部署？"><a href="#为什么要在travis做部署，而不直接利用heroku提供的github自动部署？" class="headerlink" title="为什么要在travis做部署，而不直接利用heroku提供的github自动部署？"></a>为什么要在travis做部署，而不直接利用heroku提供的github自动部署？</h3><p>首先，heroku似乎不能跑测试…</p>
<p>其实，大多数简单的项目其实都可以用github的方式，如果需要编译和生成的，都在<code>package.json</code>里添加<code>prepublish</code>脚本即可</p>
<p>我这次又是搞了一个奇怪的事情，做了一个前后端分离项目，后端提供RESTful API,前端是SPA，但是又想把SPA和API放在同一个服务器，而且分了两个repo来放前端和后端。</p>
<p>所以我的需求是，当前端或后端push之后，trigger travis去把前后端都克隆下来，并且编译和Build前端代码，放到指定文件夹，然后部署。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久么有写东西了，总感觉一直忙的跟狗一样，身心俱疲，但是又不知道到底在忙什么。&lt;/p&gt;
&lt;p&gt;最近实践了一下利用travis部署到heroku的流程，又莫名其妙的尝试了新的编辑器atom，安装了markdown-preview-plus插件，当然要来写点东西试一试， 也不知
    
    </summary>
    
    
      <category term="heroku" scheme="http://sabrinaluo.com/tech/tags/heroku/"/>
    
      <category term="travis" scheme="http://sabrinaluo.com/tech/tags/travis/"/>
    
      <category term="持续集成" scheme="http://sabrinaluo.com/tech/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
      <category term="自动部署" scheme="http://sabrinaluo.com/tech/tags/%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>微信撤回信息昵称显示原理分析</title>
    <link href="http://sabrinaluo.com/tech/2016/04/21/theory-analysis-for-wechat-recall-message-nickname/"/>
    <id>http://sabrinaluo.com/tech/2016/04/21/theory-analysis-for-wechat-recall-message-nickname/</id>
    <published>2016-04-21T09:07:08.000Z</published>
    <updated>2016-11-24T10:12:31.646Z</updated>
    
    <content type="html"><![CDATA[<h3 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h3><p>为了让各位亲朋好友方便的用撤回信息装x，本宝宝写了一个<a href="http://sabrinaluo.com/nickname-gen">昵称生成器</a><br>虽然是比较简单的页面，但本宝宝还没发布呢，微信就封了这个功能，宝宝心里委屈但宝宝不说…</p>
<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>今天早些时候，在微信群里看到了这样的撤回信息：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"牛奶"</span>撤回了一条信息并亲了你一下</span><br></pre></td></tr></table></figure></p>
<p>开始的时候我是一脸懵逼的，然后知道复制牛奶的昵称，然后再修改就可以实现这个效果，<strong>一定要复制，一个字一个字打就不行</strong>。<br>之后有同学转发了<a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY5NzI4MQ==&amp;mid=505551279&amp;idx=1&amp;sn=f10a4b837a10ed9c4a252c606f2f7c7f&amp;scene=1&amp;srcid=0421JP3AeSA1CmbSqEn1rLMh&amp;from=singlemessage&amp;isappinstalled=0&amp;pass_ticket=HbJ8e6BomIu6b3R%2Bi6i69%2FT2TY3g%2FHUMQSItE5M2cd8%3D" target="_blank" rel="external">一篇文章</a>，然后大家纷纷搞出了各种有趣的效果：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="string">"zz并亲了你一下"</span>撤回了一条消息</span><br><span class="line"><span class="number">2.</span> <span class="string">"朱饼饼息消条一了回撤"</span>并又瘦了一斤</span><br><span class="line"><span class="number">3.</span> <span class="string">"仝哈哈"</span>撤回了一条消息下一你了亲并</span><br></pre></td></tr></table></figure></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>机智的我一开始就猜到，肯定是有些什么看不见的特殊字符导致的。</p>
<p>作为一只前端狗，首先想到的当然是打开web微信，F12，看看昵称里到底是什么鬼，果然不出所料，我的昵称是这样的：<code>&amp;#8238;&amp;#8238;&amp;#8238; 用卵么什有没并而然&amp;#8237;萝卜</code></p>
<p>于是开始找这个<code>&amp;#8238;</code>特殊字符到底是做什么的，机智的我很快就找到了<a href="http://www.fileformat.info/info/unicode/char/202e/index.htm" target="_blank" rel="external">^1</a><br>首先这种字符叫做<em>Unicode_control_characters</em><a href="https://en.wikipedia.org/wiki/Unicode_control_characters" target="_blank" rel="external">^2</a><br>要知道更详细的内容（比如这种字符最开始是用于阿拉伯文等东亚文字的排版，另外类似的字符还有好几个，但）可以看看wiki的双向文稿<a href="https://zh.wikipedia.org/wiki/%E9%9B%99%E5%90%91%E6%96%87%E7%A8%BF" target="_blank" rel="external">^3</a>，还有其他更详细的使用范例<a href="https://www.w3.org/International/questions/qa-bidi-unicode-controls" target="_blank" rel="external">^4</a></p>
<table>
<thead>
<tr>
<th style="text-align:center">html特殊符号</th>
<th style="text-align:center">js unicode</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&amp;#8237;</code></td>
<td style="text-align:center"><code>\u202D</code></td>
<td style="text-align:left">Unicode Character ‘LEFT-TO-RIGHT OVERRIDE’</td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;#8238;</code></td>
<td style="text-align:center"><code>\u202E</code></td>
<td style="text-align:left">Unicode Character ‘RIGHT-TO-LEFT OVERRIDE’</td>
</tr>
</tbody>
</table>
<p>所以<code>8237</code>的作用是从左到右显示，<code>8238</code>的作用是从右到左显示。</p>
<p>也就是说，跟在<code>8238</code>后面的字符串将从右到左显示（原来的排版方式会被override，直到遇到其他的控制排版的字符(Unicode_control_characters)）；而跟在<code>8237</code>后面的字符串将从左到右显示。</p>
<p>由于大家在复制的时候根本看不到这些字符，而且可能因为在修改昵称时<strong>删除</strong>或<strong>加多</strong>了这些特殊符号，所以产生了各种奇怪的效果。而前面提到的最正确我的昵称应该是只有一个<code>8238</code>，也就是这样<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">&amp;</span><span class="id">#8238</span>;用卵么什有没并而然<span class="keyword">&amp;</span><span class="id">#8237</span>;萝卜</span><br></pre></td></tr></table></figure></p>
<p>微信撤回信息的显示逻辑是，<code>&quot;昵称&quot;+撤回了一条信息</code>，昵称前后是有引号的。<br>所以实际上，撤回信息的<strong>字符串</strong>是<code>&quot;&amp;#8238;用卵么什有没并而然&amp;#8237;萝卜&quot;撤回了一条信息</code>。<br>根据之前提到的<code>8238</code>和<code>8237</code>的作用以及前提条件（正常情况下我们看到的字都是从左到右显示），分解过程如下：（LTR从左到右，RTL从右到左）</p>
<ol>
<li>`第一个引号是正常显示，这个引号是LTR显示的强字符： （”）</li>
<li><code>&amp;#8238;</code>后面的 <em>用卵么什有没并而然</em> 是RTL显示的强字符：（”然而并没有什么卵用）</li>
<li><code>&amp;#8237;</code>后面的 <em>萝卜”撤回了一条信息</em> 是LTR显示的强字符，所以会<strong>紧跟</strong>前面的LTR的强字符，也就是紧跟第一个引号 ：（”萝卜”撤回了一条信息然而并没有什么卵用）</li>
</ol>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>上面提到的有趣的效果分析：</p>
<ol>
<li>根本没有复制到特殊符号</li>
<li>复制到特殊符号，但”并亲了你一下”被写反了，实际的文本为<code>&amp;#8238;并亲了你一下&amp;#8237;仝哈哈</code></li>
<li>复制到的特殊符号不正确，实际的文本为<code>&amp;#8238;斤一了瘦又并&amp;#8237;朱饼饼&amp;#8238;</code></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;吐槽&quot;&gt;&lt;a href=&quot;#吐槽&quot; class=&quot;headerlink&quot; title=&quot;吐槽&quot;&gt;&lt;/a&gt;吐槽&lt;/h3&gt;&lt;p&gt;为了让各位亲朋好友方便的用撤回信息装x，本宝宝写了一个&lt;a href=&quot;http://sabrinaluo.com/nickname-gen
    
    </summary>
    
    
      <category term="微信，撤回信息，原理分析，双向文稿，" scheme="http://sabrinaluo.com/tech/tags/%E5%BE%AE%E4%BF%A1%EF%BC%8C%E6%92%A4%E5%9B%9E%E4%BF%A1%E6%81%AF%EF%BC%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%EF%BC%8C%E5%8F%8C%E5%90%91%E6%96%87%E7%A8%BF%EF%BC%8C/"/>
    
  </entry>
  
  <entry>
    <title>如何通过Git钩子自动部署(Push to Deploy)</title>
    <link href="http://sabrinaluo.com/tech/2016/04/14/push-to-deploy-through-git-hook/"/>
    <id>http://sabrinaluo.com/tech/2016/04/14/push-to-deploy-through-git-hook/</id>
    <published>2016-04-14T10:59:37.000Z</published>
    <updated>2016-11-24T10:12:31.646Z</updated>
    
    <content type="html"><![CDATA[<p>看了好多讲通过git钩子自动部署的，大多讲的绕来绕去乱七八糟思路一点也不清晰…<br>做了一晚上实验之后大概明白了是怎么工作的。</p>
<h3 id="裸仓库（bare）"><a href="#裸仓库（bare）" class="headerlink" title="裸仓库（bare）"></a>裸仓库（bare）</h3><p>裸仓库跟我们平时<code>git clone</code>得到的仓库太一样，裸仓库其实相当于通过克隆来的仓库里的<code>.git</code>文件夹，整个裸仓库中只有git索引（index），<strong>并没有任何代码相关的东西</strong>。要实现Push to Deploy，首先我们需要一个裸仓库。</p>
<p>在克隆时使用 <code>--bare</code>参数来克隆一个裸仓库<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init <span class="comment">--bare xxx-bare</span></span><br></pre></td></tr></table></figure></p>
<p>###钩子（hook）<br>普通仓库<code>.git</code>文件夹下有一个<code>hooks</code>文件夹，裸仓库下直接有一个<code>hooks</code>文件夹，里面有各种各样以<code>.sample</code>结尾的钩子，当把<code>.sample</code>后缀删除时，钩子就是激活状态。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.git</span></span><br><span class="line">├───hooks</span><br><span class="line">│   └───post-update<span class="class">.sample</span>   </span><br><span class="line">└─── ...</span><br></pre></td></tr></table></figure></p>
<p>你可以在钩子文件里写一些bash命令，被激活的钩子被触发时会执行你的bash命令。</p>
<p>与deploy相关的通常使用<code>post-update</code>钩子或者<code>post-receive</code>钩子<a href="https://www.kernel.org/pub/software/scm/git/docs/githooks.html" target="_blank" rel="external">^1</a>，关于这两个钩子到底有什么不同，我是没太看懂，大概的理解是这两个钩子被trigger的时候收到的信息不一样，如果需要用commit的相关信息来做一些事情的话要仔细研究（比如可以设置某个分支收到了推送就做相应的事情之类），其他如果只是通过bash来跑一些node相关的部署命令，两个都可以。这篇文章只给一个最简单的例子，跟分支啊什么的都没关系，只要收到推送就部署。</p>
<p>要实现Push to Deploy，我们需要修改裸仓库中相应的钩子文件</p>
<h3 id="裸仓库是怎么工作的"><a href="#裸仓库是怎么工作的" class="headerlink" title="裸仓库是怎么工作的"></a>裸仓库是怎么工作的</h3><p>可以在本地同一个文件夹下先创建一个裸仓库名为xxx-remote（模拟远程服务器），再创建一个xxx-local仓库（模拟本地），将xxx-remote添加为本地仓库的远程仓库，在本地仓库写一个<code>README.md</code>文件，提交并push<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git init <span class="comment">--bare xxx-remote</span></span><br><span class="line">git init xxx-<span class="built_in">local</span></span><br><span class="line">cd xxx-<span class="built_in">local</span></span><br><span class="line">git remote <span class="built_in">add</span> origin ../xxx-remote</span><br><span class="line">echo test123&gt;README.md</span><br><span class="line">git <span class="built_in">add</span> .</span><br><span class="line">git commit -m <span class="string">'add readme file'</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></p>
<p>之后切换到远程仓库文件夹，查看git log<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">cd</span> xxx-remote</span><br><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure></p>
<p>将能够看到有一条commit记录，提交信息是 add readme file，远程仓库收到了本地仓库的push</p>
<h3 id="钩子是怎么工作的"><a href="#钩子是怎么工作的" class="headerlink" title="钩子是怎么工作的"></a>钩子是怎么工作的</h3><p>进入远程仓库，将<code>hooks</code>文件夹下的<code>post-update.sample</code>改名为<code>post-update</code>，打开并编辑为如下内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/bin/sh</span></span><br><span class="line"><span class="built_in">set</span> -x <span class="comment">#显示每条命令</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"push push"</span></span><br></pre></td></tr></table></figure></p>
<p>修改本地仓库的文件，进行一次推送，将会看到远程服务器执行了相应的命令<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Total <span class="number">0</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line"><span class="label">remote:</span> + echo <span class="keyword">push</span> <span class="keyword">push</span></span><br><span class="line"><span class="label">remote:</span> <span class="keyword">push</span> <span class="keyword">push</span></span><br><span class="line">To ../xxx</span><br><span class="line"> + <span class="number">41</span>b78ee..<span class="number">.055</span>cec9 master -&gt; master (forced update)</span><br></pre></td></tr></table></figure></p>
<h3 id="一个完整的场景举例"><a href="#一个完整的场景举例" class="headerlink" title="一个完整的场景举例"></a>一个完整的场景举例</h3><p>假设有一台远程服务器上跑着一个网站，希望每次git push之后这个网站就自动更新。<br>为了方便：</p>
<ul>
<li>假设远程服务器上放了<strong>裸仓库</strong>和<strong>网站</strong>，自动部署的过程就是裸仓库收到push之后更新一下网站的文件夹</li>
<li>假设网站都是静态文件，不需要重启web server</li>
<li>假设都只考虑默认的master分支</li>
</ul>
<p>我们需要：</p>
<ol>
<li><p>在这台远程服务器上创建一个裸仓库，假如名叫xxx。克隆repo取名为website，用于存放网站文件</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init --bare xxx</span><br><span class="line">git <span class="keyword">clone</span> <span class="title">./xxx</span> website</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改远程服务器下<code>hooks</code>文件夹下的<code>post-update.sample</code>改名为<code>post-update</code>，编辑为如下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/bin/sh</span></span><br><span class="line"><span class="built_in">set</span> -x <span class="comment">#显示每条命令</span></span><br><span class="line">git reset --hard origin/master <span class="comment">#防止因为forced push而导致无法checkout</span></span><br><span class="line">git checkout</span><br></pre></td></tr></table></figure>
</li>
<li><p>在本地repo添加远程仓库</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin ubuntu<span class="variable">@59</span>.<span class="number">64.123</span>.<span class="number">123</span><span class="symbol">:home/xxx</span>.git</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>4.在本地仓库修改文件并push</p>
<p>至此整个git自动部署的过程就完成了</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看了好多讲通过git钩子自动部署的，大多讲的绕来绕去乱七八糟思路一点也不清晰…&lt;br&gt;做了一晚上实验之后大概明白了是怎么工作的。&lt;/p&gt;
&lt;h3 id=&quot;裸仓库（bare）&quot;&gt;&lt;a href=&quot;#裸仓库（bare）&quot; class=&quot;headerlink&quot; title=&quot;裸仓
    
    </summary>
    
    
      <category term="git" scheme="http://sabrinaluo.com/tech/tags/git/"/>
    
      <category term="hook" scheme="http://sabrinaluo.com/tech/tags/hook/"/>
    
      <category term="自动部署" scheme="http://sabrinaluo.com/tech/tags/%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>结合使用Babel Mocha Istanbul进行ES6代码测试和覆盖率测试</title>
    <link href="http://sabrinaluo.com/tech/2016/04/12/babel-mocha-istanbul-es6-testing-and-coverage/"/>
    <id>http://sabrinaluo.com/tech/2016/04/12/babel-mocha-istanbul-es6-testing-and-coverage/</id>
    <published>2016-04-12T04:32:01.000Z</published>
    <updated>2016-11-24T10:12:31.646Z</updated>
    
    <content type="html"><![CDATA[<p>题外话：<br>一直以为mocha读作“抹茶”并且一直这么读了很久，直到最近看了一个mocha的教学视频，才知道这是摩卡咖啡的摩卡…而抹茶的抹茶应该是matcha…</p>
<p>在还没有babel的时候，一切都很简单，基础的问题就先不讨论了，这里主要记录一下Babel转码和Istanbul测覆盖率的一些坑。</p>
<h3 id="基本设置"><a href="#基本设置" class="headerlink" title="基本设置"></a>基本设置</h3><p>通常我们会有好几个文件夹，例如</p>
<ul>
<li><code>src</code>用来存放源文件，也就是包含es6,7的代码；</li>
<li><code>lib</code>用来存放编译后的代码</li>
<li><code>test</code>用来放测试脚本</li>
</ul>
<p>在<code>test</code>文件夹下，通常有一个<code>mocha.opts</code>文件用来存放mocha的参数<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">-compilers <span class="symbol">js:</span>babel-register</span><br><span class="line"></span>-<span class="ruby">-<span class="keyword">require</span> babel-polyfill</span></span><br></pre></td></tr></table></figure></p>
<p>如果用到了需要用babel-polyfill才能实现的方法就需要加上第二句，别忘了<code>npm install babel-polyfill --save-dev</code></p>
<p>生成覆盖率的测试命令：（<code>_mocha</code> 是有下划线的）<a href="http://www.ruanyifeng.com/blog/2015/06/istanbul.html" target="_blank" rel="external">^1</a><br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">istanbul</span> <span class="comment">cover</span> <span class="comment">_mocha</span> <span class="literal">-</span><span class="literal">-</span>  <span class="literal">-</span><span class="literal">-</span><span class="comment">opts</span> <span class="string">.</span><span class="comment">/test/mocha</span><span class="string">.</span><span class="comment">opts</span></span><br></pre></td></tr></table></figure></p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">babel src/ -d <span class="class"><span class="keyword">lib</span>/ --<span class="title">presets</span> <span class="title">es2015</span> --<span class="title">source</span>-<span class="title">map</span> <span class="title">both</span></span></span><br></pre></td></tr></table></figure>
<p>使用<code>--source-map both</code>参数将会生成source map，有了source map，istanbul就能够追踪到<code>src</code>下的源代码的覆盖率</p>
<h3 id="正确的require"><a href="#正确的require" class="headerlink" title="正确的require"></a>正确的require</h3><p>在mocha中，一定要require <code>src</code>文件夹下的文件，而不是<code>lib</code>文件夹下的文件。虽然两个文件夹下的文件mocha都能测，但是覆盖率会有一些问题。</p>
<h3 id="可能的问题"><a href="#可能的问题" class="headerlink" title="可能的问题"></a>可能的问题</h3><ul>
<li><p>出现以下错误提示时，很可能因为istanbul的版本过低，使用<code>1.0.0-alpha.2</code>版本可以正常运行</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No coverage information was collected, <span class="keyword">exit</span> <span class="keyword">without</span> writing coverage information</span><br></pre></td></tr></table></figure>
</li>
<li><p>istanbul生成的覆盖率文件里代码几乎都是<strong>红色</strong>的，这是因为编译时没有 <code>--source-map both</code> 参数，追踪的是<code>lib</code>文件夹下的覆盖率</p>
</li>
<li>istanbul生成的覆盖率文件总是显示100%，就算有些地方没测，也显示100%，这是因为在Mocha里require的是<code>lib</code>而非<code>src</code></li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>我最喜欢mocha的报告形式是<code>-R nyan</code>，一只可爱的喵星人，没有错的时候是这样的^_^，有错的时候是这样的O_O，反正就是萌萌萌。</p>
<p>然而最实用的报告形式可能是<code>-R mochawesome</code>，需要<code>npm i mochawesome</code>安装插件，生成直观的html测试报告<a href="http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html" target="_blank" rel="external">^2</a></p>
<p>平时遇到的问题十有八九一搜都能找到阮一峰老师的教程…这覆盖率也太高了？！</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a href="http://www.ruanyifeng.com/blog/2015/06/istanbul.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2015/06/istanbul.html</a><br>[2] <a href="http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题外话：&lt;br&gt;一直以为mocha读作“抹茶”并且一直这么读了很久，直到最近看了一个mocha的教学视频，才知道这是摩卡咖啡的摩卡…而抹茶的抹茶应该是matcha…&lt;/p&gt;
&lt;p&gt;在还没有babel的时候，一切都很简单，基础的问题就先不讨论了，这里主要记录一下Babel转码
    
    </summary>
    
    
      <category term="ES6" scheme="http://sabrinaluo.com/tech/tags/ES6/"/>
    
      <category term="babel" scheme="http://sabrinaluo.com/tech/tags/babel/"/>
    
      <category term="istanbul" scheme="http://sabrinaluo.com/tech/tags/istanbul/"/>
    
      <category term="mocha" scheme="http://sabrinaluo.com/tech/tags/mocha/"/>
    
      <category term="代码覆盖率" scheme="http://sabrinaluo.com/tech/tags/%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87/"/>
    
      <category term="测试" scheme="http://sabrinaluo.com/tech/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>箭头函数的作用域和this</title>
    <link href="http://sabrinaluo.com/tech/2016/04/01/scope-and-this-of-arrow-function/"/>
    <id>http://sabrinaluo.com/tech/2016/04/01/scope-and-this-of-arrow-function/</id>
    <published>2016-04-01T08:38:12.000Z</published>
    <updated>2016-11-24T10:12:31.646Z</updated>
    
    <content type="html"><![CDATA[<p>JS里的作用域和this一直是一件令人头疼的事情，以前接触的不太多，毕竟面向过程编程的我基本上都不会使用“类”这个概念。</p>
<p>自从开始学习ES6，很长一段时间都认为箭头函数(Arrow Function)<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="external">^1</a>就是给懒人用的<strong>简写的匿名函数</strong>而已。后来看到有人挑战阮一峰老师<a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">《ECMAScript 6入门》</a>中关于箭头函数this的一些问题<a href="https://github.com/ruanyf/es6tutorial/issues/150" target="_blank" rel="external">^2</a>，才对箭头函数有了一丁点的理解。</p>
<p>我平时的工作基本上都是各种第三方的API整合，于是各种异步请求，promise都是家常便饭。由于SalesForce没有直接的nodejs sdk，所以自己写一个自定义的类就不可避免了。在写的过程中，关于this踩到坑里了，所以就有了这篇文章。</p>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>其中一个简单的功能是，查找用户是否存在，若存在则发送欢迎邮件（整个流程对应<code>onBoardFlow</code>）。实际场景比这个要复杂，可能需要连续发送好几个请求，为了避免<em>回调地狱</em>，所有的请求我都用promise包了起来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">'use strict'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalesForce</span> </span>&#123;</span><br><span class="line">  constructor(email, username) &#123;</span><br><span class="line">    <span class="keyword">this</span>.email = email;</span><br><span class="line">    <span class="keyword">this</span>.username = username;</span><br><span class="line">  &#125;</span><br><span class="line">  checkUser()&#123;</span><br><span class="line">    <span class="keyword">return</span> getUserByName(<span class="keyword">this</span>.username); <span class="comment">//发送一个请求到salesforce，返回一个promise</span></span><br><span class="line">  &#125;</span><br><span class="line">  sendEmail()&#123;</span><br><span class="line">    <span class="keyword">return</span> send(<span class="keyword">this</span>.email); <span class="comment">//发送一个请求通知salesforce发送邮件，返回一个promise</span></span><br><span class="line">  &#125;</span><br><span class="line">  onBoardFlow()&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p><strong>在<code>onBoardFlow</code>中，搞不清this和作用域的我首先这么写：</strong><br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span>例<span class="number">1</span></span><br><span class="line"><span class="keyword">this</span>.checkuser().<span class="keyword">then</span>(<span class="keyword">this</span>.sendEmail);  <span class="regexp">//</span>Cannot read property <span class="string">'email'</span> <span class="keyword">of</span> <span class="literal">undefined</span></span><br></pre></td></tr></table></figure></p>
<p>然后想到了在promise链中，this指向的是global；</p>
<blockquote>
<p>Q: <strong>为什么能找到<code>this.sendEmail()</code>方法，却找不到<code>this.email</code>属性呢？</strong><br>A: 我的理解是：因为<code>this.sendEmail</code>是作为参数传入，传入的this是then外部的this，也就是<code>SalesForce</code>对象；<br>而this.sendEmail函数的作用域中产生了<strong>新的this</strong>，而这个this指向global（浏览器中为window对象）；在严格模式下this为undefined；</p>
</blockquote>
<p><strong>然后容易想到的就是各种_this self，然后bind(this) call(_this)之类的</strong><br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例2</span></span><br><span class="line"><span class="keyword">this</span>.checkuser().<span class="keyword">then</span>(<span class="keyword">this</span>.sendEmail.bind(<span class="keyword">this</span>));  <span class="comment">//it works !</span></span><br></pre></td></tr></table></figure></p>
<p>这样是可以正常工作的，但感觉怪怪的，每个then都要<code>bind(this)</code>真是一点也不优雅。</p>
<p><strong>匿名函数和箭头函数原来不一样啊</strong><br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例3</span></span><br><span class="line"><span class="keyword">this</span>.checkuser().then(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.sendEmail();</span><br><span class="line">&#125;);  <span class="comment">//Cannot read property 'updateFunnelData' of undefined</span></span><br></pre></td></tr></table></figure></p>
<p>此时<code>this.sendEmail</code>的this是then中的匿名函数新产生的promise作用域下的this，非严格模式下指向global</p>
<blockquote>
<p>在箭头函数出现之前，每个新定义的函数都将新产生自己作用域下的this, arguments等对象<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="external">^1</a></p>
</blockquote>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">4</span></span><br><span class="line"><span class="keyword">this</span>.checkuser().<span class="keyword">then</span>(<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">this</span>.sendEmail());  <span class="regexp">//i</span>t works!</span><br></pre></td></tr></table></figure>
<h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>作用域内可以嵌套作用域，从而形成作用域链，在最外层的也就是全局作用域，当在内部查找一个对象时，会顺着作用域链最内层，层层向外寻找，直到找到为止。</p>
<p>在例3中，匿名函数的作用域中产生了新的<code>this</code>，该<code>this</code>指向global<br>在例4中，箭头函数的作用域中没有产生新的this，所以顺着作用域链层层往外寻找<code>this</code>，找到<code>onBoardFlow()</code>的作用域时，找到了<code>this</code>，而此时<code>this</code>就是<code>SalesForce</code>对象</p>
<h3 id="为什么promise中的this指向global"><a href="#为什么promise中的this指向global" class="headerlink" title="为什么promise中的this指向global"></a>为什么promise中的this指向global</h3><p>这个，我还没学会…</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JS里的作用域和this一直是一件令人头疼的事情，以前接触的不太多，毕竟面向过程编程的我基本上都不会使用“类”这个概念。&lt;/p&gt;
&lt;p&gt;自从开始学习ES6，很长一段时间都认为箭头函数(Arrow Function)&lt;a href=&quot;https://developer.moz
    
    </summary>
    
      <category term="ES6" scheme="http://sabrinaluo.com/tech/categories/ES6/"/>
    
    
      <category term="es6" scheme="http://sabrinaluo.com/tech/tags/es6/"/>
    
      <category term="this" scheme="http://sabrinaluo.com/tech/tags/this/"/>
    
      <category term="作用域" scheme="http://sabrinaluo.com/tech/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
      <category term="箭头函数" scheme="http://sabrinaluo.com/tech/tags/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    
      <category term="词法作用域" scheme="http://sabrinaluo.com/tech/tags/%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>AWS EC2 SSH访问 &amp; mongodb 安装</title>
    <link href="http://sabrinaluo.com/tech/2016/03/14/aws-ec2-ssh-access-mongodb-installation/"/>
    <id>http://sabrinaluo.com/tech/2016/03/14/aws-ec2-ssh-access-mongodb-installation/</id>
    <published>2016-03-14T10:33:31.000Z</published>
    <updated>2016-11-24T10:12:31.646Z</updated>
    
    <content type="html"><![CDATA[<p>环境：Ubuntu</p>
<h3 id="SSH连接-EC2"><a href="#SSH连接-EC2" class="headerlink" title="SSH连接 EC2"></a>SSH连接 EC2</h3><p>windows下通常用putty<br>ubuntu下先打个命令<code>ssh</code>看看能否识别命令，如果能就方便很多</p>
<p>要连接EC2通常都会有一个<code>.pem</code>的<strong>私钥</strong>文件，另外还会有一个<strong>Public IP</strong><br>首先设置权限（并不知道这个有什么用，chmod 400使得文件只能被该文件的拥有者读取）<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod <span class="number">400</span> <span class="comment">/*path*/</span>my-key-pair<span class="class">.pem</span></span><br><span class="line">ssh -<span class="tag">i</span> <span class="comment">/*path*/</span>my-key-pair<span class="class">.pem</span> username@<span class="number">59.64</span>.<span class="number">123.1</span></span><br></pre></td></tr></table></figure></p>
<p>其中username默认如下：<a href="http://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/AccessingInstancesLinux.html" target="_blank" rel="external">^1</a></p>
<table>
<thead>
<tr>
<th style="text-align:right">OS</th>
<th style="text-align:right">username</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">Linux</td>
<td style="text-align:right">ec2-user</td>
</tr>
<tr>
<td style="text-align:right">RHEL5</td>
<td style="text-align:right">root 或 ec2-user</td>
</tr>
<tr>
<td style="text-align:right">Ubuntu</td>
<td style="text-align:right">ubuntu</td>
</tr>
</tbody>
</table>
<h3 id="mongodb安装及配置"><a href="#mongodb安装及配置" class="headerlink" title="mongodb安装及配置"></a>mongodb安装及配置</h3><p>有了apt-get一切真是轻松如放屁…连解压缩都不用！也不用再设置环境变量什么的（根部记不住解压缩的命令…）<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install mongodb</span><br></pre></td></tr></table></figure></p>
<p>安装好了之后，去<strong>根目录</strong>下创建<code>data</code>文件夹即可，然后打<code>mongod</code>命令，应该就启动了，此时访问<code>localhost:27017</code>，如果看到以下文字，就成功启动了芒果DB</p>
<blockquote>
<p>You are trying to access MongoDB on the native driver port. For http diagnostic access, add 1000 to the port number</p>
</blockquote>
<p>如果有error通常是没有data文件夹，设置<code>dbpath</code>后再尝试启动<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod <span class="comment">--dbpath=./path_of _data</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;环境：Ubuntu&lt;/p&gt;
&lt;h3 id=&quot;SSH连接-EC2&quot;&gt;&lt;a href=&quot;#SSH连接-EC2&quot; class=&quot;headerlink&quot; title=&quot;SSH连接 EC2&quot;&gt;&lt;/a&gt;SSH连接 EC2&lt;/h3&gt;&lt;p&gt;windows下通常用putty&lt;br&gt;ubunt
    
    </summary>
    
    
      <category term="AWS" scheme="http://sabrinaluo.com/tech/tags/AWS/"/>
    
      <category term="EC2" scheme="http://sabrinaluo.com/tech/tags/EC2/"/>
    
      <category term="mongodb" scheme="http://sabrinaluo.com/tech/tags/mongodb/"/>
    
      <category term="ssh" scheme="http://sabrinaluo.com/tech/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>AWS API Gateway Mapping Template 获取IP, header等</title>
    <link href="http://sabrinaluo.com/tech/2016/03/07/aws-api-gateway-mapping-templates/"/>
    <id>http://sabrinaluo.com/tech/2016/03/07/aws-api-gateway-mapping-templates/</id>
    <published>2016-03-07T06:33:03.000Z</published>
    <updated>2016-11-24T10:12:31.646Z</updated>
    
    <content type="html"><![CDATA[<p>API Gateway暂时没有详细的中文文档，翻译无能的我实在不知道Mapping Template应该翻译成什么比较好。</p>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>在配合API Gateway和Lambda来搭建RESTful API时，Lambda获取的payload并非通常服务器端获取的一个request对象，lambda获取到的payload并<strong>不包含 request header</strong>的内容，而只有<strong>request body</strong>的内容。</p>
<p>header中的部分内容可以通过API Gateway提供的变量从mapping template中获取。可以获取的内容包括IP, http方法，路由参数，query等，具体可以看文档<a href="http://docs.aws.amazon.com/zh_cn/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html" target="_blank" rel="external">^1</a></p>
<h3 id="设置方法"><a href="#设置方法" class="headerlink" title="设置方法"></a>设置方法</h3><p>按照理论来说，AWS设置可以通过界面设置的都可以通过脚本来设置。下面只介绍在界面中的设置：</p>
<ol>
<li>在API Gateway界面中选中具体的api方法，点击右侧的<strong>Intergration Request</strong></li>
<li>在底部点击<strong>Mapping Templates</strong></li>
<li>点击<strong>Add Mapping Template</strong>，输入<code>application/json</code>，点击√进行确认</li>
<li>在右侧新出现的区域，点击编辑按钮（铅笔图标），输入需要的变量即可，例如要获取ip：<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"body"</span>: <span class="variable">$input</span>.json(<span class="string">'$'</span>),</span><br><span class="line">  <span class="string">"source_ip"</span> : <span class="string">"$context.identity.sourceIp"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>其中<code>$input.json(&#39;$&#39;)</code>是请求时客户端发来的body</p>
<h3 id="response-header和cookie"><a href="#response-header和cookie" class="headerlink" title="response header和cookie"></a>response header和cookie</h3><p>在配合使用lambda和API gateway的时候，header和cookie是非常令人头疼的问题…<br>lambda返回的内容，只是response body，因此设置header要在api gateway中进行，并且也是有一些限制的：</p>
<ol>
<li>在API Gateway界面中选中具体的api方法，点击右侧的<strong>Method Response</strong></li>
<li>展开HTTP Status，点击<strong>Add Header</strong>，添加一个header。<blockquote>
<p><strong>注意</strong>：可以添加多个Header，但这些header不能同名，这也就意味着，只能有一个<code>Set-Cookie</code>，只能添加一个cookie </p>
</blockquote>
</li>
<li>完成以上步骤后，返回第一步所在的页面，点击<strong>Integration Response</strong>，点击三角展开，会看到<strong>Header Mappings</strong></li>
<li>在对应的位置编辑<strong>mapping value</strong><ul>
<li>如果想使用lambda返回的数据，设置为<code>integration.response.body.KEY</code></li>
<li>如果不是使用lambda（即把gateway用作代理），而是使用实际服务器返回的header，设置为<code>integration.response.header.KEY</code></li>
</ul>
</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://docs.aws.amazon.com/zh_cn/apigateway/latest/developerguide/how-to-method-settings-execution-console.html" target="_blank" rel="external">http://docs.aws.amazon.com/zh_cn/apigateway/latest/developerguide/how-to-method-settings-execution-console.html</a></li>
<li><a href="http://docs.aws.amazon.com/zh_cn/apigateway/latest/developerguide/request-response-data-mappings.html" target="_blank" rel="external">http://docs.aws.amazon.com/zh_cn/apigateway/latest/developerguide/request-response-data-mappings.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;API Gateway暂时没有详细的中文文档，翻译无能的我实在不知道Mapping Template应该翻译成什么比较好。&lt;/p&gt;
&lt;h3 id=&quot;适用场景&quot;&gt;&lt;a href=&quot;#适用场景&quot; class=&quot;headerlink&quot; title=&quot;适用场景&quot;&gt;&lt;/a&gt;适用场景&lt;
    
    </summary>
    
    
      <category term="API Gateway" scheme="http://sabrinaluo.com/tech/tags/API-Gateway/"/>
    
      <category term="AWS" scheme="http://sabrinaluo.com/tech/tags/AWS/"/>
    
      <category term="header" scheme="http://sabrinaluo.com/tech/tags/header/"/>
    
      <category term="lambda" scheme="http://sabrinaluo.com/tech/tags/lambda/"/>
    
      <category term="mapping templates" scheme="http://sabrinaluo.com/tech/tags/mapping-templates/"/>
    
  </entry>
  
  <entry>
    <title>Cookie在前端和后端的设置</title>
    <link href="http://sabrinaluo.com/tech/2016/02/29/set-cookie-from-server-side-and-client-side/"/>
    <id>http://sabrinaluo.com/tech/2016/02/29/set-cookie-from-server-side-and-client-side/</id>
    <published>2016-02-29T06:04:57.000Z</published>
    <updated>2016-11-24T10:12:31.646Z</updated>
    
    <content type="html"><![CDATA[<p>http协议什么的，不知道跟通信有没有关系…作为一个通信科班出身的硬<del>汉</del>妹，对各种协议基本上只能说出名字，别的一窍不通=，= 所以当我知道cookie原来是在header里的时候，当时我就震惊了…</p>
<p>在服务器端，各种框架都已经包装好了方便设置cookie的方法，比如nodejs的express，php的codeignitor、laravel（我居然都被迫写过php了，真是逼良为娼…）</p>
<p>为什么要了解设置cookie的原理呢？了解了才能在某些时候用最原始的方法来设置cookie，比如没有框架可用的时候，以及框架提供的方法不适用于某些场景的时候。<br>我是在使用laravel设置cookie的时候踩了坑，现在的项目里因为要配合使用GTM（google tag manager），所以cookie是不加密的raw data，但通过laravel设置的cookie都是加密了的。于是只能学习PHP原生的添加cookie方法。<code>setcookie(NAME, VALUE, EXPIRES)</code></p>
<p>另外就是因为用AWS API Gateway时候的一些需求，想要通过gateway直接设置cookie，这个时候就不得不了解http cookie的运作方式。</p>
<h3 id="response-cookie-从服务器端返回新cookie"><a href="#response-cookie-从服务器端返回新cookie" class="headerlink" title="response cookie 从服务器端返回新cookie"></a>response cookie 从服务器端返回新cookie</h3><p>设置cookie是通过在响应的头部加入<code>Set-Cookie</code>来设置的，</p>
<blockquote>
<ul>
<li>一个请求通常包含header和body</li>
<li>与请求有关的cookie分为request cookie和response cookie<ul>
<li>request cookie是浏览器已储存的cookie</li>
<li>response cookie是服务器端返回的新的cookie，也就是将会储存在浏览器端的新cookie</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="一个完整的cookie-header"><a href="#一个完整的cookie-header" class="headerlink" title="一个完整的cookie header"></a>一个完整的cookie header</h4><p>一个完整的cookie头长这样<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Set</span>-Cookie: NAME=VALUE; expires=<span class="built_in">DATE</span>; <span class="built_in">path</span>=<span class="built_in">PATH</span>; domain=DOMAIN</span><br></pre></td></tr></table></figure></p>
<p>NAME VALUE是一对键值<br>expires是过期日期，通常用当前时间的毫秒数加上一段时间：<code>new Date().getTime()+30*24*60*60*1000)</code>，然后<strong>需要调用<code>toUTCString()</code>方法</strong><br>如果不设置expires，在浏览器中这个cookie将被当做session对待，也就是关闭了浏览器cookie就消失<br>path和domain这个…感觉不太用得到，具体可以看<a href="http://blog.sina.com.cn/s/blog_70c4d9410100z3il.html" target="_blank" rel="external">这篇文章</a></p>
<p>如果要同时设置多个cookie，同时返回多个<code>Set-Cookie</code>头即可</p>
<h4 id="maxAge"><a href="#maxAge" class="headerlink" title="maxAge"></a>maxAge</h4><p>有一些服务器端的框架会提供maxAge属性来设置cookie的过期时间，但是原始的Set-Cookie头是不支持maxAge的，所以在通过头部来设置cookie还是乖乖用回expires吧</p>
<h3 id="浏览器端读取cookie"><a href="#浏览器端读取cookie" class="headerlink" title="浏览器端读取cookie"></a>浏览器端读取cookie</h3><p>JS原生方法：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cookies = <span class="built_in">document</span>.cookie;</span><br></pre></td></tr></table></figure></p>
<p>读取的cookie是一个分号分隔的包含所有cookie键值字符串，可以通过正则表达式来提取需要的cookie<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cookieA = <span class="built_in">document</span>.cookie.replace(<span class="regexp">/(?:(?:^|.*;\s*)cookieA\s*\=\s*([^;]*).*$)|^.*$/</span>, <span class="string">"$1"</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="request-cookie-浏览器端设置cookie"><a href="#request-cookie-浏览器端设置cookie" class="headerlink" title="request cookie 浏览器端设置cookie"></a>request cookie 浏览器端设置cookie</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'cookie_example=123'</span>+<span class="string">';expires='</span>+expire+<span class="string">';path=/'</span>;</span><br></pre></td></tr></table></figure>
<p>如果要设置多个cookie，多次调用<code>document.cookie</code>即可</p>
<h4 id="document-cookie"><a href="#document-cookie" class="headerlink" title="document.cookie"></a>document.cookie</h4><p>这个document的behavior有点奇怪，明明返回的是个字符串，本来以为每次设置cookie得用新的字符串连接旧的字符串，但其实直接等于新的值也并不会覆盖旧的值，不知道实现这个属性&amp;方法混用的原理是什么0,0</p>
<p>####NOTE<br>通常设置cookie的时候都会把path设置为<code>/</code>，这样同一个域名下，所有路径都共用一个cookie<br>如果没有设置path，某些框架可能默认会使用创建cookie时的路径作为path，这样就可能存在多个path不同的同名cookie。</p>
<p>####工具</p>
<ul>
<li>在浏览器端，可以使用chrome的扩展<em>EditThisCookie</em>来查看和编辑cookie</li>
<li>如果是从服务器端写入的cookie，可以在F12 network 选项卡中选中请求，有cookie的时候会有一个cookie选项，能看到request cookie和response cookie</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;http协议什么的，不知道跟通信有没有关系…作为一个通信科班出身的硬&lt;del&gt;汉&lt;/del&gt;妹，对各种协议基本上只能说出名字，别的一窍不通=，= 所以当我知道cookie原来是在header里的时候，当时我就震惊了…&lt;/p&gt;
&lt;p&gt;在服务器端，各种框架都已经包装好了方便设置
    
    </summary>
    
    
      <category term="cookie" scheme="http://sabrinaluo.com/tech/tags/cookie/"/>
    
  </entry>
  
  <entry>
    <title>jQuery中利用JSONP进行跨域GET请求</title>
    <link href="http://sabrinaluo.com/tech/2016/02/17/using-jQuery-to-handle-CORS-with-jsonp/"/>
    <id>http://sabrinaluo.com/tech/2016/02/17/using-jQuery-to-handle-CORS-with-jsonp/</id>
    <published>2016-02-17T04:31:55.000Z</published>
    <updated>2016-11-24T10:12:31.646Z</updated>
    
    <content type="html"><![CDATA[<p>每次遇到跨域的问题真是！@#￥%</p>
<p>我对<code>JSONP</code>的一些浅显的理解就是，有时候会看到类似<code>http://xxx.xx.com/?callback=xxx</code>这样的请求（<code>callback=</code>也可能是<code>jsonp=</code>也可能是<code>jsonpcallback=</code>，这个取决于服务器端是怎么实现jsonp的），这样的请求做的事情简单的来说就是等得到所有数据之后就执行回调函数。</p>
<p>由于这个回调函数已经发给了服务器，返回的结果其实是一个函数，函数的入参是获取的数据。</p>
<p>jQuery的ajax请求其实能很简单的在客户端进行跨域GET请求，具体如下：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  url: 'http://xx.xx.com/xxx',</span><br><span class="line">  <span class="keyword">method</span>: '<span class="type">GET</span>',</span><br><span class="line">  dataType: 'jsonp',</span><br><span class="line">  //jsonp: 'callback',</span><br><span class="line">  success: function(data)&#123;</span><br><span class="line">    //<span class="keyword">do</span> something here;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$.ajax(options);</span><br></pre></td></tr></table></figure></p>
<p>其中需要注意的是，一定要声明<strong><code>dataType</code></strong>，然后把回调函数写在success后面就可以了。<br>另外一开始提到，服务器端对jsonp的实现可能不同，所以在<code>options</code>中，有时候需要声明<code>jsonp</code>对应的字符串，默认是<code>&quot;callback&quot;</code>。例如：如果服务器实现jsonp是通过<code>http://xxx.xx.com/?jsonpcallback=xxx</code>，那么就需要在<code>options</code>中声明<code>jsonp:&#39;jsonpcallback&#39;</code></p>
<p>原理据说和<code>&lt;script src=&quot;...&quot;&gt;</code>差不多，我现在还不是很明白=，=</p>
<p>参考<br><a href="http://www.runoob.com/json/json-jsonp.html" target="_blank" rel="external">http://www.runoob.com/json/json-jsonp.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每次遇到跨域的问题真是！@#￥%&lt;/p&gt;
&lt;p&gt;我对&lt;code&gt;JSONP&lt;/code&gt;的一些浅显的理解就是，有时候会看到类似&lt;code&gt;http://xxx.xx.com/?callback=xxx&lt;/code&gt;这样的请求（&lt;code&gt;callback=&lt;/code&gt;也可
    
    </summary>
    
    
      <category term="CORS" scheme="http://sabrinaluo.com/tech/tags/CORS/"/>
    
      <category term="JSONP" scheme="http://sabrinaluo.com/tech/tags/JSONP/"/>
    
      <category term="jQuery" scheme="http://sabrinaluo.com/tech/tags/jQuery/"/>
    
      <category term="跨域" scheme="http://sabrinaluo.com/tech/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>谷歌地图 Google Map API 初体验</title>
    <link href="http://sabrinaluo.com/tech/2016/02/03/experiencing-google-map-js-api/"/>
    <id>http://sabrinaluo.com/tech/2016/02/03/experiencing-google-map-js-api/</id>
    <published>2016-02-03T10:32:51.000Z</published>
    <updated>2016-11-24T10:12:31.646Z</updated>
    
    <content type="html"><![CDATA[<p>一直都想把自己去过的地方做个地图标记，然而现在能找到的各种现成的地图产品都不太喜欢，所以就用谷歌地图自己写了一个。<br>总结以下常见的问题和坑：</p>
<h3 id="自动缩放-auto-zoom"><a href="#自动缩放-auto-zoom" class="headerlink" title="自动缩放(auto zoom)"></a>自动缩放(auto zoom)</h3><p>使用场景大多数时候是有很多marker，想要全部显示这些marker，同时zoom当然越大越清晰。</p>
<ul>
<li>首先需要一个marker的位置列表 <code>markerList</code>，单个元素长这样<code>{lat:xxx,lng:xxx}</code></li>
<li>遍历列表，把元素传入<code>google.maps.LatLngBounds</code>实例的<code>extend</code>方法<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> latlngbounds = <span class="keyword">new</span> google.maps.LatLngBounds();</span><br><span class="line">markerList.<span class="keyword">forEach</span>(<span class="function"><span class="keyword">function</span> <span class="params">(item)</span> </span>&#123;</span><br><span class="line">  latlngbounds.extend(item);</span><br><span class="line">&#125;);</span><br><span class="line">map.fitBounds(latlngbounds);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>然而这有一个很多人提到的问题，就是缩放效果不平滑。(smooth这个词，我还是百度了smooth scroll才写的出字面意思来，我现在中文是有多差…)<br>这个暂时没什么解决方法，API本身就是这样的。据说谷歌本身的地图是h5的canvas绘制的，但通过API生成的地图不是同样的原理…谷歌居然自己都不用自己的API …</p>
<p>另一个问题是，缩放<strong>太大力</strong>怎么办？答案是，在<code>MapOptions</code>中设置<code>maxZoom</code>值</p>
<h3 id="动画效果切换"><a href="#动画效果切换" class="headerlink" title="动画效果切换"></a>动画效果切换</h3><p>API提供三种效果：<code>BOUNCE</code> <code>DROP</code> <code>NULL</code><br>使用场景大多数时候是在NULL和BOUNCE之间切换</p>
<p>动画比较坑爹的是，每个动画都要持续700ms，之后才能改变状态。</p>
<p>比如这样一个例子：有两组marker，<strong>有交集</strong>。想要让第一组先BOUNCE，之后停止第一组，让第二组BOUNCE。很容易想到的方法是，通过遍历，把第一组的动画全部设置为NULL，再把第二组动画全部设置为BOUNCE。然而交集的这一部分只会BOUNCE一次然后就停了…因为计算速度很快，从NULL到BOUNCE不到700ms，动画其实还处于NULL状态。</p>
<p>可以参考官方的这个例子，<a href="https://developers.google.com/maps/documentation/javascript/examples/marker-animations" target="_blank" rel="external">https://developers.google.com/maps/documentation/javascript/examples/marker-animations</a> ，当你双击marker的时候，其实就是模拟了快速切换状态，但动画效果并不如预期…</p>
<p>解决方案：求差集，也就是把交集的部分去掉，在设置动画为NULL</p>
<h3 id="自定义地图样式"><a href="#自定义地图样式" class="headerlink" title="自定义地图样式"></a>自定义地图样式</h3><p><a href="https://snazzymaps.com/" target="_blank" rel="external">https://snazzymaps.com/</a> 这个网站有很多已经设计好的样式，选喜欢的直接复制代码放到<code>StyledMapType()</code>方法中即可，然后给这个样式取个名字，下例中我使用了<a href="https://snazzymaps.com/style/134/light-dream" target="_blank" rel="external">light dream</a> 这个样式<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mapStyle = <span class="built_in">new</span> google.maps.StyledMapType([....])</span><br><span class="line"><span class="keyword">map</span>.mapTypes.set(<span class="string">'lightDream'</span>, mapStyle);</span><br><span class="line"><span class="keyword">map</span>.setMapTypeId(<span class="string">'lightDream'</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="遍历添加-event-listener-同时又需要传参数给-google-maps-event-addListener-的回调函数"><a href="#遍历添加-event-listener-同时又需要传参数给-google-maps-event-addListener-的回调函数" class="headerlink" title="遍历添加 event listener 同时又需要传参数给 google.maps.event.addListener() 的回调函数"></a>遍历添加 event listener 同时又需要传参数给 <code>google.maps.event.addListener()</code> 的回调函数</h3><p>不太理解event.addListener的工作原理，但根据我踩的坑推测这是一个异步的方法（否则为什么有回调函数？！）</p>
<p>这个时候就要用到高大上的<strong>闭包</strong>。下面这个例子中，如果不把<code>addListener</code>包起来，每次cityHandler收到的city都是遍历的最后一个city。因为遍历速度太快，而回调还没有执行，等回调执行的时候city已经遍历到最后一个了…</p>
<p>不用闭包的话，用promise应该也能解决这个问题，但是感觉promise需要写的code会比较多一些。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cityList=[&#123;marker:googleMapMarker,city:<span class="string">'Beijing'</span>&#125;,...];</span><br><span class="line">cityList.<span class="keyword">forEach</span>(<span class="function"><span class="keyword">function</span><span class="params">(item)</span></span>&#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> <span class="params">(marker, city)</span> </span>&#123;</span><br><span class="line">    google.maps.event.addListener(marker, <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(e)</span> </span>&#123;</span><br><span class="line">      cityHandler(city);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)(item.marker, item.city)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="原生marker图标"><a href="#原生marker图标" class="headerlink" title="原生marker图标"></a>原生marker图标</h3><p><a href="http://mabp.kiev.ua/2010/01/12/google-map-markers/" target="_blank" rel="external">http://mabp.kiev.ua/2010/01/12/google-map-markers/</a></p>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="https://developers.google.com/maps/documentation/javascript/reference" target="_blank" rel="external">https://developers.google.com/maps/documentation/javascript/reference</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直都想把自己去过的地方做个地图标记，然而现在能找到的各种现成的地图产品都不太喜欢，所以就用谷歌地图自己写了一个。&lt;br&gt;总结以下常见的问题和坑：&lt;/p&gt;
&lt;h3 id=&quot;自动缩放-auto-zoom&quot;&gt;&lt;a href=&quot;#自动缩放-auto-zoom&quot; class=&quot;he
    
    </summary>
    
    
      <category term="Google Map" scheme="http://sabrinaluo.com/tech/tags/Google-Map/"/>
    
      <category term="Google Map API" scheme="http://sabrinaluo.com/tech/tags/Google-Map-API/"/>
    
      <category term="谷歌地图" scheme="http://sabrinaluo.com/tech/tags/%E8%B0%B7%E6%AD%8C%E5%9C%B0%E5%9B%BE/"/>
    
      <category term="谷歌地图API" scheme="http://sabrinaluo.com/tech/tags/%E8%B0%B7%E6%AD%8C%E5%9C%B0%E5%9B%BEAPI/"/>
    
  </entry>
  
  <entry>
    <title>git如何ignore已经track的文件</title>
    <link href="http://sabrinaluo.com/tech/2016/02/01/git-how-to-ignore-tracked-files/"/>
    <id>http://sabrinaluo.com/tech/2016/02/01/git-how-to-ignore-tracked-files/</id>
    <published>2016-02-01T06:01:03.000Z</published>
    <updated>2016-11-24T10:12:31.646Z</updated>
    
    <content type="html"><![CDATA[<p>我也不想中英文混杂的取标题……但我实在翻译无能…_(:з」∠)_</p>
<h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><p>在git中文件有两类，共三种状态：</p>
<ul>
<li>untracked</li>
<li>tracked<ul>
<li>changes not staged for commit</li>
<li>changes to be committed<br>我们都知道，在<code>.gitignore</code>文件里添加相应的文件夹或文件就能忽略掉不想被track的文件。<br>但是，<code>.gitignore</code>文件只能忽略<strong>Untracked files</strong>。</li>
</ul>
</li>
</ul>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>参考这样一个例子：<br>一个项目因为一些莫名其妙的原因对<code>node_modules</code>文件夹进行了track，然后每次check out出来<code>npm install</code>的时候，很可能这些依赖包就更新了，然后又因为一些莫名其妙的原因，始终没有人把这个文件夹移出git的index，于是你也不好意思删除这个文件夹做一次commit。然而，每次都有几十上百条<code>modified: node_modules/xxx</code>，根本找不到自己真正修改和添加的文件…</p>
<p>于是问题来了，怎么样才能把<code>node_module</code> ignore，但又不commit这些change呢？</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>正常情况，跑以下的命令就能忽略掉已经track的<strong>文件夹</strong>：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">ls</span>-<span class="keyword">files</span> -<span class="keyword">z</span> node_modules/ | xargs -<span class="number">0</span> git <span class="keyword">update</span>-<span class="built_in">index</span> --assume-unchanged</span><br></pre></td></tr></table></figure></p>
<p>如果只需要忽略<strong>单个文件</strong>，则以下命令就能搞定。<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git update-<span class="built_in">index</span> --assume-unchanged &lt;<span class="keyword">file</span> <span class="keyword">name</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>因为update-index不支持递归<code>-r</code>，所以只能通过上面提到的方法来实现忽略文件夹<br>（憋问我为什么不支持…我也不知道）</p>
<h3 id="另一种情况：将tracked文件移出index，但仍然保留在本地"><a href="#另一种情况：将tracked文件移出index，但仍然保留在本地" class="headerlink" title="另一种情况：将tracked文件移出index，但仍然保留在本地"></a>另一种情况：将tracked文件移出index，但仍然保留在本地</h3><p>终于有一天，大家想通了，决定将<code>node_modules</code>文件夹移出git index，但是如果删除了整个文件夹commit之后，项目要跑起来，又要重新<code>npm install</code>，懒癌患者倒地不起…</p>
<p>下面这个命令可以解决上述问题：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm <span class="comment">--cached -r node_modules</span></span><br></pre></td></tr></table></figure></p>
<h3 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h3><p>我反正是无法理解把诸如npm包，bower包，composer包等等等的第三方依赖放到git里去track，那么还要package.json干啥=，=</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我也不想中英文混杂的取标题……但我实在翻译无能…_(:з」∠)_&lt;/p&gt;
&lt;h3 id=&quot;基本知识&quot;&gt;&lt;a href=&quot;#基本知识&quot; class=&quot;headerlink&quot; title=&quot;基本知识&quot;&gt;&lt;/a&gt;基本知识&lt;/h3&gt;&lt;p&gt;在git中文件有两类，共三种状态：&lt;/p&gt;

    
    </summary>
    
    
      <category term="git" scheme="http://sabrinaluo.com/tech/tags/git/"/>
    
      <category term="gitignore" scheme="http://sabrinaluo.com/tech/tags/gitignore/"/>
    
      <category term="update index" scheme="http://sabrinaluo.com/tech/tags/update-index/"/>
    
  </entry>
  
  <entry>
    <title>Promise的顺序执行和并行执行</title>
    <link href="http://sabrinaluo.com/tech/2016/01/23/excecute-parallel-promise-and-sequential-promise/"/>
    <id>http://sabrinaluo.com/tech/2016/01/23/excecute-parallel-promise-and-sequential-promise/</id>
    <published>2016-01-23T14:52:26.000Z</published>
    <updated>2016-11-24T10:12:31.646Z</updated>
    
    <content type="html"><![CDATA[<p>并行和顺序执行的前提当然是，有一堆promise等着你去执行……<br>通常我们把这“一堆”promise对象放到一个数组里，<code>[promise1, promise2, promise3, ...]</code></p>
<p>我们都知道想要让promise按顺序执行，那就是一个接一个的then。然而手写很多then太累了，而嵌套的promise又是反模式，我之前蠢蠢的<a href="tech/2016/01/18/sequentialize-promise-by-recursion/">用递归解决了顺序执行的问题</a>，后来终于在udacity习得了顺序promise的正确打开方式！</p>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>假如我们要去拿github按关键字搜索google, amazon, facebook，每个关键字搜出的第一个用户的第一个repo的名字。<br>单独拿一个，比如google，过程是这样的：</p>
<ol>
<li>请求<a href="https://api.github.com/search/users?q=google" target="_blank" rel="external">https://api.github.com/search/users?q=google</a> ，得到用户列表，读取第一个用户的repos_url</li>
<li>请求上一步读取的repous_url，获得repo列表，读取第一个repo的名字<br>显然，第二步是依赖于第一步的执行结果的。</li>
</ol>
<p>因此，很容易想到下面几种情况：</p>
<ol>
<li><p>等第一步全部执行完，再执行第二步（并行执行）</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string">--------------------</span>|</span><br><span class="line">google第一步          |<span class="string">------------------</span>|</span><br><span class="line">amazon第一步        google第二步</span><br><span class="line">facebook第一步      amazon第二步 </span><br><span class="line">                   facebook第二步</span><br></pre></td></tr></table></figure>
</li>
<li><p>对第一步的顺序有要求，必须严格按照google, amazon, facebook的顺序执行（顺序执行）</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string">---------</span>|</span><br><span class="line">google1   |<span class="string">---------</span>|</span><br><span class="line">            google2 |<span class="string">---------</span>|</span><br><span class="line">                     amazon1  |<span class="string">---------</span>|</span><br><span class="line">                              amazon2   |<span class="string">---------</span>|</span><br><span class="line">                                        facebook1 |<span class="string">--------</span>|</span><br><span class="line">                                                  facebook2</span><br></pre></td></tr></table></figure>
</li>
<li><p>google1执行完就执行google1，amazon1执行完就执行amazon2，但对google, amazon, facebook的顺序没有要求</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string">------------------</span>|</span><br><span class="line">google1            |<span class="string">-------------</span>|</span><br><span class="line">                   google2</span><br><span class="line">|<span class="string">---------</span>|</span><br><span class="line">amazon1   |<span class="string">-----------</span>|</span><br><span class="line">          amazon2</span><br><span class="line">|<span class="string">------------</span>|</span><br><span class="line">facebook1    |<span class="string">-------------</span>|<span class="string">  </span><br><span class="line">             facebook2</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Promise并行执行"><a href="#Promise并行执行" class="headerlink" title="Promise并行执行"></a>Promise并行执行</h3><p>对于场景1，主要就是用到<code>Promise.all</code>，因为是数组，所以在处理的过程中通常会用到<code>.map</code>或<code>.forEach</code><br><iframe width="100%" height="300" src="http://jsfiddle.net/HiiTea/zfjvr4pz/1/embedded/js,resources,html,css,result/light" frameborder="0" allowfullscreen></iframe><br><img src="http://7xow88.com1.z0.glb.clouddn.com/tech-promise1.png" alt="promise例1网络请求时间线"><br>可以看到3个user请求是同时进行（并行），3个repos请求也是同时进行（并行），由于使用了<code>Promise.all</code>，所以repos请求等待users请求全部完成才开始。</p>
<h3 id="promise顺序执行的正确打开方式"><a href="#promise顺序执行的正确打开方式" class="headerlink" title="promise顺序执行的正确打开方式"></a>promise顺序执行的正确打开方式</h3><p>对于场景2，有一个小技巧，我第一次看到的时候感受是…惊为天人<br>按照顺序执行，容易想到的有以下几种方法：</p>
<ol>
<li>then.then.then，从头then到尾…</li>
<li>then(then(then()))，then的嵌套…</li>
</ol>
<p>promise链的本质其实就是从头then到尾，但是第一种方法怎么用程序来实现，也就是上面提到的小技巧，就是值得学习的地方了。（反正我觉得太巧妙了！！！我自己就想不到…）</p>
<p>大概跟在做求和运算时候的思想一样：<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//求和的时候通常这么做，先定义一个<span class="built_in">sum</span>，然后依次往里做加法</span><br><span class="line">var <span class="built_in">sum</span> = <span class="number">0</span>;</span><br><span class="line">array.forEach(<span class="function"><span class="keyword">function</span><span class="params">(item)</span></span> &#123;</span><br><span class="line">  <span class="built_in">sum</span> = <span class="built_in">sum</span> + item;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//要得到一个<span class="keyword">then</span> <span class="keyword">then</span> <span class="keyword">then</span>的promise链，先定义一个已经resolve了的promise，然后依次往后<span class="keyword">then</span>…</span><br><span class="line">var <span class="keyword">sequence</span> = Promise.resolve();</span><br><span class="line">array.forEach(<span class="function"><span class="keyword">function</span><span class="params">(item)</span></span> &#123;</span><br><span class="line">  <span class="keyword">sequence</span> = <span class="keyword">sequence</span>.<span class="keyword">then</span>(...)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>下面给出场景2的代码：<br><iframe width="100%" height="300" src="http://jsfiddle.net/HiiTea/sq2aga08/embedded/js,resources,html,css,result/light" frameborder="0" allowfullscreen></iframe><br><img src="http://7xow88.com1.z0.glb.clouddn.com/tech-promise2.png" alt="promise例2网络请求时间线"><br>可以看到请求是按顺序依次发出</p>
<h3 id="并行执行和顺序执行混用"><a href="#并行执行和顺序执行混用" class="headerlink" title="并行执行和顺序执行混用"></a>并行执行和顺序执行混用</h3><p>场景3:<br><iframe width="100%" height="300" src="http://jsfiddle.net/HiiTea/z09xjowq/1/embedded/js,resources,html,css,result/light" frameborder="0" allowfullscreen></iframe><br><img src="http://7xow88.com1.z0.glb.clouddn.com/tech-promise3.png" alt="promise例3网络请求时间线"><br>可以看到users请求是并行发出，但完成时间不一样，而repos请求是在<strong>对应的</strong>users请求完成后就立即执行</p>
<h3 id="混用的另一种情况"><a href="#混用的另一种情况" class="headerlink" title="混用的另一种情况"></a>混用的另一种情况</h3><p>有了以上的知识，很容易写出最后一种混用的情况，users按顺序执行，等users全部执行完之后并发执行repos。我比较懒…这个我就不写了…</p>
<h3 id="补充知识："><a href="#补充知识：" class="headerlink" title="补充知识："></a>补充知识：</h3><h4 id="浏览器的fetch-API"><a href="#浏览器的fetch-API" class="headerlink" title="浏览器的fetch API"></a>浏览器的fetch API</h4><p>本文跟fetch不是充分必要关系，只是我太懒了不想写太多的代码来举例。你可以把它理解为是用Promise包住的<code>$.ajax</code>，也就是fetch返回一个promise对象。关于fetch的详细用法请参考<a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" target="_blank" rel="external">MDN Fetch_ API</a></p>
<h4 id="如何查看请求的发送是并行还是顺序"><a href="#如何查看请求的发送是并行还是顺序" class="headerlink" title="如何查看请求的发送是并行还是顺序"></a>如何查看请求的发送是并行还是顺序</h4><p>打开chrome，按F12，选中Network选项卡，在No throttling这个下拉列表选GPRS，再运行代码，然后就能清楚的看到各个请求的时间线了。</p>
<p>如果看到的区别不是很明显，很可能是已经缓存了，清空浏览器的缓存在重复上面的步骤就能看到比较明显的区别了。</p>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p>[1] <a href="https://www.udacity.com/course/viewer#!/c-ud898" target="_blank" rel="external">https://www.udacity.com/course/viewer#!/c-ud898</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;并行和顺序执行的前提当然是，有一堆promise等着你去执行……&lt;br&gt;通常我们把这“一堆”promise对象放到一个数组里，&lt;code&gt;[promise1, promise2, promise3, ...]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们都知道想要让promise按顺序
    
    </summary>
    
    
      <category term="Promise" scheme="http://sabrinaluo.com/tech/tags/Promise/"/>
    
      <category term="parallel" scheme="http://sabrinaluo.com/tech/tags/parallel/"/>
    
      <category term="sequential" scheme="http://sabrinaluo.com/tech/tags/sequential/"/>
    
      <category term="顺序执行，并行执行" scheme="http://sabrinaluo.com/tech/tags/%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%EF%BC%8C%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>对浏览器跨域问题的一些理解</title>
    <link href="http://sabrinaluo.com/tech/2016/01/22/understanding-of-CORS/"/>
    <id>http://sabrinaluo.com/tech/2016/01/22/understanding-of-CORS/</id>
    <published>2016-01-22T07:08:33.000Z</published>
    <updated>2016-11-24T10:12:31.646Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题宝宝"><a href="#问题宝宝" class="headerlink" title="问题宝宝"></a>问题宝宝</h3><h4 id="1-移动应用开发"><a href="#1-移动应用开发" class="headerlink" title="1 移动应用开发"></a>1 移动应用开发</h4><p>之前用Ionic写mobile app，移动app自然是少不了调用RESTful API的数据。<br>开发的时候用浏览器进行调试，然后console里不停的出现下面的提示(<strong>Access-Control-Allow-Origin</strong>)：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XMLHttpRequest cannot <span class="operator"><span class="keyword">load</span> <span class="keyword">http</span>://samlino.<span class="keyword">local</span>/cag/get_leads. <span class="keyword">No</span> <span class="string">'Access-Control-Allow-Origin'</span> header <span class="keyword">is</span> <span class="keyword">present</span> <span class="keyword">on</span> the requested <span class="keyword">resource</span>. Origin <span class="string">'http://localhost:63342'</span> <span class="keyword">is</span> therefore <span class="keyword">not</span> allowed <span class="keyword">access</span>.</span></span><br></pre></td></tr></table></figure></p>
<p>而我当时的解决方法是，在chrome装了一个叫<a href="https://chrome.google.com/webstore/detail/allow-control-allow-origi/nlfbmbojpeacfghkpbjhddihlkkiljbi" target="_blank" rel="external">Allow-Control-Allow-Origin</a>的扩展，启用之后就不报错了。</p>
<p>也不知道什么什么原理，反正就这么一直用着。（不思进取）</p>
<h4 id="2-网络应用开发"><a href="#2-网络应用开发" class="headerlink" title="2 网络应用开发"></a>2 网络应用开发</h4><p>后来写单页应用（SPA），静态文件的js里调用各大公司的API， github、facebook什么的，反正从来没有报过上面的错…<br>另外还写过用NodeJS做中间层，从NodeJS去API拿数据然后渲染再发到前端，也从来没报过错…</p>
<p>最近的一个case是，我们有用AWS API Gateway, Lambda, DynamoDB搭建的API，API被调用的时候就会trigger一系列的任务。然后有个小哥偷懒不想写PHP，想在前端直接请求AWS的API。于是问题来了…</p>
<ul>
<li>浏览器不停的提示No ‘Access-Control-Allow-Origin’的错误， 拿不到任何返回的数据。</li>
<li>但是！服务器该做的job却都做了！</li>
</ul>
<p>这根本不科学啊！！！所以？到底是什么鬼？！</p>
<h3 id="同源策略-Same-Origin-Policy"><a href="#同源策略-Same-Origin-Policy" class="headerlink" title="同源策略(Same Origin Policy)"></a>同源策略(Same Origin Policy)</h3><p>同源策略就是只有访问的内容来自<strong>相同协议、相同主机、相同端口</strong>的内容<a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy" target="_blank" rel="external">^1</a>时，才会加载访问得到的内容。<strong>浏览器是同源策略的一种实现</strong></p>
<ul>
<li>协议：<code>location.protocol</code>，http和https是两种不同的协议</li>
<li>主机：<code>location.host</code>，不同子域名之间都算跨域，例如www.baidu.com, tieba.baidu.com是两个不同的源</li>
<li>端口：<code>location.port</code></li>
</ul>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>之前脑子里大概有个<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="external">CORS</a>的概念，然后一直以为是服务器拒绝从浏览器跨域访问…因为要解决自己call自己不同域名下的API问题，就是去服务器设置一下header…但其实是都是浏览器在作怪…</p>
<p>在浏览器中，允许跨域访问的资源的一些例子<a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy#Cross-origin_network_access" target="_blank" rel="external">^2</a>：<br><code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code><br><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;...&quot;&gt;</code><br><code>&lt;img&gt;</code> <code>&lt;video&gt;</code> <code>&lt;audio&gt;</code><br><code>&lt;object&gt;</code> <code>&lt;embed&gt;</code> <code>&lt;applet&gt;</code><br><code>@font-face</code><br><code>&lt;frame&gt;</code> <code>&lt;iframe&gt;</code></p>
<h3 id="Response-Headers"><a href="#Response-Headers" class="headerlink" title="Response Headers"></a>Response Headers</h3><p>先看看可以在浏览器中跨域请求的别人家(github)的API返回的header：<br><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Credentials:true</span><br><span class="line">Access-Control-Allow-Origin:*</span><br><span class="line">Access-Control-Expose-Headers:ETag, Link, <span class="keyword">X</span>-GitHub-OTP, <span class="keyword">X</span>-RateLimit-Limit, <span class="keyword">X</span>-RateLimit-Remaining, <span class="keyword">X</span>-RateLimit-Reset, <span class="keyword">X</span>-OAuth-Scopes, <span class="keyword">X</span>-Accepted-OAuth-Scopes, <span class="keyword">X</span>-Poll-Interval</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>看看自家API返回的header<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">Connection</span><span class="symbol">:keep-alive</span></span><br><span class="line"><span class="constant">Content</span>-<span class="constant">Encoding</span><span class="symbol">:gzip</span></span><br><span class="line"><span class="constant">Content</span>-<span class="constant">Type</span><span class="symbol">:text/html</span></span><br><span class="line"><span class="constant">Date</span><span class="symbol">:Fri</span>, <span class="number">22</span> <span class="constant">Jan</span> <span class="number">2016</span> <span class="number">07</span><span class="symbol">:</span><span class="number">07</span><span class="symbol">:</span><span class="number">01</span> <span class="constant">GMT</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>差别就在于别人家的API返回了<strong>Access-Control-Allow-Origin:*</strong><br>浏览器读到这个头部之后，才会加载请求的结果。</p>
<h3 id="跨域的时候服务器收到请求了吗？"><a href="#跨域的时候服务器收到请求了吗？" class="headerlink" title="跨域的时候服务器收到请求了吗？"></a>跨域的时候服务器收到请求了吗？</h3><p>服务器当然收到请求了，不然怎么能返回头部…而且我上面举的诡异的例子中，请求trigger的job都完成了。</p>
<p>所以也就是说，服务器其实收到了你的请求，并且给你返回了全部的数据，但是浏览器看到头部就把body藏起来了，然后抛出错误提示…</p>
<h3 id="为什么浏览器不允许跨域访问？"><a href="#为什么浏览器不允许跨域访问？" class="headerlink" title="为什么浏览器不允许跨域访问？"></a>为什么浏览器不允许跨域访问？</h3><p>当然是为了安全……但是这个有点不太好理解，api拿点数据有什么不安全的？！</p>
<p>下面这个例子比较清楚的说明同源策略是如何避免安全问题的：<a href="http://stackoverflow.com/questions/9222822/why-do-browser-apis-restrict-cross-domain-requests" target="_blank" rel="external">^3</a><br>网站A：一个看起来跟银行网站几乎一样的假网站<br>网站B：真正的银行网站<br>如果没有同源策略：<br>1.当用户来到A网站，以为是真的银行网站，然后输入自己的账号、密码（此时用户的账号、密码已经被网站A获取了）<br>2.网站A利用ajax把账号密码发到真正的银行网站B，然后银行网站返回一个带有token的form需要用户输入手机验证码。<br>3.网站A获得这个form之后显示出来，让用户填入手机验证码……至此，网站A获得了账号、密码、手机验证码，已经可以登陆用户的账号了。</p>
<p>而当有同源策略时，到第2步的时候，网站A根本无法获取银行网站返回的带token的form，所以就算有了账户和密码，也无法操作用户的账户。</p>
<p>当然啦，银行的加密机制肯定没有我描述的这么弱智，不然还要U盾之类的东东干嘛，这只是一个为了方便理解安全问题而杜撰的例子…</p>
<h3 id="好奇宝宝"><a href="#好奇宝宝" class="headerlink" title="好奇宝宝"></a>好奇宝宝</h3><p>不知道chrome的这个插件<a href="https://chrome.google.com/webstore/detail/allow-control-allow-origi/nlfbmbojpeacfghkpbjhddihlkkiljbi" target="_blank" rel="external">Allow-Control-Allow-Origin</a>，是怎么实现允许跨域请求的。<br>之前发现启用插件的时候，github上的小图标全都不显示了…</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题宝宝&quot;&gt;&lt;a href=&quot;#问题宝宝&quot; class=&quot;headerlink&quot; title=&quot;问题宝宝&quot;&gt;&lt;/a&gt;问题宝宝&lt;/h3&gt;&lt;h4 id=&quot;1-移动应用开发&quot;&gt;&lt;a href=&quot;#1-移动应用开发&quot; class=&quot;headerlink&quot; title=&quot;1
    
    </summary>
    
    
      <category term="CORS" scheme="http://sabrinaluo.com/tech/tags/CORS/"/>
    
      <category term="corss domain" scheme="http://sabrinaluo.com/tech/tags/corss-domain/"/>
    
      <category term="同源策略" scheme="http://sabrinaluo.com/tech/tags/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"/>
    
      <category term="浏览器" scheme="http://sabrinaluo.com/tech/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="跨域" scheme="http://sabrinaluo.com/tech/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>递归实现按顺序执行Promise</title>
    <link href="http://sabrinaluo.com/tech/2016/01/18/sequentialize-promise-by-recursion/"/>
    <id>http://sabrinaluo.com/tech/2016/01/18/sequentialize-promise-by-recursion/</id>
    <published>2016-01-18T09:23:18.000Z</published>
    <updated>2016-11-24T10:12:31.650Z</updated>
    
    <content type="html"><![CDATA[<p><strong>2016-01-24更新</strong><br>我还是觉得嵌套多层的promise是反模式，不推荐使用，机智的我学会了另一种不嵌套不递归的方法，请看这里：<br>(Promise的顺序执行和并行执行](tech/2016/01/23/excecute-parallel-promise-and-sequential-promise)</p>
<p><strong>以下为原文：</strong></p>
<p>之前我一直有个疑问，当我有一堆promise的时候，怎么按顺序执行它们呢？</p>
<p>网上搜到的大多数教程都是建一个数组<code>array</code>，把promise对象放到数组里，然后数组中的promise全部执行完毕时调用<code>Promise.all(array)</code>。然而这只适用于数组中的<strong>promise对象不互相依赖</strong>的情况。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>我之前提到过一个典型的例子是Facebook的Graph API 中的分页问题（ <a href="https://developers.facebook.com/docs/graph-api/using-graph-api#paging" target="_blank" rel="external">Cursor-based Pagination</a>），API的Response如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">data</span>": <span class="value">[</span><br><span class="line">     ... Endpoint data is here</span><br><span class="line">  ]</span>,</span><br><span class="line">  "<span class="attribute">paging</span>": <span class="value">&#123;</span><br><span class="line">    "<span class="attribute">cursors</span>": <span class="value">&#123;</span><br><span class="line">      "<span class="attribute">after</span>": <span class="value"><span class="string">"MTAxNTExOTQ1MjAwNzI5NDE="</span></span>,</span><br><span class="line">      "<span class="attribute">before</span>": <span class="value"><span class="string">"NDMyNzQyODI3OTQw"</span></span><br><span class="line">    </span>&#125;</span>,</span><br><span class="line">    "<span class="attribute">previous</span>": <span class="value"><span class="string">"https://graph.facebook.com/me/albums?limit=25&amp;amp;before=NDMyNzQyODI3OTQw"</span></span>,</span><br><span class="line">    "<span class="attribute">next</span>": <span class="value"><span class="string">"https://graph.facebook.com/me/albums?limit=25&amp;amp;after=MTAxNTExOTQ1MjAwNzI5NDE="</span></span><br><span class="line">  </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>简单的一个例子是，当我想要获取一个人的完整好友列表（Friend List），但是这个人好友太多了，分成了很多页。显然这些结果是互相依赖的。我必须先拿到第一页的<code>paging.next</code>，才能进行下一次请求。（别跟我说改query string <code>limit</code>后面的值，limit是有最大限制的=，=）</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h5 id="当知道总共有多少页的时候"><a href="#当知道总共有多少页的时候" class="headerlink" title="当知道总共有多少页的时候"></a>当知道总共有多少页的时候</h5><p>(假设request是一个返回promise对象的函数,resolve的是上面的json)</p>
<ul>
<li>普通程序员这么做<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var url = <span class="string">'http://xxx'</span>; //first page</span><br><span class="line">request(url)</span><br><span class="line">  .<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> request(data.<span class="built_in">next</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> request(data.<span class="built_in">next</span>);</span><br><span class="line">  &#125;) //....<span class="keyword">then</span> <span class="keyword">then</span> <span class="keyword">then</span>...</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>其实这么一直then下去也是可以的…</p>
<ul>
<li>二逼程序员这么做<br>回调函数层层嵌套…Callback Hell。</li>
</ul>
<h5 id="当不知道总共多少页的时候"><a href="#当不知道总共多少页的时候" class="headerlink" title="当不知道总共多少页的时候"></a>当不知道总共多少页的时候</h5><p>不停then的方法就不行了，于是有了文艺的程序员</p>
<ul>
<li>文艺程序员这么做<br>首先要知道的一点是，当没有下一页的时候，返回的<code>next=null</code>，于是我们就有了递归的终止条件。<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">(url)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!url) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">while</span> (url) &#123;</span><br><span class="line">    <span class="keyword">return</span> request(url).then(<span class="function"><span class="keyword">function</span><span class="params">(data)</span> </span>&#123;</span><br><span class="line">      run(data.paging.next);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">'http://xxx'</span>; <span class="comment">// first page</span></span><br><span class="line">run(url);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="瞎扯"><a href="#瞎扯" class="headerlink" title="瞎扯"></a>瞎扯</h3><p>嵌套的Promise其实<strong>可能</strong>是反模式（anti-pattern）<a href="http://taoofcode.net/promise-anti-patterns/" target="_blank" rel="external">^1</a>，但是本文中的情况，如果不递归用嵌套的promise，我实在想不出别的办法来了（ (๑•́ ₃ •̀)宝宝心里苦，但宝宝不说）</p>
<p>为什么说可能是呢，因为谷歌一搜“promise anti pattern nesting”，总能搜出一大堆关于嵌套promise是反模式的文章。然而bluebird的wiki<a href="https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns" target="_blank" rel="external">^2</a>中，并没有提到嵌套的promise是反模式。</p>
<p>所以到底是不是反模式，我也不知道=，=大概的想法是，在能不嵌套的时候就不要嵌套，否则还不如用callback。</p>
<p>能不嵌套的情况是说，then的都是完全不同的promise，如果都是then类似的promise，那么，懒人还是递归吧…</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;2016-01-24更新&lt;/strong&gt;&lt;br&gt;我还是觉得嵌套多层的promise是反模式，不推荐使用，机智的我学会了另一种不嵌套不递归的方法，请看这里：&lt;br&gt;(Promise的顺序执行和并行执行](tech/2016/01/23/excecute-pa
    
    </summary>
    
    
      <category term="promise" scheme="http://sabrinaluo.com/tech/tags/promise/"/>
    
      <category term="递归" scheme="http://sabrinaluo.com/tech/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>对generator和yield的一些理解</title>
    <link href="http://sabrinaluo.com/tech/2016/01/12/ES6-generator-yield/"/>
    <id>http://sabrinaluo.com/tech/2016/01/12/ES6-generator-yield/</id>
    <published>2016-01-12T09:11:28.000Z</published>
    <updated>2016-11-24T10:12:31.650Z</updated>
    
    <content type="html"><![CDATA[<p>于是也是入了ES6的坑，为什么只有babel这种ES6转ES5的工具，而没有ES5转ES6的工具呢？可能有，但是我不知道。如果有的话，就能把5转成6，起码看起来逼格高了一大截，也能让我这种还不习惯ES6的小白假装会写ES6…</p>
<p>简单的看了一下相关的概念，觉得还不太理解…就好像最开始看<em>原型链</em>一样，花了一年多才慢慢理解继承啊什么的，但<code>constructor</code>和<code>__proto__</code>之类的东东我也还（4声）没整明白…真是资质愚钝QAQ</p>
<h3 id="generator-function"><a href="#generator-function" class="headerlink" title="generator function"></a>generator function</h3><p>一个generator函数大概长这样：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function* <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="number">111</span>);</span><br><span class="line">  yield <span class="number">123</span>;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="number">222</span>);</span><br><span class="line">  yield <span class="number">456</span>;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="number">333</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = foo(<span class="number">3</span>); <span class="comment">//此时函数不会执行</span></span><br><span class="line">a.next(); <span class="comment">//此时函数执行到第一句含有yield的语句时就暂停了，也就是只打印了 111</span></span><br><span class="line">a.next(); <span class="comment">//此时函数执行到第二句含有yield的语句时暂停，打印了 222</span></span><br><span class="line">a.next(); <span class="comment">//已经没有yield语句了，将会打印333，函数执行完毕</span></span><br><span class="line">a.next(); <span class="comment">//已经没有yiedl语句了，什么也不会打印</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>定义的时候多加一个星星号<strong>function*</strong></li>
<li>generator函数中通常都会有yield，如果没有yield那就定义一个普通函数就好了</li>
<li>函数不会立即执行，使用<code>.next()</code>方法时，函数才会执行；</li>
</ul>
<h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><p>yield到底是一个什么东东呢？操作符？对象？还是别的什么，这个我还没搞明白。</p>
<p>看看阮一峰老师的这个例子，有助于理解参数的一些问题：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function* foo(x) &#123;</span><br><span class="line">  var y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>));</span><br><span class="line">  var z = <span class="keyword">yield</span> (y / <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> (x + y + z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = foo(<span class="number">5</span>);</span><br><span class="line">a.<span class="keyword">next</span>(); <span class="regexp">//</span> <span class="constant">Object</span>&#123;<span class="symbol">value:</span><span class="number">6</span>, <span class="symbol">done:</span><span class="literal">false</span>&#125;</span><br><span class="line">a.<span class="keyword">next</span>(); <span class="regexp">//</span> <span class="constant">Object</span>&#123;<span class="symbol">value:</span><span class="constant">NaN</span>, <span class="symbol">done:</span><span class="literal">false</span>&#125;</span><br><span class="line">a.<span class="keyword">next</span>(); <span class="regexp">//</span> <span class="constant">Object</span>&#123;<span class="symbol">value:</span><span class="constant">NaN</span>, <span class="symbol">done:</span><span class="literal">false</span>&#125;</span><br><span class="line"></span><br><span class="line">var b = foo(<span class="number">5</span>);</span><br><span class="line">b.<span class="keyword">next</span>(); <span class="regexp">//</span> &#123; <span class="symbol">value:</span><span class="number">6</span>, <span class="symbol">done:</span><span class="literal">false</span> &#125; ，此时x=<span class="number">5</span>，var y还没执行</span><br><span class="line">b.<span class="keyword">next</span>(<span class="number">12</span>); <span class="regexp">//</span> &#123; <span class="symbol">value:</span><span class="number">8</span>, <span class="symbol">done:</span><span class="literal">false</span> &#125;，此时x=<span class="number">5</span>，y=<span class="number">24</span>，var z还没执行</span><br><span class="line">b.<span class="keyword">next</span>(<span class="number">13</span>); <span class="regexp">//</span> &#123; <span class="symbol">value:</span><span class="number">42</span>, <span class="symbol">done:</span><span class="literal">true</span> &#125;，此时x=<span class="number">5</span>，y=<span class="number">24</span>，</span><br></pre></td></tr></table></figure></p>
<p>当上面的函数运行<code>b.next(12)</code>这一句时，x=5，y=24，var z还没执行，返回对象为{ value:8, done:false }</p>
<blockquote>
<p>Q: 为什么y=24？<br>A: 因为第二个next方法的参数传给<em>上一个yield</em>，也就是第一个yield，所以var y = 2 * 12</p>
<p>Q: 为什么返回对象value为8？<br>A: 因为第二个yield后面跟的表达式是 y/3，y=24，所以返回的对象value为8</p>
</blockquote>
<ul>
<li>yield是一个<strong>暂停的标记</strong>，使用<code>.next()</code>方法运行函数时，遇到yield就会暂停</li>
<li>yield用在表达式中必须加括号扩起来，比如这样<code>var a = 1 + (yield 1+1)</code></li>
<li>调用<code>.next()</code>方法时会返回一个对象，长这样：<code>{ value: xxx, done: false }</code><ul>
<li>有两个key，一个是value，一个是done</li>
<li>value的值是，该次暂停遇到的这个<code>yield</code> 后面跟的表达式的值。比如上面的例子中第一次调用<code>b.next()</code>时，遇到第一个yield而暂停，<code>var y = 2 * (yield (x + 1));</code>，yield后面跟的表达式是(x+1)，所以返回的对象value是6</li>
<li>当<code>done</code>为<code>true</code>说明后面没有yield了，之后再调用<code>.next()</code>方法返回的value都是<code>undefined</code></li>
<li>如果generator函数没有返回值，那么最后一个yield之后再调用的<code>.next()</code>方法返回的就是<code>{ value:undefined, done: true }</code></li>
<li>如果generator函数有返回值，那么最后一个yield之后再调用<code>.next()</code>方法返回的对象value是函数的返回值</li>
</ul>
</li>
<li>调用<code>.next()</code>方法时，可以传入参数<ul>
<li>该参数是传给<strong>上一个yield</strong>，所以第一次调用<code>.next()</code>时不能传入参数。<em>可能会报错，也可能参数会被忽略，取决于浏览器是怎么实现的</em></li>
</ul>
</li>
<li>不传入参数时，yield语句返回的值为<code>undefined</code></li>
</ul>
<h3 id="瞎扯"><a href="#瞎扯" class="headerlink" title="瞎扯"></a>瞎扯</h3><ul>
<li>感觉yield像一个“函数”，执行的时候遇到这个函数就会暂停</li>
<li><p>这个函数返回的值等于<code>.next(xxx)</code>调用时传入的参数xxx，如果没有参数，返回值就是<code>undefined</code></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function* foo() &#123;</span><br><span class="line">  console.log(<span class="keyword">yield</span>);</span><br><span class="line">  console.log(<span class="keyword">yield</span>);</span><br><span class="line">&#125;</span><br><span class="line">var a=foo();</span><br><span class="line">a.<span class="keyword">next</span>(); <span class="regexp">//</span> 遇到第一个<span class="keyword">yield</span>暂停，什么也不打印</span><br><span class="line">a.<span class="keyword">next</span>(); <span class="regexp">//</span> 遇到第二个<span class="keyword">yield</span>暂停，打印上一句console.log(<span class="keyword">yield</span>)，由于没有传入参数，<span class="keyword">yield</span>返回undefined</span><br><span class="line">a.<span class="keyword">next</span>(<span class="string">'hello'</span>); <span class="regexp">//</span>后面没有<span class="keyword">yield</span>了，函数执行完毕，打印第二个console.log，由于传入参数，将会打印出hello</span><br></pre></td></tr></table></figure>
</li>
<li><p>yield用在表达式中必须加括号扩起来，比如这样<code>var a = 1 + (yield 1+1)</code>，有点类似于把一个函数写到表达式中要用括号括起来</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> + (<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">123</span>&#125;());</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="好奇宝宝"><a href="#好奇宝宝" class="headerlink" title="好奇宝宝"></a>好奇宝宝</h3><ul>
<li>往<code>next()</code>里传入参数的用法，在什么场景下适用？</li>
<li>通常是不是都通过<code>.next().value</code>来获取当前暂停的<code>yield</code>后面的表达式？</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;于是也是入了ES6的坑，为什么只有babel这种ES6转ES5的工具，而没有ES5转ES6的工具呢？可能有，但是我不知道。如果有的话，就能把5转成6，起码看起来逼格高了一大截，也能让我这种还不习惯ES6的小白假装会写ES6…&lt;/p&gt;
&lt;p&gt;简单的看了一下相关的概念，觉得还不
    
    </summary>
    
    
      <category term="ES6" scheme="http://sabrinaluo.com/tech/tags/ES6/"/>
    
      <category term="generator" scheme="http://sabrinaluo.com/tech/tags/generator/"/>
    
      <category term="yield" scheme="http://sabrinaluo.com/tech/tags/yield/"/>
    
  </entry>
  
  <entry>
    <title>对JS类和继承的一些理解</title>
    <link href="http://sabrinaluo.com/tech/2015/12/31/understand-js-inheritance/"/>
    <id>http://sabrinaluo.com/tech/2015/12/31/understand-js-inheritance/</id>
    <published>2015-12-31T03:36:54.000Z</published>
    <updated>2016-11-24T10:12:31.650Z</updated>
    
    <content type="html"><![CDATA[<p>本文只总结最常用的实现方法，不具体讨论各种实现方法的优缺点（这些具体可以看<a href="http://book.douban.com/subject/10546125/" target="_blank" rel="external">《JavaScript高级程序设计》</a>）。</p>
<p>直到ES5，JS也还是一个没有类的语言，虽然ES6中可以使用class关键字，但据说也只是语法糖。(不知道好不好吃ԅ(¯﹃¯ԅ))</p>
<h3 id="类的实现"><a href="#类的实现" class="headerlink" title="类的实现"></a>类的实现</h3><p>类的两个基本元素就是<strong>属性</strong>和<strong>方法</strong>。</p>
<p>JS中类的实现有很多种，构造函数模式、原型模式等等，各有各的优缺点，最常用的是混合了构造函数和原型模式的混合模式。<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span></span> Person(<span class="keyword">name</span>) &#123;</span><br><span class="line">  this.<span class="keyword">name</span> = <span class="keyword">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="string">'Hi, '</span> + this.<span class="keyword">name</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用构造函数来构造<strong>属性</strong>，然后往原型对象添加<strong>方法</strong>。这样的好处是：</p>
<ul>
<li>每个实例之间不用共享属性，拥有各自独立的属性。也就可以避免当属性为引用类型（数组、对象）时，修改一个实例的属性会影响到其他实例的情况。</li>
<li>每个实例之间共用原型对象上的方法，实现了函数复用。</li>
</ul>
<h3 id="继承的实现"><a href="#继承的实现" class="headerlink" title="继承的实现"></a>继承的实现</h3><p>JS中继承的实现也有很多种，借用构造函数，原型链等等。<br>子类继承父类，当然继承的就是父类的<strong>属性和方法</strong>。JS中继承的实现，最常用的也是混合模式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Student.prototype.constructor); <span class="comment">// Student</span></span><br><span class="line"></span><br><span class="line">Student.prototype = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(Student.prototype.constructor); <span class="comment">// Person</span></span><br><span class="line"></span><br><span class="line">Student.prototype.constructor = Student; <span class="comment">// 重写constructor</span></span><br><span class="line"></span><br><span class="line">Student.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"I'm "</span> + <span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用<strong>借用构造函数</strong>的方式来继承<strong>属性</strong>，然后使用<strong>原型链</strong>来继承<strong>方法</strong>。通过将子类的原型对象指向父类的实例，子类的实例就可以通过原型链向上查找到父类原型上的方法。</p>
<h3 id="重写子类构造函数的意义"><a href="#重写子类构造函数的意义" class="headerlink" title="重写子类构造函数的意义"></a>重写子类构造函数的意义</h3><p><code>Student.prototype = new Person();</code>这一步完全改变了Student原型对象的引用，<code>Student.prototype.constructor</code> 变为了Person原型对象的constructor。<br>个人觉得重写<code>Student.prototype.constructor = Student;</code>没有什么实际意义，可能只是<strong>约定俗成的一种潜规则</strong>。<br>人们通常可能已经习惯了使用new操作符的时候，构造函数的一致性<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Student.prototype.constructor = Student; 在上面的代码中注释掉这一句</span></span><br><span class="line"><span class="keyword">var</span> xiaobai = <span class="keyword">new</span> Student(<span class="string">'小白妹妹'</span>, <span class="number">10</span>);</span><br><span class="line">xiaobai.<span class="keyword">constructor</span>; <span class="comment">// Person</span></span><br></pre></td></tr></table></figure></p>
<p>当你在代码中遇到上面这种情况，如果不去查看之前的代码的话，肯定会觉得奇怪，为什么明明通过Student构造函数new了一个Student实例，而这个实例，却说自己的构造函数是Person？！？！WTF？！</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a href="http://stackoverflow.com/questions/4012998/what-it-the-significance-of-the-javascript-constructor-property" target="_blank" rel="external">http://stackoverflow.com/questions/4012998/what-it-the-significance-of-the-javascript-constructor-property</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文只总结最常用的实现方法，不具体讨论各种实现方法的优缺点（这些具体可以看&lt;a href=&quot;http://book.douban.com/subject/10546125/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《JavaScript高级程序设计》
    
    </summary>
    
    
      <category term="JS" scheme="http://sabrinaluo.com/tech/tags/JS/"/>
    
      <category term="prototype" scheme="http://sabrinaluo.com/tech/tags/prototype/"/>
    
      <category term="原型" scheme="http://sabrinaluo.com/tech/tags/%E5%8E%9F%E5%9E%8B/"/>
    
      <category term="继承" scheme="http://sabrinaluo.com/tech/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
</feed>
