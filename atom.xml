<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小白妹妹写代码</title>
  <subtitle>一个废话很多的程序媛</subtitle>
  <link href="/tech/atom.xml" rel="self"/>
  
  <link href="http://sabrinaluo.com/tech/"/>
  <updated>2016-04-21T10:01:55.391Z</updated>
  <id>http://sabrinaluo.com/tech/</id>
  
  <author>
    <name>Sabrina</name>
    <email>luohaojing@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微信撤回信息昵称显示原理分析</title>
    <link href="http://sabrinaluo.com/tech/2016/04/21/theory-analysis-for-wechat-recall-message-nickname/"/>
    <id>http://sabrinaluo.com/tech/2016/04/21/theory-analysis-for-wechat-recall-message-nickname/</id>
    <published>2016-04-21T09:07:08.000Z</published>
    <updated>2016-04-21T10:01:55.391Z</updated>
    
    <content type="html">&lt;h3 id=&quot;吐槽&quot;&gt;&lt;a href=&quot;#吐槽&quot; class=&quot;headerlink&quot; title=&quot;吐槽&quot;&gt;&lt;/a&gt;吐槽&lt;/h3&gt;&lt;p&gt;为了让各位亲朋好友方便的用撤回信息装x，本宝宝写了一个&lt;a href=&quot;http://sabrinaluo.com/nickname-gen&quot;&gt;昵称生成器&lt;/a&gt;&lt;br&gt;虽然是比较简单的页面，但本宝宝还没发布呢，微信就封了这个功能，宝宝心里委屈但宝宝不说…&lt;/p&gt;
&lt;h3 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h3&gt;&lt;p&gt;今天早些时候，在微信群里看到了这样的撤回信息：&lt;br&gt;&lt;figure class=&quot;highlight 1c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;牛奶&quot;&lt;/span&gt;撤回了一条信息并亲了你一下&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;开始的时候我是一脸懵逼的，然后知道复制牛奶的昵称，然后再修改就可以实现这个效果，&lt;strong&gt;一定要复制，一个字一个字打就不行&lt;/strong&gt;。&lt;br&gt;之后有同学转发了&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAwNDY5NzI4MQ==&amp;amp;mid=505551279&amp;amp;idx=1&amp;amp;sn=f10a4b837a10ed9c4a252c606f2f7c7f&amp;amp;scene=1&amp;amp;srcid=0421JP3AeSA1CmbSqEn1rLMh&amp;amp;from=singlemessage&amp;amp;isappinstalled=0&amp;amp;pass_ticket=HbJ8e6BomIu6b3R%2Bi6i69%2FT2TY3g%2FHUMQSItE5M2cd8%3D&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;一篇文章&lt;/a&gt;，然后大家纷纷搞出了各种有趣的效果：&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;zz并亲了你一下&quot;&lt;/span&gt;撤回了一条消息&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2.&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;朱饼饼息消条一了回撤&quot;&lt;/span&gt;并又瘦了一斤&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;3.&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;仝哈哈&quot;&lt;/span&gt;撤回了一条消息下一你了亲并&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h3&gt;&lt;p&gt;机智的我一开始就猜到，肯定是有些什么看不见的特殊字符导致的。&lt;/p&gt;
&lt;p&gt;作为一只前端狗，首先想到的当然是打开web微信，F12，看看昵称里到底是什么鬼，果然不出所料，我的昵称是这样的：&lt;code&gt;&amp;amp;#8238;&amp;amp;#8238;&amp;amp;#8238; 用卵么什有没并而然&amp;amp;#8237;萝卜&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;于是开始找这个&lt;code&gt;&amp;amp;#8238;&lt;/code&gt;特殊字符到底是做什么的，机智的我很快就找到了&lt;a href=&quot;http://www.fileformat.info/info/unicode/char/202e/index.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;^1&lt;/a&gt;&lt;br&gt;首先这种字符叫做&lt;em&gt;Unicode_control_characters&lt;/em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode_control_characters&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;^2&lt;/a&gt;&lt;br&gt;要知道更详细的内容（比如这种字符最开始是用于阿拉伯文等东亚文字的排版，另外类似的字符还有好几个，但）可以看看wiki的双向文稿&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%9B%99%E5%90%91%E6%96%87%E7%A8%BF&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;^3&lt;/a&gt;，还有其他更详细的使用范例&lt;a href=&quot;https://www.w3.org/International/questions/qa-bidi-unicode-controls&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;^4&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;html特殊符号&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;js unicode&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;&amp;amp;#8237;&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;\u202D&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Unicode Character ‘LEFT-TO-RIGHT OVERRIDE’&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;&amp;amp;#8238;&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;\u202E&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Unicode Character ‘RIGHT-TO-LEFT OVERRIDE’&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;所以&lt;code&gt;8237&lt;/code&gt;的作用是从左到右显示，&lt;code&gt;8238&lt;/code&gt;的作用是从右到左显示。&lt;/p&gt;
&lt;p&gt;也就是说，跟在&lt;code&gt;8238&lt;/code&gt;后面的字符串将从右到左显示（原来的排版方式会被override，直到遇到其他的控制排版的字符(Unicode_control_characters)）；而跟在&lt;code&gt;8237&lt;/code&gt;后面的字符串将从左到右显示。&lt;/p&gt;
&lt;p&gt;由于大家在复制的时候根本看不到这些字符，而且可能因为在修改昵称时&lt;strong&gt;删除&lt;/strong&gt;或&lt;strong&gt;加多&lt;/strong&gt;了这些特殊符号，所以产生了各种奇怪的效果。而前面提到的最正确我的昵称应该是只有一个&lt;code&gt;8238&lt;/code&gt;，也就是这样&lt;br&gt;&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;id&quot;&gt;#8238&lt;/span&gt;;用卵么什有没并而然&lt;span class=&quot;keyword&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;id&quot;&gt;#8237&lt;/span&gt;;萝卜&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;微信撤回信息的显示逻辑是，&lt;code&gt;&amp;quot;昵称&amp;quot;+撤回了一条信息&lt;/code&gt;，昵称前后是有引号的。&lt;br&gt;所以实际上，撤回信息的&lt;strong&gt;字符串&lt;/strong&gt;是&lt;code&gt;&amp;quot;&amp;amp;#8238;用卵么什有没并而然&amp;amp;#8237;萝卜&amp;quot;撤回了一条信息&lt;/code&gt;。&lt;br&gt;根据之前提到的&lt;code&gt;8238&lt;/code&gt;和&lt;code&gt;8237&lt;/code&gt;的作用以及前提条件（正常情况下我们看到的字都是从左到右显示），分解过程如下：（LTR从左到右，RTL从右到左）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;`第一个引号是正常显示，这个引号是LTR显示的强字符： （”）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;#8238;&lt;/code&gt;后面的 &lt;em&gt;用卵么什有没并而然&lt;/em&gt; 是RTL显示的强字符：（”然而并没有什么卵用）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;#8237;&lt;/code&gt;后面的 &lt;em&gt;萝卜”撤回了一条信息&lt;/em&gt; 是LTR显示的强字符，所以会&lt;strong&gt;紧跟&lt;/strong&gt;前面的LTR的强字符，也就是紧跟第一个引号 ：（”萝卜”撤回了一条信息然而并没有什么卵用）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;其他&quot;&gt;&lt;a href=&quot;#其他&quot; class=&quot;headerlink&quot; title=&quot;其他&quot;&gt;&lt;/a&gt;其他&lt;/h3&gt;&lt;p&gt;上面提到的有趣的效果分析：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根本没有复制到特殊符号&lt;/li&gt;
&lt;li&gt;复制到特殊符号，但”并亲了你一下”被写反了，实际的文本为&lt;code&gt;&amp;amp;#8238;并亲了你一下&amp;amp;#8237;仝哈哈&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;复制到的特殊符号不正确，实际的文本为&lt;code&gt;&amp;amp;#8238;斤一了瘦又并&amp;amp;#8237;朱饼饼&amp;amp;#8238;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;吐槽&quot;&gt;&lt;a href=&quot;#吐槽&quot; class=&quot;headerlink&quot; title=&quot;吐槽&quot;&gt;&lt;/a&gt;吐槽&lt;/h3&gt;&lt;p&gt;为了让各位亲朋好友方便的用撤回信息装x，本宝宝写了一个&lt;a href=&quot;http://sabrinaluo.com/nickname-gen
    
    </summary>
    
    
      <category term="微信，撤回信息，原理分析，双向文稿，" scheme="http://sabrinaluo.com/tech/tags/%E5%BE%AE%E4%BF%A1%EF%BC%8C%E6%92%A4%E5%9B%9E%E4%BF%A1%E6%81%AF%EF%BC%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%EF%BC%8C%E5%8F%8C%E5%90%91%E6%96%87%E7%A8%BF%EF%BC%8C/"/>
    
  </entry>
  
  <entry>
    <title>如何通过Git钩子自动部署(Push to Deploy)</title>
    <link href="http://sabrinaluo.com/tech/2016/04/14/push-to-deploy-through-git-hook/"/>
    <id>http://sabrinaluo.com/tech/2016/04/14/push-to-deploy-through-git-hook/</id>
    <published>2016-04-14T10:59:37.000Z</published>
    <updated>2016-04-21T10:01:55.391Z</updated>
    
    <content type="html">&lt;p&gt;看了好多讲通过git钩子自动部署的，大多讲的绕来绕去乱七八糟思路一点也不清晰…&lt;br&gt;做了一晚上实验之后大概明白了是怎么工作的。&lt;/p&gt;
&lt;h3 id=&quot;裸仓库（bare）&quot;&gt;&lt;a href=&quot;#裸仓库（bare）&quot; class=&quot;headerlink&quot; title=&quot;裸仓库（bare）&quot;&gt;&lt;/a&gt;裸仓库（bare）&lt;/h3&gt;&lt;p&gt;裸仓库跟我们平时&lt;code&gt;git clone&lt;/code&gt;得到的仓库太一样，裸仓库其实相当于通过克隆来的仓库里的&lt;code&gt;.git&lt;/code&gt;文件夹，整个裸仓库中只有git索引（index），&lt;strong&gt;并没有任何代码相关的东西&lt;/strong&gt;。要实现Push to Deploy，首先我们需要一个裸仓库。&lt;/p&gt;
&lt;p&gt;在克隆时使用 &lt;code&gt;--bare&lt;/code&gt;参数来克隆一个裸仓库&lt;br&gt;&lt;figure class=&quot;highlight applescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git init &lt;span class=&quot;comment&quot;&gt;--bare xxx-bare&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;###钩子（hook）&lt;br&gt;普通仓库&lt;code&gt;.git&lt;/code&gt;文件夹下有一个&lt;code&gt;hooks&lt;/code&gt;文件夹，裸仓库下直接有一个&lt;code&gt;hooks&lt;/code&gt;文件夹，里面有各种各样以&lt;code&gt;.sample&lt;/code&gt;结尾的钩子，当把&lt;code&gt;.sample&lt;/code&gt;后缀删除时，钩子就是激活状态。&lt;br&gt;&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;.git&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├───hooks&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;│   └───post-update&lt;span class=&quot;class&quot;&gt;.sample&lt;/span&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;└─── ...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;你可以在钩子文件里写一些bash命令，被激活的钩子被触发时会执行你的bash命令。&lt;/p&gt;
&lt;p&gt;与deploy相关的通常使用&lt;code&gt;post-update&lt;/code&gt;钩子或者&lt;code&gt;post-receive&lt;/code&gt;钩子&lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/githooks.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;^1&lt;/a&gt;，关于这两个钩子到底有什么不同，我是没太看懂，大概的理解是这两个钩子被trigger的时候收到的信息不一样，如果需要用commit的相关信息来做一些事情的话要仔细研究（比如可以设置某个分支收到了推送就做相应的事情之类），其他如果只是通过bash来跑一些node相关的部署命令，两个都可以。这篇文章只给一个最简单的例子，跟分支啊什么的都没关系，只要收到推送就部署。&lt;/p&gt;
&lt;p&gt;要实现Push to Deploy，我们需要修改裸仓库中相应的钩子文件&lt;/p&gt;
&lt;h3 id=&quot;裸仓库是怎么工作的&quot;&gt;&lt;a href=&quot;#裸仓库是怎么工作的&quot; class=&quot;headerlink&quot; title=&quot;裸仓库是怎么工作的&quot;&gt;&lt;/a&gt;裸仓库是怎么工作的&lt;/h3&gt;&lt;p&gt;可以在本地同一个文件夹下先创建一个裸仓库名为xxx-remote（模拟远程服务器），再创建一个xxx-local仓库（模拟本地），将xxx-remote添加为本地仓库的远程仓库，在本地仓库写一个&lt;code&gt;README.md&lt;/code&gt;文件，提交并push&lt;br&gt;&lt;figure class=&quot;highlight livecodeserver&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git init &lt;span class=&quot;comment&quot;&gt;--bare xxx-remote&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git init xxx-&lt;span class=&quot;built_in&quot;&gt;local&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd xxx-&lt;span class=&quot;built_in&quot;&gt;local&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git remote &lt;span class=&quot;built_in&quot;&gt;add&lt;/span&gt; origin ../xxx-remote&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo test123&amp;gt;README.md&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;built_in&quot;&gt;add&lt;/span&gt; .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git commit -m &lt;span class=&quot;string&quot;&gt;&#39;add readme file&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git push -u origin master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;之后切换到远程仓库文件夹，查看git log&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; ..&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; xxx-remote&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;将能够看到有一条commit记录，提交信息是 add readme file，远程仓库收到了本地仓库的push&lt;/p&gt;
&lt;h3 id=&quot;钩子是怎么工作的&quot;&gt;&lt;a href=&quot;#钩子是怎么工作的&quot; class=&quot;headerlink&quot; title=&quot;钩子是怎么工作的&quot;&gt;&lt;/a&gt;钩子是怎么工作的&lt;/h3&gt;&lt;p&gt;进入远程仓库，将&lt;code&gt;hooks&lt;/code&gt;文件夹下的&lt;code&gt;post-update.sample&lt;/code&gt;改名为&lt;code&gt;post-update&lt;/code&gt;，打开并编辑为如下内容：&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;shebang&quot;&gt;#!/bin/sh&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;set&lt;/span&gt; -x &lt;span class=&quot;comment&quot;&gt;#显示每条命令&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;push push&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;修改本地仓库的文件，进行一次推送，将会看到远程服务器执行了相应的命令&lt;br&gt;&lt;figure class=&quot;highlight avrasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Total &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; (delta &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;), reused &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; (delta &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;label&quot;&gt;remote:&lt;/span&gt; + echo &lt;span class=&quot;keyword&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;push&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;label&quot;&gt;remote:&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;push&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;To ../xxx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; + &lt;span class=&quot;number&quot;&gt;41&lt;/span&gt;b78ee..&lt;span class=&quot;number&quot;&gt;.055&lt;/span&gt;cec9 master -&amp;gt; master (forced update)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;一个完整的场景举例&quot;&gt;&lt;a href=&quot;#一个完整的场景举例&quot; class=&quot;headerlink&quot; title=&quot;一个完整的场景举例&quot;&gt;&lt;/a&gt;一个完整的场景举例&lt;/h3&gt;&lt;p&gt;假设有一台远程服务器上跑着一个网站，希望每次git push之后这个网站就自动更新。&lt;br&gt;为了方便：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;假设远程服务器上放了&lt;strong&gt;裸仓库&lt;/strong&gt;和&lt;strong&gt;网站&lt;/strong&gt;，自动部署的过程就是裸仓库收到push之后更新一下网站的文件夹&lt;/li&gt;
&lt;li&gt;假设网站都是静态文件，不需要重启web server&lt;/li&gt;
&lt;li&gt;假设都只考虑默认的master分支&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们需要：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在这台远程服务器上创建一个裸仓库，假如名叫xxx。克隆repo取名为website，用于存放网站文件&lt;/p&gt;
&lt;figure class=&quot;highlight crmsh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git init --bare xxx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;keyword&quot;&gt;clone&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;./xxx&lt;/span&gt; website&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改远程服务器下&lt;code&gt;hooks&lt;/code&gt;文件夹下的&lt;code&gt;post-update.sample&lt;/code&gt;改名为&lt;code&gt;post-update&lt;/code&gt;，编辑为如下内容：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;shebang&quot;&gt;#!/bin/sh&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;set&lt;/span&gt; -x &lt;span class=&quot;comment&quot;&gt;#显示每条命令&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git reset --hard origin/master &lt;span class=&quot;comment&quot;&gt;#防止因为forced push而导致无法checkout&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git checkout&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在本地repo添加远程仓库&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git remote add origin ubuntu&lt;span class=&quot;variable&quot;&gt;@59&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;64.123&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:home/xxx&lt;/span&gt;.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;4.在本地仓库修改文件并push&lt;/p&gt;
&lt;p&gt;至此整个git自动部署的过程就完成了&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;看了好多讲通过git钩子自动部署的，大多讲的绕来绕去乱七八糟思路一点也不清晰…&lt;br&gt;做了一晚上实验之后大概明白了是怎么工作的。&lt;/p&gt;
&lt;h3 id=&quot;裸仓库（bare）&quot;&gt;&lt;a href=&quot;#裸仓库（bare）&quot; class=&quot;headerlink&quot; title=&quot;裸仓
    
    </summary>
    
    
      <category term="git" scheme="http://sabrinaluo.com/tech/tags/git/"/>
    
      <category term="hook" scheme="http://sabrinaluo.com/tech/tags/hook/"/>
    
      <category term="自动部署" scheme="http://sabrinaluo.com/tech/tags/%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>结合使用Babel Mocha Istanbul进行ES6代码测试和覆盖率测试</title>
    <link href="http://sabrinaluo.com/tech/2016/04/12/babel-mocha-istanbul-es6-testing-and-coverage/"/>
    <id>http://sabrinaluo.com/tech/2016/04/12/babel-mocha-istanbul-es6-testing-and-coverage/</id>
    <published>2016-04-12T04:32:01.000Z</published>
    <updated>2016-04-21T10:01:55.391Z</updated>
    
    <content type="html">&lt;p&gt;题外话：&lt;br&gt;一直以为mocha读作“抹茶”并且一直这么读了很久，直到最近看了一个mocha的教学视频，才知道这是摩卡咖啡的摩卡…而抹茶的抹茶应该是matcha…&lt;/p&gt;
&lt;p&gt;在还没有babel的时候，一切都很简单，基础的问题就先不讨论了，这里主要记录一下Babel转码和Istanbul测覆盖率的一些坑。&lt;/p&gt;
&lt;h3 id=&quot;基本设置&quot;&gt;&lt;a href=&quot;#基本设置&quot; class=&quot;headerlink&quot; title=&quot;基本设置&quot;&gt;&lt;/a&gt;基本设置&lt;/h3&gt;&lt;p&gt;通常我们会有好几个文件夹，例如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;src&lt;/code&gt;用来存放源文件，也就是包含es6,7的代码；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lib&lt;/code&gt;用来存放编译后的代码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;test&lt;/code&gt;用来放测试脚本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在&lt;code&gt;test&lt;/code&gt;文件夹下，通常有一个&lt;code&gt;mocha.opts&lt;/code&gt;文件用来存放mocha的参数&lt;br&gt;&lt;figure class=&quot;highlight haml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-&lt;span class=&quot;ruby&quot;&gt;-compilers &lt;span class=&quot;symbol&quot;&gt;js:&lt;/span&gt;babel-register&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;-&lt;span class=&quot;ruby&quot;&gt;-&lt;span class=&quot;keyword&quot;&gt;require&lt;/span&gt; babel-polyfill&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果用到了需要用babel-polyfill才能实现的方法就需要加上第二句，别忘了&lt;code&gt;npm install babel-polyfill --save-dev&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;生成覆盖率的测试命令：（&lt;code&gt;_mocha&lt;/code&gt; 是有下划线的）&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/06/istanbul.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;^1&lt;/a&gt;&lt;br&gt;&lt;figure class=&quot;highlight brainfuck&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;istanbul&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;cover&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;_mocha&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;literal&quot;&gt;-&lt;/span&gt;  &lt;span class=&quot;literal&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;literal&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;opts&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;/test/mocha&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;opts&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;编译&quot;&gt;&lt;a href=&quot;#编译&quot; class=&quot;headerlink&quot; title=&quot;编译&quot;&gt;&lt;/a&gt;编译&lt;/h3&gt;&lt;figure class=&quot;highlight crystal&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;babel src/ -d &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;lib&lt;/span&gt;/ --&lt;span class=&quot;title&quot;&gt;presets&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;es2015&lt;/span&gt; --&lt;span class=&quot;title&quot;&gt;source&lt;/span&gt;-&lt;span class=&quot;title&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;both&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用&lt;code&gt;--source-map both&lt;/code&gt;参数将会生成source map，有了source map，istanbul就能够追踪到&lt;code&gt;src&lt;/code&gt;下的源代码的覆盖率&lt;/p&gt;
&lt;h3 id=&quot;正确的require&quot;&gt;&lt;a href=&quot;#正确的require&quot; class=&quot;headerlink&quot; title=&quot;正确的require&quot;&gt;&lt;/a&gt;正确的require&lt;/h3&gt;&lt;p&gt;在mocha中，一定要require &lt;code&gt;src&lt;/code&gt;文件夹下的文件，而不是&lt;code&gt;lib&lt;/code&gt;文件夹下的文件。虽然两个文件夹下的文件mocha都能测，但是覆盖率会有一些问题。&lt;/p&gt;
&lt;h3 id=&quot;可能的问题&quot;&gt;&lt;a href=&quot;#可能的问题&quot; class=&quot;headerlink&quot; title=&quot;可能的问题&quot;&gt;&lt;/a&gt;可能的问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;出现以下错误提示时，很可能因为istanbul的版本过低，使用&lt;code&gt;1.0.0-alpha.2&lt;/code&gt;版本可以正常运行&lt;/p&gt;
&lt;figure class=&quot;highlight applescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;No coverage information was collected, &lt;span class=&quot;keyword&quot;&gt;exit&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;without&lt;/span&gt; writing coverage information&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;istanbul生成的覆盖率文件里代码几乎都是&lt;strong&gt;红色&lt;/strong&gt;的，这是因为编译时没有 &lt;code&gt;--source-map both&lt;/code&gt; 参数，追踪的是&lt;code&gt;lib&lt;/code&gt;文件夹下的覆盖率&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;istanbul生成的覆盖率文件总是显示100%，就算有些地方没测，也显示100%，这是因为在Mocha里require的是&lt;code&gt;lib&lt;/code&gt;而非&lt;code&gt;src&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;其他&quot;&gt;&lt;a href=&quot;#其他&quot; class=&quot;headerlink&quot; title=&quot;其他&quot;&gt;&lt;/a&gt;其他&lt;/h3&gt;&lt;p&gt;我最喜欢mocha的报告形式是&lt;code&gt;-R nyan&lt;/code&gt;，一只可爱的喵星人，没有错的时候是这样的^_^，有错的时候是这样的O_O，反正就是萌萌萌。&lt;/p&gt;
&lt;p&gt;然而最实用的报告形式可能是&lt;code&gt;-R mochawesome&lt;/code&gt;，需要&lt;code&gt;npm i mochawesome&lt;/code&gt;安装插件，生成直观的html测试报告&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;^2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;平时遇到的问题十有八九一搜都能找到阮一峰老师的教程…这覆盖率也太高了？！&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;p&gt;[1] &lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/06/istanbul.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.ruanyifeng.com/blog/2015/06/istanbul.html&lt;/a&gt;&lt;br&gt;[2] &lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;题外话：&lt;br&gt;一直以为mocha读作“抹茶”并且一直这么读了很久，直到最近看了一个mocha的教学视频，才知道这是摩卡咖啡的摩卡…而抹茶的抹茶应该是matcha…&lt;/p&gt;
&lt;p&gt;在还没有babel的时候，一切都很简单，基础的问题就先不讨论了，这里主要记录一下Babel转码
    
    </summary>
    
    
      <category term="ES6" scheme="http://sabrinaluo.com/tech/tags/ES6/"/>
    
      <category term="babel" scheme="http://sabrinaluo.com/tech/tags/babel/"/>
    
      <category term="istanbul" scheme="http://sabrinaluo.com/tech/tags/istanbul/"/>
    
      <category term="mocha" scheme="http://sabrinaluo.com/tech/tags/mocha/"/>
    
      <category term="代码覆盖率" scheme="http://sabrinaluo.com/tech/tags/%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87/"/>
    
      <category term="测试" scheme="http://sabrinaluo.com/tech/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>箭头函数的作用域和this</title>
    <link href="http://sabrinaluo.com/tech/2016/04/01/scope-and-this-of-arrow-function/"/>
    <id>http://sabrinaluo.com/tech/2016/04/01/scope-and-this-of-arrow-function/</id>
    <published>2016-04-01T08:38:12.000Z</published>
    <updated>2016-04-21T10:01:55.391Z</updated>
    
    <content type="html">&lt;p&gt;JS里的作用域和this一直是一件令人头疼的事情，以前接触的不太多，毕竟面向过程编程的我基本上都不会使用“类”这个概念。&lt;/p&gt;
&lt;p&gt;自从开始学习ES6，很长一段时间都认为箭头函数(Arrow Function)&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;^1&lt;/a&gt;就是给懒人用的&lt;strong&gt;简写的匿名函数&lt;/strong&gt;而已。后来看到有人挑战阮一峰老师&lt;a href=&quot;http://es6.ruanyifeng.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《ECMAScript 6入门》&lt;/a&gt;中关于箭头函数this的一些问题&lt;a href=&quot;https://github.com/ruanyf/es6tutorial/issues/150&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;^2&lt;/a&gt;，才对箭头函数有了一丁点的理解。&lt;/p&gt;
&lt;p&gt;我平时的工作基本上都是各种第三方的API整合，于是各种异步请求，promise都是家常便饭。由于SalesForce没有直接的nodejs sdk，所以自己写一个自定义的类就不可避免了。在写的过程中，关于this踩到坑里了，所以就有了这篇文章。&lt;/p&gt;
&lt;h3 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h3&gt;&lt;p&gt;其中一个简单的功能是，查找用户是否存在，若存在则发送欢迎邮件（整个流程对应&lt;code&gt;onBoardFlow&lt;/code&gt;）。实际场景比这个要复杂，可能需要连续发送好几个请求，为了避免&lt;em&gt;回调地狱&lt;/em&gt;，所有的请求我都用promise包了起来。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;pi&quot;&gt;&#39;use strict&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SalesForce&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  constructor(email, username) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.email = email;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.username = username;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  checkUser()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; getUserByName(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.username); &lt;span class=&quot;comment&quot;&gt;//发送一个请求到salesforce，返回一个promise&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  sendEmail()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; send(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.email); &lt;span class=&quot;comment&quot;&gt;//发送一个请求通知salesforce发送邮件，返回一个promise&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  onBoardFlow()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//....&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;方案&quot;&gt;&lt;a href=&quot;#方案&quot; class=&quot;headerlink&quot; title=&quot;方案&quot;&gt;&lt;/a&gt;方案&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;在&lt;code&gt;onBoardFlow&lt;/code&gt;中，搞不清this和作用域的我首先这么写：&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight coffeescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt;例&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.checkuser().&lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.sendEmail);  &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt;Cannot read property &lt;span class=&quot;string&quot;&gt;&#39;email&#39;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然后想到了在promise链中，this指向的是global；&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Q: &lt;strong&gt;为什么能找到&lt;code&gt;this.sendEmail()&lt;/code&gt;方法，却找不到&lt;code&gt;this.email&lt;/code&gt;属性呢？&lt;/strong&gt;&lt;br&gt;A: 我的理解是：因为&lt;code&gt;this.sendEmail&lt;/code&gt;是作为参数传入，传入的this是then外部的this，也就是&lt;code&gt;SalesForce&lt;/code&gt;对象；&lt;br&gt;而this.sendEmail函数的作用域中产生了&lt;strong&gt;新的this&lt;/strong&gt;，而这个this指向global（浏览器中为window对象）；在严格模式下this为undefined；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;然后容易想到的就是各种_this self，然后bind(this) call(_this)之类的&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight ceylon&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//例2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.checkuser().&lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.sendEmail.bind(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;));  &lt;span class=&quot;comment&quot;&gt;//it works !&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这样是可以正常工作的，但感觉怪怪的，每个then都要&lt;code&gt;bind(this)&lt;/code&gt;真是一点也不优雅。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;匿名函数和箭头函数原来不一样啊&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//例3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.checkuser().then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.sendEmail();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);  &lt;span class=&quot;comment&quot;&gt;//Cannot read property &#39;updateFunnelData&#39; of undefined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;此时&lt;code&gt;this.sendEmail&lt;/code&gt;的this是then中的匿名函数新产生的promise作用域下的this，非严格模式下指向global&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在箭头函数出现之前，每个新定义的函数都将新产生自己作用域下的this, arguments等对象&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;^1&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight coffeescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;例&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.checkuser().&lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.sendEmail());  &lt;span class=&quot;regexp&quot;&gt;//i&lt;/span&gt;t works!&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;词法作用域&quot;&gt;&lt;a href=&quot;#词法作用域&quot; class=&quot;headerlink&quot; title=&quot;词法作用域&quot;&gt;&lt;/a&gt;词法作用域&lt;/h3&gt;&lt;p&gt;作用域内可以嵌套作用域，从而形成作用域链，在最外层的也就是全局作用域，当在内部查找一个对象时，会顺着作用域链最内层，层层向外寻找，直到找到为止。&lt;/p&gt;
&lt;p&gt;在例3中，匿名函数的作用域中产生了新的&lt;code&gt;this&lt;/code&gt;，该&lt;code&gt;this&lt;/code&gt;指向global&lt;br&gt;在例4中，箭头函数的作用域中没有产生新的this，所以顺着作用域链层层往外寻找&lt;code&gt;this&lt;/code&gt;，找到&lt;code&gt;onBoardFlow()&lt;/code&gt;的作用域时，找到了&lt;code&gt;this&lt;/code&gt;，而此时&lt;code&gt;this&lt;/code&gt;就是&lt;code&gt;SalesForce&lt;/code&gt;对象&lt;/p&gt;
&lt;h3 id=&quot;为什么promise中的this指向global&quot;&gt;&lt;a href=&quot;#为什么promise中的this指向global&quot; class=&quot;headerlink&quot; title=&quot;为什么promise中的this指向global&quot;&gt;&lt;/a&gt;为什么promise中的this指向global&lt;/h3&gt;&lt;p&gt;这个，我还没学会…&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;JS里的作用域和this一直是一件令人头疼的事情，以前接触的不太多，毕竟面向过程编程的我基本上都不会使用“类”这个概念。&lt;/p&gt;
&lt;p&gt;自从开始学习ES6，很长一段时间都认为箭头函数(Arrow Function)&lt;a href=&quot;https://developer.moz
    
    </summary>
    
      <category term="ES6" scheme="http://sabrinaluo.com/tech/categories/ES6/"/>
    
    
      <category term="es6" scheme="http://sabrinaluo.com/tech/tags/es6/"/>
    
      <category term="this" scheme="http://sabrinaluo.com/tech/tags/this/"/>
    
      <category term="作用域" scheme="http://sabrinaluo.com/tech/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
      <category term="箭头函数" scheme="http://sabrinaluo.com/tech/tags/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    
      <category term="词法作用域" scheme="http://sabrinaluo.com/tech/tags/%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>AWS EC2 SSH访问 &amp; mongodb 安装</title>
    <link href="http://sabrinaluo.com/tech/2016/03/14/aws-ec2-ssh-access-mongodb-installation/"/>
    <id>http://sabrinaluo.com/tech/2016/03/14/aws-ec2-ssh-access-mongodb-installation/</id>
    <published>2016-03-14T10:33:31.000Z</published>
    <updated>2016-04-21T10:01:55.391Z</updated>
    
    <content type="html">&lt;p&gt;环境：Ubuntu&lt;/p&gt;
&lt;h3 id=&quot;SSH连接-EC2&quot;&gt;&lt;a href=&quot;#SSH连接-EC2&quot; class=&quot;headerlink&quot; title=&quot;SSH连接 EC2&quot;&gt;&lt;/a&gt;SSH连接 EC2&lt;/h3&gt;&lt;p&gt;windows下通常用putty&lt;br&gt;ubuntu下先打个命令&lt;code&gt;ssh&lt;/code&gt;看看能否识别命令，如果能就方便很多&lt;/p&gt;
&lt;p&gt;要连接EC2通常都会有一个&lt;code&gt;.pem&lt;/code&gt;的&lt;strong&gt;私钥&lt;/strong&gt;文件，另外还会有一个&lt;strong&gt;Public IP&lt;/strong&gt;&lt;br&gt;首先设置权限（并不知道这个有什么用，chmod 400使得文件只能被该文件的拥有者读取）&lt;br&gt;&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;chmod &lt;span class=&quot;number&quot;&gt;400&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;/*path*/&lt;/span&gt;my-key-pair&lt;span class=&quot;class&quot;&gt;.pem&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ssh -&lt;span class=&quot;tag&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;/*path*/&lt;/span&gt;my-key-pair&lt;span class=&quot;class&quot;&gt;.pem&lt;/span&gt; username@&lt;span class=&quot;number&quot;&gt;59.64&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;123.1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其中username默认如下：&lt;a href=&quot;http://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/AccessingInstancesLinux.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;^1&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:right&quot;&gt;OS&lt;/th&gt;
&lt;th style=&quot;text-align:right&quot;&gt;username&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:right&quot;&gt;Linux&lt;/td&gt;
&lt;td style=&quot;text-align:right&quot;&gt;ec2-user&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:right&quot;&gt;RHEL5&lt;/td&gt;
&lt;td style=&quot;text-align:right&quot;&gt;root 或 ec2-user&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:right&quot;&gt;Ubuntu&lt;/td&gt;
&lt;td style=&quot;text-align:right&quot;&gt;ubuntu&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;mongodb安装及配置&quot;&gt;&lt;a href=&quot;#mongodb安装及配置&quot; class=&quot;headerlink&quot; title=&quot;mongodb安装及配置&quot;&gt;&lt;/a&gt;mongodb安装及配置&lt;/h3&gt;&lt;p&gt;有了apt-get一切真是轻松如放屁…连解压缩都不用！也不用再设置环境变量什么的（根部记不住解压缩的命令…）&lt;br&gt;&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-&lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt; install mongodb&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;安装好了之后，去&lt;strong&gt;根目录&lt;/strong&gt;下创建&lt;code&gt;data&lt;/code&gt;文件夹即可，然后打&lt;code&gt;mongod&lt;/code&gt;命令，应该就启动了，此时访问&lt;code&gt;localhost:27017&lt;/code&gt;，如果看到以下文字，就成功启动了芒果DB&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You are trying to access MongoDB on the native driver port. For http diagnostic access, add 1000 to the port number&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果有error通常是没有data文件夹，设置&lt;code&gt;dbpath&lt;/code&gt;后再尝试启动&lt;br&gt;&lt;figure class=&quot;highlight applescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mongod &lt;span class=&quot;comment&quot;&gt;--dbpath=./path_of _data&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;环境：Ubuntu&lt;/p&gt;
&lt;h3 id=&quot;SSH连接-EC2&quot;&gt;&lt;a href=&quot;#SSH连接-EC2&quot; class=&quot;headerlink&quot; title=&quot;SSH连接 EC2&quot;&gt;&lt;/a&gt;SSH连接 EC2&lt;/h3&gt;&lt;p&gt;windows下通常用putty&lt;br&gt;ubunt
    
    </summary>
    
    
      <category term="AWS" scheme="http://sabrinaluo.com/tech/tags/AWS/"/>
    
      <category term="EC2" scheme="http://sabrinaluo.com/tech/tags/EC2/"/>
    
      <category term="mongodb" scheme="http://sabrinaluo.com/tech/tags/mongodb/"/>
    
      <category term="ssh" scheme="http://sabrinaluo.com/tech/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>AWS API Gateway Mapping Template 获取IP, header等</title>
    <link href="http://sabrinaluo.com/tech/2016/03/07/aws-api-gateway-mapping-templates/"/>
    <id>http://sabrinaluo.com/tech/2016/03/07/aws-api-gateway-mapping-templates/</id>
    <published>2016-03-07T06:33:03.000Z</published>
    <updated>2016-04-21T10:01:55.391Z</updated>
    
    <content type="html">&lt;p&gt;API Gateway暂时没有详细的中文文档，翻译无能的我实在不知道Mapping Template应该翻译成什么比较好。&lt;/p&gt;
&lt;h3 id=&quot;适用场景&quot;&gt;&lt;a href=&quot;#适用场景&quot; class=&quot;headerlink&quot; title=&quot;适用场景&quot;&gt;&lt;/a&gt;适用场景&lt;/h3&gt;&lt;p&gt;在配合API Gateway和Lambda来搭建RESTful API时，Lambda获取的payload并非通常服务器端获取的一个request对象，lambda获取到的payload并&lt;strong&gt;不包含 request header&lt;/strong&gt;的内容，而只有&lt;strong&gt;request body&lt;/strong&gt;的内容。&lt;/p&gt;
&lt;p&gt;header中的部分内容可以通过API Gateway提供的变量从mapping template中获取。可以获取的内容包括IP, http方法，路由参数，query等，具体可以看文档&lt;a href=&quot;http://docs.aws.amazon.com/zh_cn/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;^1&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;设置方法&quot;&gt;&lt;a href=&quot;#设置方法&quot; class=&quot;headerlink&quot; title=&quot;设置方法&quot;&gt;&lt;/a&gt;设置方法&lt;/h3&gt;&lt;p&gt;按照理论来说，AWS设置可以通过界面设置的都可以通过脚本来设置。下面只介绍在界面中的设置：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在API Gateway界面中选中具体的api方法，点击右侧的&lt;strong&gt;Intergration Request&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在底部点击&lt;strong&gt;Mapping Templates&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;点击&lt;strong&gt;Add Mapping Template&lt;/strong&gt;，输入&lt;code&gt;application/json&lt;/code&gt;，点击√进行确认&lt;/li&gt;
&lt;li&gt;在右侧新出现的区域，点击编辑按钮（铅笔图标），输入需要的变量即可，例如要获取ip：&lt;figure class=&quot;highlight xquery&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;&quot;body&quot;&lt;/span&gt;: &lt;span class=&quot;variable&quot;&gt;$input&lt;/span&gt;.json(&lt;span class=&quot;string&quot;&gt;&#39;$&#39;&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;&quot;source_ip&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;&quot;$context.identity.sourceIp&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中&lt;code&gt;$input.json(&amp;#39;$&amp;#39;)&lt;/code&gt;是请求时客户端发来的body&lt;/p&gt;
&lt;h3 id=&quot;response-header和cookie&quot;&gt;&lt;a href=&quot;#response-header和cookie&quot; class=&quot;headerlink&quot; title=&quot;response header和cookie&quot;&gt;&lt;/a&gt;response header和cookie&lt;/h3&gt;&lt;p&gt;在配合使用lambda和API gateway的时候，header和cookie是非常令人头疼的问题…&lt;br&gt;lambda返回的内容，只是response body，因此设置header要在api gateway中进行，并且也是有一些限制的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在API Gateway界面中选中具体的api方法，点击右侧的&lt;strong&gt;Method Response&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;展开HTTP Status，点击&lt;strong&gt;Add Header&lt;/strong&gt;，添加一个header。&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：可以添加多个Header，但这些header不能同名，这也就意味着，只能有一个&lt;code&gt;Set-Cookie&lt;/code&gt;，只能添加一个cookie &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;完成以上步骤后，返回第一步所在的页面，点击&lt;strong&gt;Integration Response&lt;/strong&gt;，点击三角展开，会看到&lt;strong&gt;Header Mappings&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在对应的位置编辑&lt;strong&gt;mapping value&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;如果想使用lambda返回的数据，设置为&lt;code&gt;integration.response.body.KEY&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果不是使用lambda（即把gateway用作代理），而是使用实际服务器返回的header，设置为&lt;code&gt;integration.response.header.KEY&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.aws.amazon.com/zh_cn/apigateway/latest/developerguide/how-to-method-settings-execution-console.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://docs.aws.amazon.com/zh_cn/apigateway/latest/developerguide/how-to-method-settings-execution-console.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.aws.amazon.com/zh_cn/apigateway/latest/developerguide/request-response-data-mappings.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://docs.aws.amazon.com/zh_cn/apigateway/latest/developerguide/request-response-data-mappings.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;API Gateway暂时没有详细的中文文档，翻译无能的我实在不知道Mapping Template应该翻译成什么比较好。&lt;/p&gt;
&lt;h3 id=&quot;适用场景&quot;&gt;&lt;a href=&quot;#适用场景&quot; class=&quot;headerlink&quot; title=&quot;适用场景&quot;&gt;&lt;/a&gt;适用场景&lt;
    
    </summary>
    
    
      <category term="API Gateway" scheme="http://sabrinaluo.com/tech/tags/API-Gateway/"/>
    
      <category term="AWS" scheme="http://sabrinaluo.com/tech/tags/AWS/"/>
    
      <category term="header" scheme="http://sabrinaluo.com/tech/tags/header/"/>
    
      <category term="lambda" scheme="http://sabrinaluo.com/tech/tags/lambda/"/>
    
      <category term="mapping templates" scheme="http://sabrinaluo.com/tech/tags/mapping-templates/"/>
    
  </entry>
  
  <entry>
    <title>Cookie在前端和后端的设置</title>
    <link href="http://sabrinaluo.com/tech/2016/02/29/set-cookie-from-server-side-and-client-side/"/>
    <id>http://sabrinaluo.com/tech/2016/02/29/set-cookie-from-server-side-and-client-side/</id>
    <published>2016-02-29T06:04:57.000Z</published>
    <updated>2016-04-21T10:01:55.391Z</updated>
    
    <content type="html">&lt;p&gt;http协议什么的，不知道跟通信有没有关系…作为一个通信科班出身的硬&lt;del&gt;汉&lt;/del&gt;妹，对各种协议基本上只能说出名字，别的一窍不通=，= 所以当我知道cookie原来是在header里的时候，当时我就震惊了…&lt;/p&gt;
&lt;p&gt;在服务器端，各种框架都已经包装好了方便设置cookie的方法，比如nodejs的express，php的codeignitor、laravel（我居然都被迫写过php了，真是逼良为娼…）&lt;/p&gt;
&lt;p&gt;为什么要了解设置cookie的原理呢？了解了才能在某些时候用最原始的方法来设置cookie，比如没有框架可用的时候，以及框架提供的方法不适用于某些场景的时候。&lt;br&gt;我是在使用laravel设置cookie的时候踩了坑，现在的项目里因为要配合使用GTM（google tag manager），所以cookie是不加密的raw data，但通过laravel设置的cookie都是加密了的。于是只能学习PHP原生的添加cookie方法。&lt;code&gt;setcookie(NAME, VALUE, EXPIRES)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;另外就是因为用AWS API Gateway时候的一些需求，想要通过gateway直接设置cookie，这个时候就不得不了解http cookie的运作方式。&lt;/p&gt;
&lt;h3 id=&quot;response-cookie-从服务器端返回新cookie&quot;&gt;&lt;a href=&quot;#response-cookie-从服务器端返回新cookie&quot; class=&quot;headerlink&quot; title=&quot;response cookie 从服务器端返回新cookie&quot;&gt;&lt;/a&gt;response cookie 从服务器端返回新cookie&lt;/h3&gt;&lt;p&gt;设置cookie是通过在响应的头部加入&lt;code&gt;Set-Cookie&lt;/code&gt;来设置的，&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;一个请求通常包含header和body&lt;/li&gt;
&lt;li&gt;与请求有关的cookie分为request cookie和response cookie&lt;ul&gt;
&lt;li&gt;request cookie是浏览器已储存的cookie&lt;/li&gt;
&lt;li&gt;response cookie是服务器端返回的新的cookie，也就是将会储存在浏览器端的新cookie&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;一个完整的cookie-header&quot;&gt;&lt;a href=&quot;#一个完整的cookie-header&quot; class=&quot;headerlink&quot; title=&quot;一个完整的cookie header&quot;&gt;&lt;/a&gt;一个完整的cookie header&lt;/h4&gt;&lt;p&gt;一个完整的cookie头长这样&lt;br&gt;&lt;figure class=&quot;highlight dos&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;Set&lt;/span&gt;-Cookie: NAME=VALUE; expires=&lt;span class=&quot;built_in&quot;&gt;DATE&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;path&lt;/span&gt;=&lt;span class=&quot;built_in&quot;&gt;PATH&lt;/span&gt;; domain=DOMAIN&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;NAME VALUE是一对键值&lt;br&gt;expires是过期日期，通常用当前时间的毫秒数加上一段时间：&lt;code&gt;new Date().getTime()+30*24*60*60*1000)&lt;/code&gt;，然后&lt;strong&gt;需要调用&lt;code&gt;toUTCString()&lt;/code&gt;方法&lt;/strong&gt;&lt;br&gt;如果不设置expires，在浏览器中这个cookie将被当做session对待，也就是关闭了浏览器cookie就消失&lt;br&gt;path和domain这个…感觉不太用得到，具体可以看&lt;a href=&quot;http://blog.sina.com.cn/s/blog_70c4d9410100z3il.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果要同时设置多个cookie，同时返回多个&lt;code&gt;Set-Cookie&lt;/code&gt;头即可&lt;/p&gt;
&lt;h4 id=&quot;maxAge&quot;&gt;&lt;a href=&quot;#maxAge&quot; class=&quot;headerlink&quot; title=&quot;maxAge&quot;&gt;&lt;/a&gt;maxAge&lt;/h4&gt;&lt;p&gt;有一些服务器端的框架会提供maxAge属性来设置cookie的过期时间，但是原始的Set-Cookie头是不支持maxAge的，所以在通过头部来设置cookie还是乖乖用回expires吧&lt;/p&gt;
&lt;h3 id=&quot;浏览器端读取cookie&quot;&gt;&lt;a href=&quot;#浏览器端读取cookie&quot; class=&quot;headerlink&quot; title=&quot;浏览器端读取cookie&quot;&gt;&lt;/a&gt;浏览器端读取cookie&lt;/h3&gt;&lt;p&gt;JS原生方法：&lt;br&gt;&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; cookies = &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.cookie;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;读取的cookie是一个分号分隔的包含所有cookie键值字符串，可以通过正则表达式来提取需要的cookie&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; cookieA = &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.cookie.replace(&lt;span class=&quot;regexp&quot;&gt;/(?:(?:^|.*;\s*)cookieA\s*\=\s*([^;]*).*$)|^.*$/&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;$1&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;request-cookie-浏览器端设置cookie&quot;&gt;&lt;a href=&quot;#request-cookie-浏览器端设置cookie&quot; class=&quot;headerlink&quot; title=&quot;request cookie 浏览器端设置cookie&quot;&gt;&lt;/a&gt;request cookie 浏览器端设置cookie&lt;/h3&gt;&lt;figure class=&quot;highlight coffeescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.cookie = &lt;span class=&quot;string&quot;&gt;&#39;cookie_example=123&#39;&lt;/span&gt;+&lt;span class=&quot;string&quot;&gt;&#39;;expires=&#39;&lt;/span&gt;+expire+&lt;span class=&quot;string&quot;&gt;&#39;;path=/&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果要设置多个cookie，多次调用&lt;code&gt;document.cookie&lt;/code&gt;即可&lt;/p&gt;
&lt;h4 id=&quot;document-cookie&quot;&gt;&lt;a href=&quot;#document-cookie&quot; class=&quot;headerlink&quot; title=&quot;document.cookie&quot;&gt;&lt;/a&gt;document.cookie&lt;/h4&gt;&lt;p&gt;这个document的behavior有点奇怪，明明返回的是个字符串，本来以为每次设置cookie得用新的字符串连接旧的字符串，但其实直接等于新的值也并不会覆盖旧的值，不知道实现这个属性&amp;amp;方法混用的原理是什么0,0&lt;/p&gt;
&lt;p&gt;####NOTE&lt;br&gt;通常设置cookie的时候都会把path设置为&lt;code&gt;/&lt;/code&gt;，这样同一个域名下，所有路径都共用一个cookie&lt;br&gt;如果没有设置path，某些框架可能默认会使用创建cookie时的路径作为path，这样就可能存在多个path不同的同名cookie。&lt;/p&gt;
&lt;p&gt;####工具&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在浏览器端，可以使用chrome的扩展&lt;em&gt;EditThisCookie&lt;/em&gt;来查看和编辑cookie&lt;/li&gt;
&lt;li&gt;如果是从服务器端写入的cookie，可以在F12 network 选项卡中选中请求，有cookie的时候会有一个cookie选项，能看到request cookie和response cookie&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;http协议什么的，不知道跟通信有没有关系…作为一个通信科班出身的硬&lt;del&gt;汉&lt;/del&gt;妹，对各种协议基本上只能说出名字，别的一窍不通=，= 所以当我知道cookie原来是在header里的时候，当时我就震惊了…&lt;/p&gt;
&lt;p&gt;在服务器端，各种框架都已经包装好了方便设置
    
    </summary>
    
    
      <category term="cookie" scheme="http://sabrinaluo.com/tech/tags/cookie/"/>
    
  </entry>
  
  <entry>
    <title>jQuery中利用JSONP进行跨域GET请求</title>
    <link href="http://sabrinaluo.com/tech/2016/02/17/using-jQuery-to-handle-CORS-with-jsonp/"/>
    <id>http://sabrinaluo.com/tech/2016/02/17/using-jQuery-to-handle-CORS-with-jsonp/</id>
    <published>2016-02-17T04:31:55.000Z</published>
    <updated>2016-04-21T10:01:55.391Z</updated>
    
    <content type="html">&lt;p&gt;每次遇到跨域的问题真是！@#￥%&lt;/p&gt;
&lt;p&gt;我对&lt;code&gt;JSONP&lt;/code&gt;的一些浅显的理解就是，有时候会看到类似&lt;code&gt;http://xxx.xx.com/?callback=xxx&lt;/code&gt;这样的请求（&lt;code&gt;callback=&lt;/code&gt;也可能是&lt;code&gt;jsonp=&lt;/code&gt;也可能是&lt;code&gt;jsonpcallback=&lt;/code&gt;，这个取决于服务器端是怎么实现jsonp的），这样的请求做的事情简单的来说就是等得到所有数据之后就执行回调函数。&lt;/p&gt;
&lt;p&gt;由于这个回调函数已经发给了服务器，返回的结果其实是一个函数，函数的入参是获取的数据。&lt;/p&gt;
&lt;p&gt;jQuery的ajax请求其实能很简单的在客户端进行跨域GET请求，具体如下：&lt;br&gt;&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; options = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  url: &#39;http://xx.xx.com/xxx&#39;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;method&lt;/span&gt;: &#39;&lt;span class=&quot;type&quot;&gt;GET&lt;/span&gt;&#39;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  dataType: &#39;jsonp&#39;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //jsonp: &#39;callback&#39;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  success: function(data)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; something here;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$.ajax(options);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其中需要注意的是，一定要声明&lt;strong&gt;&lt;code&gt;dataType&lt;/code&gt;&lt;/strong&gt;，然后把回调函数写在success后面就可以了。&lt;br&gt;另外一开始提到，服务器端对jsonp的实现可能不同，所以在&lt;code&gt;options&lt;/code&gt;中，有时候需要声明&lt;code&gt;jsonp&lt;/code&gt;对应的字符串，默认是&lt;code&gt;&amp;quot;callback&amp;quot;&lt;/code&gt;。例如：如果服务器实现jsonp是通过&lt;code&gt;http://xxx.xx.com/?jsonpcallback=xxx&lt;/code&gt;，那么就需要在&lt;code&gt;options&lt;/code&gt;中声明&lt;code&gt;jsonp:&amp;#39;jsonpcallback&amp;#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;原理据说和&lt;code&gt;&amp;lt;script src=&amp;quot;...&amp;quot;&amp;gt;&lt;/code&gt;差不多，我现在还不是很明白=，=&lt;/p&gt;
&lt;p&gt;参考&lt;br&gt;&lt;a href=&quot;http://www.runoob.com/json/json-jsonp.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.runoob.com/json/json-jsonp.html&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;每次遇到跨域的问题真是！@#￥%&lt;/p&gt;
&lt;p&gt;我对&lt;code&gt;JSONP&lt;/code&gt;的一些浅显的理解就是，有时候会看到类似&lt;code&gt;http://xxx.xx.com/?callback=xxx&lt;/code&gt;这样的请求（&lt;code&gt;callback=&lt;/code&gt;也可
    
    </summary>
    
    
      <category term="CORS" scheme="http://sabrinaluo.com/tech/tags/CORS/"/>
    
      <category term="JSONP" scheme="http://sabrinaluo.com/tech/tags/JSONP/"/>
    
      <category term="jQuery" scheme="http://sabrinaluo.com/tech/tags/jQuery/"/>
    
      <category term="跨域" scheme="http://sabrinaluo.com/tech/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>谷歌地图 Google Map API 初体验</title>
    <link href="http://sabrinaluo.com/tech/2016/02/03/experiencing-google-map-js-api/"/>
    <id>http://sabrinaluo.com/tech/2016/02/03/experiencing-google-map-js-api/</id>
    <published>2016-02-03T10:32:51.000Z</published>
    <updated>2016-04-21T10:01:55.391Z</updated>
    
    <content type="html">&lt;p&gt;一直都想把自己去过的地方做个地图标记，然而现在能找到的各种现成的地图产品都不太喜欢，所以就用谷歌地图自己写了一个。&lt;br&gt;总结以下常见的问题和坑：&lt;/p&gt;
&lt;h3 id=&quot;自动缩放-auto-zoom&quot;&gt;&lt;a href=&quot;#自动缩放-auto-zoom&quot; class=&quot;headerlink&quot; title=&quot;自动缩放(auto zoom)&quot;&gt;&lt;/a&gt;自动缩放(auto zoom)&lt;/h3&gt;&lt;p&gt;使用场景大多数时候是有很多marker，想要全部显示这些marker，同时zoom当然越大越清晰。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先需要一个marker的位置列表 &lt;code&gt;markerList&lt;/code&gt;，单个元素长这样&lt;code&gt;{lat:xxx,lng:xxx}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;遍历列表，把元素传入&lt;code&gt;google.maps.LatLngBounds&lt;/code&gt;实例的&lt;code&gt;extend&lt;/code&gt;方法&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; latlngbounds = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; google.maps.LatLngBounds();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;markerList.&lt;span class=&quot;keyword&quot;&gt;forEach&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(item)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  latlngbounds.extend(item);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;map.fitBounds(latlngbounds);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然而这有一个很多人提到的问题，就是缩放效果不平滑。(smooth这个词，我还是百度了smooth scroll才写的出字面意思来，我现在中文是有多差…)&lt;br&gt;这个暂时没什么解决方法，API本身就是这样的。据说谷歌本身的地图是h5的canvas绘制的，但通过API生成的地图不是同样的原理…谷歌居然自己都不用自己的API …&lt;/p&gt;
&lt;p&gt;另一个问题是，缩放&lt;strong&gt;太大力&lt;/strong&gt;怎么办？答案是，在&lt;code&gt;MapOptions&lt;/code&gt;中设置&lt;code&gt;maxZoom&lt;/code&gt;值&lt;/p&gt;
&lt;h3 id=&quot;动画效果切换&quot;&gt;&lt;a href=&quot;#动画效果切换&quot; class=&quot;headerlink&quot; title=&quot;动画效果切换&quot;&gt;&lt;/a&gt;动画效果切换&lt;/h3&gt;&lt;p&gt;API提供三种效果：&lt;code&gt;BOUNCE&lt;/code&gt; &lt;code&gt;DROP&lt;/code&gt; &lt;code&gt;NULL&lt;/code&gt;&lt;br&gt;使用场景大多数时候是在NULL和BOUNCE之间切换&lt;/p&gt;
&lt;p&gt;动画比较坑爹的是，每个动画都要持续700ms，之后才能改变状态。&lt;/p&gt;
&lt;p&gt;比如这样一个例子：有两组marker，&lt;strong&gt;有交集&lt;/strong&gt;。想要让第一组先BOUNCE，之后停止第一组，让第二组BOUNCE。很容易想到的方法是，通过遍历，把第一组的动画全部设置为NULL，再把第二组动画全部设置为BOUNCE。然而交集的这一部分只会BOUNCE一次然后就停了…因为计算速度很快，从NULL到BOUNCE不到700ms，动画其实还处于NULL状态。&lt;/p&gt;
&lt;p&gt;可以参考官方的这个例子，&lt;a href=&quot;https://developers.google.com/maps/documentation/javascript/examples/marker-animations&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developers.google.com/maps/documentation/javascript/examples/marker-animations&lt;/a&gt; ，当你双击marker的时候，其实就是模拟了快速切换状态，但动画效果并不如预期…&lt;/p&gt;
&lt;p&gt;解决方案：求差集，也就是把交集的部分去掉，在设置动画为NULL&lt;/p&gt;
&lt;h3 id=&quot;自定义地图样式&quot;&gt;&lt;a href=&quot;#自定义地图样式&quot; class=&quot;headerlink&quot; title=&quot;自定义地图样式&quot;&gt;&lt;/a&gt;自定义地图样式&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://snazzymaps.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://snazzymaps.com/&lt;/a&gt; 这个网站有很多已经设计好的样式，选喜欢的直接复制代码放到&lt;code&gt;StyledMapType()&lt;/code&gt;方法中即可，然后给这个样式取个名字，下例中我使用了&lt;a href=&quot;https://snazzymaps.com/style/134/light-dream&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;light dream&lt;/a&gt; 这个样式&lt;br&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; mapStyle = &lt;span class=&quot;built_in&quot;&gt;new&lt;/span&gt; google.maps.StyledMapType([....])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;map&lt;/span&gt;.mapTypes.set(&lt;span class=&quot;string&quot;&gt;&#39;lightDream&#39;&lt;/span&gt;, mapStyle);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;map&lt;/span&gt;.setMapTypeId(&lt;span class=&quot;string&quot;&gt;&#39;lightDream&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;遍历添加-event-listener-同时又需要传参数给-google-maps-event-addListener-的回调函数&quot;&gt;&lt;a href=&quot;#遍历添加-event-listener-同时又需要传参数给-google-maps-event-addListener-的回调函数&quot; class=&quot;headerlink&quot; title=&quot;遍历添加 event listener 同时又需要传参数给 google.maps.event.addListener() 的回调函数&quot;&gt;&lt;/a&gt;遍历添加 event listener 同时又需要传参数给 &lt;code&gt;google.maps.event.addListener()&lt;/code&gt; 的回调函数&lt;/h3&gt;&lt;p&gt;不太理解event.addListener的工作原理，但根据我踩的坑推测这是一个异步的方法（否则为什么有回调函数？！）&lt;/p&gt;
&lt;p&gt;这个时候就要用到高大上的&lt;strong&gt;闭包&lt;/strong&gt;。下面这个例子中，如果不把&lt;code&gt;addListener&lt;/code&gt;包起来，每次cityHandler收到的city都是遍历的最后一个city。因为遍历速度太快，而回调还没有执行，等回调执行的时候city已经遍历到最后一个了…&lt;/p&gt;
&lt;p&gt;不用闭包的话，用promise应该也能解决这个问题，但是感觉promise需要写的code会比较多一些。&lt;/p&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; cityList=[&amp;#123;marker:googleMapMarker,city:&lt;span class=&quot;string&quot;&gt;&#39;Beijing&#39;&lt;/span&gt;&amp;#125;,...];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cityList.&lt;span class=&quot;keyword&quot;&gt;forEach&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(item)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(marker, city)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    google.maps.event.addListener(marker, &lt;span class=&quot;string&quot;&gt;&#39;click&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(e)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      cityHandler(city);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;)(item.marker, item.city)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;原生marker图标&quot;&gt;&lt;a href=&quot;#原生marker图标&quot; class=&quot;headerlink&quot; title=&quot;原生marker图标&quot;&gt;&lt;/a&gt;原生marker图标&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://mabp.kiev.ua/2010/01/12/google-map-markers/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://mabp.kiev.ua/2010/01/12/google-map-markers/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;参考：&quot;&gt;&lt;a href=&quot;#参考：&quot; class=&quot;headerlink&quot; title=&quot;参考：&quot;&gt;&lt;/a&gt;参考：&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://developers.google.com/maps/documentation/javascript/reference&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developers.google.com/maps/documentation/javascript/reference&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;一直都想把自己去过的地方做个地图标记，然而现在能找到的各种现成的地图产品都不太喜欢，所以就用谷歌地图自己写了一个。&lt;br&gt;总结以下常见的问题和坑：&lt;/p&gt;
&lt;h3 id=&quot;自动缩放-auto-zoom&quot;&gt;&lt;a href=&quot;#自动缩放-auto-zoom&quot; class=&quot;he
    
    </summary>
    
    
      <category term="Google Map" scheme="http://sabrinaluo.com/tech/tags/Google-Map/"/>
    
      <category term="Google Map API" scheme="http://sabrinaluo.com/tech/tags/Google-Map-API/"/>
    
      <category term="谷歌地图" scheme="http://sabrinaluo.com/tech/tags/%E8%B0%B7%E6%AD%8C%E5%9C%B0%E5%9B%BE/"/>
    
      <category term="谷歌地图API" scheme="http://sabrinaluo.com/tech/tags/%E8%B0%B7%E6%AD%8C%E5%9C%B0%E5%9B%BEAPI/"/>
    
  </entry>
  
  <entry>
    <title>git如何ignore已经track的文件</title>
    <link href="http://sabrinaluo.com/tech/2016/02/01/git-how-to-ignore-tracked-files/"/>
    <id>http://sabrinaluo.com/tech/2016/02/01/git-how-to-ignore-tracked-files/</id>
    <published>2016-02-01T06:01:03.000Z</published>
    <updated>2016-04-21T10:01:55.391Z</updated>
    
    <content type="html">&lt;p&gt;我也不想中英文混杂的取标题……但我实在翻译无能…_(:з」∠)_&lt;/p&gt;
&lt;h3 id=&quot;基本知识&quot;&gt;&lt;a href=&quot;#基本知识&quot; class=&quot;headerlink&quot; title=&quot;基本知识&quot;&gt;&lt;/a&gt;基本知识&lt;/h3&gt;&lt;p&gt;在git中文件有两类，共三种状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;untracked&lt;/li&gt;
&lt;li&gt;tracked&lt;ul&gt;
&lt;li&gt;changes not staged for commit&lt;/li&gt;
&lt;li&gt;changes to be committed&lt;br&gt;我们都知道，在&lt;code&gt;.gitignore&lt;/code&gt;文件里添加相应的文件夹或文件就能忽略掉不想被track的文件。&lt;br&gt;但是，&lt;code&gt;.gitignore&lt;/code&gt;文件只能忽略&lt;strong&gt;Untracked files&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;适用场景&quot;&gt;&lt;a href=&quot;#适用场景&quot; class=&quot;headerlink&quot; title=&quot;适用场景&quot;&gt;&lt;/a&gt;适用场景&lt;/h3&gt;&lt;p&gt;参考这样一个例子：&lt;br&gt;一个项目因为一些莫名其妙的原因对&lt;code&gt;node_modules&lt;/code&gt;文件夹进行了track，然后每次check out出来&lt;code&gt;npm install&lt;/code&gt;的时候，很可能这些依赖包就更新了，然后又因为一些莫名其妙的原因，始终没有人把这个文件夹移出git的index，于是你也不好意思删除这个文件夹做一次commit。然而，每次都有几十上百条&lt;code&gt;modified: node_modules/xxx&lt;/code&gt;，根本找不到自己真正修改和添加的文件…&lt;/p&gt;
&lt;p&gt;于是问题来了，怎么样才能把&lt;code&gt;node_module&lt;/code&gt; ignore，但又不commit这些change呢？&lt;/p&gt;
&lt;h3 id=&quot;解决方法&quot;&gt;&lt;a href=&quot;#解决方法&quot; class=&quot;headerlink&quot; title=&quot;解决方法&quot;&gt;&lt;/a&gt;解决方法&lt;/h3&gt;&lt;p&gt;正常情况，跑以下的命令就能忽略掉已经track的&lt;strong&gt;文件夹&lt;/strong&gt;：&lt;br&gt;&lt;figure class=&quot;highlight vim&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;keyword&quot;&gt;ls&lt;/span&gt;-&lt;span class=&quot;keyword&quot;&gt;files&lt;/span&gt; -&lt;span class=&quot;keyword&quot;&gt;z&lt;/span&gt; node_modules/ | xargs -&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; git &lt;span class=&quot;keyword&quot;&gt;update&lt;/span&gt;-&lt;span class=&quot;built_in&quot;&gt;index&lt;/span&gt; --assume-unchanged&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果只需要忽略&lt;strong&gt;单个文件&lt;/strong&gt;，则以下命令就能搞定。&lt;br&gt;&lt;figure class=&quot;highlight fortran&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git update-&lt;span class=&quot;built_in&quot;&gt;index&lt;/span&gt; --assume-unchanged &amp;lt;&lt;span class=&quot;keyword&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;因为update-index不支持递归&lt;code&gt;-r&lt;/code&gt;，所以只能通过上面提到的方法来实现忽略文件夹&lt;br&gt;（憋问我为什么不支持…我也不知道）&lt;/p&gt;
&lt;h3 id=&quot;另一种情况：将tracked文件移出index，但仍然保留在本地&quot;&gt;&lt;a href=&quot;#另一种情况：将tracked文件移出index，但仍然保留在本地&quot; class=&quot;headerlink&quot; title=&quot;另一种情况：将tracked文件移出index，但仍然保留在本地&quot;&gt;&lt;/a&gt;另一种情况：将tracked文件移出index，但仍然保留在本地&lt;/h3&gt;&lt;p&gt;终于有一天，大家想通了，决定将&lt;code&gt;node_modules&lt;/code&gt;文件夹移出git index，但是如果删除了整个文件夹commit之后，项目要跑起来，又要重新&lt;code&gt;npm install&lt;/code&gt;，懒癌患者倒地不起…&lt;/p&gt;
&lt;p&gt;下面这个命令可以解决上述问题：&lt;br&gt;&lt;figure class=&quot;highlight applescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git rm &lt;span class=&quot;comment&quot;&gt;--cached -r node_modules&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;吐槽&quot;&gt;&lt;a href=&quot;#吐槽&quot; class=&quot;headerlink&quot; title=&quot;吐槽&quot;&gt;&lt;/a&gt;吐槽&lt;/h3&gt;&lt;p&gt;我反正是无法理解把诸如npm包，bower包，composer包等等等的第三方依赖放到git里去track，那么还要package.json干啥=，=&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;我也不想中英文混杂的取标题……但我实在翻译无能…_(:з」∠)_&lt;/p&gt;
&lt;h3 id=&quot;基本知识&quot;&gt;&lt;a href=&quot;#基本知识&quot; class=&quot;headerlink&quot; title=&quot;基本知识&quot;&gt;&lt;/a&gt;基本知识&lt;/h3&gt;&lt;p&gt;在git中文件有两类，共三种状态：&lt;/p&gt;

    
    </summary>
    
    
      <category term="git" scheme="http://sabrinaluo.com/tech/tags/git/"/>
    
      <category term="gitignore" scheme="http://sabrinaluo.com/tech/tags/gitignore/"/>
    
      <category term="update index" scheme="http://sabrinaluo.com/tech/tags/update-index/"/>
    
  </entry>
  
  <entry>
    <title>Promise的顺序执行和并行执行</title>
    <link href="http://sabrinaluo.com/tech/2016/01/23/excecute-parallel-promise-and-sequential-promise/"/>
    <id>http://sabrinaluo.com/tech/2016/01/23/excecute-parallel-promise-and-sequential-promise/</id>
    <published>2016-01-23T14:52:26.000Z</published>
    <updated>2016-04-21T10:01:55.391Z</updated>
    
    <content type="html">&lt;p&gt;并行和顺序执行的前提当然是，有一堆promise等着你去执行……&lt;br&gt;通常我们把这“一堆”promise对象放到一个数组里，&lt;code&gt;[promise1, promise2, promise3, ...]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们都知道想要让promise按顺序执行，那就是一个接一个的then。然而手写很多then太累了，而嵌套的promise又是反模式，我之前蠢蠢的&lt;a href=&quot;tech/2016/01/18/sequentialize-promise-by-recursion/&quot;&gt;用递归解决了顺序执行的问题&lt;/a&gt;，后来终于在udacity习得了顺序promise的正确打开方式！&lt;/p&gt;
&lt;h3 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h3&gt;&lt;p&gt;假如我们要去拿github按关键字搜索google, amazon, facebook，每个关键字搜出的第一个用户的第一个repo的名字。&lt;br&gt;单独拿一个，比如google，过程是这样的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;请求&lt;a href=&quot;https://api.github.com/search/users?q=google&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://api.github.com/search/users?q=google&lt;/a&gt; ，得到用户列表，读取第一个用户的repos_url&lt;/li&gt;
&lt;li&gt;请求上一步读取的repous_url，获得repo列表，读取第一个repo的名字&lt;br&gt;显然，第二步是依赖于第一步的执行结果的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此，很容易想到下面几种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;等第一步全部执行完，再执行第二步（并行执行）&lt;/p&gt;
&lt;figure class=&quot;highlight gherkin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;|&lt;span class=&quot;string&quot;&gt;--------------------&lt;/span&gt;|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;google第一步          |&lt;span class=&quot;string&quot;&gt;------------------&lt;/span&gt;|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;amazon第一步        google第二步&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;facebook第一步      amazon第二步 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                   facebook第二步&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对第一步的顺序有要求，必须严格按照google, amazon, facebook的顺序执行（顺序执行）&lt;/p&gt;
&lt;figure class=&quot;highlight gherkin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;|&lt;span class=&quot;string&quot;&gt;---------&lt;/span&gt;|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;google1   |&lt;span class=&quot;string&quot;&gt;---------&lt;/span&gt;|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            google2 |&lt;span class=&quot;string&quot;&gt;---------&lt;/span&gt;|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     amazon1  |&lt;span class=&quot;string&quot;&gt;---------&lt;/span&gt;|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                              amazon2   |&lt;span class=&quot;string&quot;&gt;---------&lt;/span&gt;|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                        facebook1 |&lt;span class=&quot;string&quot;&gt;--------&lt;/span&gt;|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                  facebook2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;google1执行完就执行google1，amazon1执行完就执行amazon2，但对google, amazon, facebook的顺序没有要求&lt;/p&gt;
&lt;figure class=&quot;highlight gherkin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;|&lt;span class=&quot;string&quot;&gt;------------------&lt;/span&gt;|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;google1            |&lt;span class=&quot;string&quot;&gt;-------------&lt;/span&gt;|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                   google2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|&lt;span class=&quot;string&quot;&gt;---------&lt;/span&gt;|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;amazon1   |&lt;span class=&quot;string&quot;&gt;-----------&lt;/span&gt;|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          amazon2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|&lt;span class=&quot;string&quot;&gt;------------&lt;/span&gt;|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;facebook1    |&lt;span class=&quot;string&quot;&gt;-------------&lt;/span&gt;|&lt;span class=&quot;string&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             facebook2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Promise并行执行&quot;&gt;&lt;a href=&quot;#Promise并行执行&quot; class=&quot;headerlink&quot; title=&quot;Promise并行执行&quot;&gt;&lt;/a&gt;Promise并行执行&lt;/h3&gt;&lt;p&gt;对于场景1，主要就是用到&lt;code&gt;Promise.all&lt;/code&gt;，因为是数组，所以在处理的过程中通常会用到&lt;code&gt;.map&lt;/code&gt;或&lt;code&gt;.forEach&lt;/code&gt;&lt;br&gt;&lt;iframe width=&quot;100%&quot; height=&quot;300&quot; src=&quot;http://jsfiddle.net/HiiTea/zfjvr4pz/1/embedded/js,resources,html,css,result/light&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;br&gt;&lt;img src=&quot;http://7xow88.com1.z0.glb.clouddn.com/tech-promise1.png&quot; alt=&quot;promise例1网络请求时间线&quot;&gt;&lt;br&gt;可以看到3个user请求是同时进行（并行），3个repos请求也是同时进行（并行），由于使用了&lt;code&gt;Promise.all&lt;/code&gt;，所以repos请求等待users请求全部完成才开始。&lt;/p&gt;
&lt;h3 id=&quot;promise顺序执行的正确打开方式&quot;&gt;&lt;a href=&quot;#promise顺序执行的正确打开方式&quot; class=&quot;headerlink&quot; title=&quot;promise顺序执行的正确打开方式&quot;&gt;&lt;/a&gt;promise顺序执行的正确打开方式&lt;/h3&gt;&lt;p&gt;对于场景2，有一个小技巧，我第一次看到的时候感受是…惊为天人&lt;br&gt;按照顺序执行，容易想到的有以下几种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;then.then.then，从头then到尾…&lt;/li&gt;
&lt;li&gt;then(then(then()))，then的嵌套…&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;promise链的本质其实就是从头then到尾，但是第一种方法怎么用程序来实现，也就是上面提到的小技巧，就是值得学习的地方了。（反正我觉得太巧妙了！！！我自己就想不到…）&lt;/p&gt;
&lt;p&gt;大概跟在做求和运算时候的思想一样：&lt;br&gt;&lt;figure class=&quot;highlight fortran&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//求和的时候通常这么做，先定义一个&lt;span class=&quot;built_in&quot;&gt;sum&lt;/span&gt;，然后依次往里做加法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var &lt;span class=&quot;built_in&quot;&gt;sum&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;array.forEach(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(item)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;sum&lt;/span&gt; = &lt;span class=&quot;built_in&quot;&gt;sum&lt;/span&gt; + item;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight fortran&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//要得到一个&lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;的promise链，先定义一个已经resolve了的promise，然后依次往后&lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;…&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var &lt;span class=&quot;keyword&quot;&gt;sequence&lt;/span&gt; = Promise.resolve();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;array.forEach(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(item)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;sequence&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;sequence&lt;/span&gt;.&lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;(...)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下面给出场景2的代码：&lt;br&gt;&lt;iframe width=&quot;100%&quot; height=&quot;300&quot; src=&quot;http://jsfiddle.net/HiiTea/sq2aga08/embedded/js,resources,html,css,result/light&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;br&gt;&lt;img src=&quot;http://7xow88.com1.z0.glb.clouddn.com/tech-promise2.png&quot; alt=&quot;promise例2网络请求时间线&quot;&gt;&lt;br&gt;可以看到请求是按顺序依次发出&lt;/p&gt;
&lt;h3 id=&quot;并行执行和顺序执行混用&quot;&gt;&lt;a href=&quot;#并行执行和顺序执行混用&quot; class=&quot;headerlink&quot; title=&quot;并行执行和顺序执行混用&quot;&gt;&lt;/a&gt;并行执行和顺序执行混用&lt;/h3&gt;&lt;p&gt;场景3:&lt;br&gt;&lt;iframe width=&quot;100%&quot; height=&quot;300&quot; src=&quot;http://jsfiddle.net/HiiTea/z09xjowq/1/embedded/js,resources,html,css,result/light&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;br&gt;&lt;img src=&quot;http://7xow88.com1.z0.glb.clouddn.com/tech-promise3.png&quot; alt=&quot;promise例3网络请求时间线&quot;&gt;&lt;br&gt;可以看到users请求是并行发出，但完成时间不一样，而repos请求是在&lt;strong&gt;对应的&lt;/strong&gt;users请求完成后就立即执行&lt;/p&gt;
&lt;h3 id=&quot;混用的另一种情况&quot;&gt;&lt;a href=&quot;#混用的另一种情况&quot; class=&quot;headerlink&quot; title=&quot;混用的另一种情况&quot;&gt;&lt;/a&gt;混用的另一种情况&lt;/h3&gt;&lt;p&gt;有了以上的知识，很容易写出最后一种混用的情况，users按顺序执行，等users全部执行完之后并发执行repos。我比较懒…这个我就不写了…&lt;/p&gt;
&lt;h3 id=&quot;补充知识：&quot;&gt;&lt;a href=&quot;#补充知识：&quot; class=&quot;headerlink&quot; title=&quot;补充知识：&quot;&gt;&lt;/a&gt;补充知识：&lt;/h3&gt;&lt;h4 id=&quot;浏览器的fetch-API&quot;&gt;&lt;a href=&quot;#浏览器的fetch-API&quot; class=&quot;headerlink&quot; title=&quot;浏览器的fetch API&quot;&gt;&lt;/a&gt;浏览器的fetch API&lt;/h4&gt;&lt;p&gt;本文跟fetch不是充分必要关系，只是我太懒了不想写太多的代码来举例。你可以把它理解为是用Promise包住的&lt;code&gt;$.ajax&lt;/code&gt;，也就是fetch返回一个promise对象。关于fetch的详细用法请参考&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MDN Fetch_ API&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;如何查看请求的发送是并行还是顺序&quot;&gt;&lt;a href=&quot;#如何查看请求的发送是并行还是顺序&quot; class=&quot;headerlink&quot; title=&quot;如何查看请求的发送是并行还是顺序&quot;&gt;&lt;/a&gt;如何查看请求的发送是并行还是顺序&lt;/h4&gt;&lt;p&gt;打开chrome，按F12，选中Network选项卡，在No throttling这个下拉列表选GPRS，再运行代码，然后就能清楚的看到各个请求的时间线了。&lt;/p&gt;
&lt;p&gt;如果看到的区别不是很明显，很可能是已经缓存了，清空浏览器的缓存在重复上面的步骤就能看到比较明显的区别了。&lt;/p&gt;
&lt;h3 id=&quot;参考：&quot;&gt;&lt;a href=&quot;#参考：&quot; class=&quot;headerlink&quot; title=&quot;参考：&quot;&gt;&lt;/a&gt;参考：&lt;/h3&gt;&lt;p&gt;[1] &lt;a href=&quot;https://www.udacity.com/course/viewer#!/c-ud898&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.udacity.com/course/viewer#!/c-ud898&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;并行和顺序执行的前提当然是，有一堆promise等着你去执行……&lt;br&gt;通常我们把这“一堆”promise对象放到一个数组里，&lt;code&gt;[promise1, promise2, promise3, ...]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们都知道想要让promise按顺序
    
    </summary>
    
    
      <category term="Promise" scheme="http://sabrinaluo.com/tech/tags/Promise/"/>
    
      <category term="parallel" scheme="http://sabrinaluo.com/tech/tags/parallel/"/>
    
      <category term="sequential" scheme="http://sabrinaluo.com/tech/tags/sequential/"/>
    
      <category term="顺序执行，并行执行" scheme="http://sabrinaluo.com/tech/tags/%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%EF%BC%8C%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>对浏览器跨域问题的一些理解</title>
    <link href="http://sabrinaluo.com/tech/2016/01/22/understanding-of-CORS/"/>
    <id>http://sabrinaluo.com/tech/2016/01/22/understanding-of-CORS/</id>
    <published>2016-01-22T07:08:33.000Z</published>
    <updated>2016-04-21T10:01:55.391Z</updated>
    
    <content type="html">&lt;h3 id=&quot;问题宝宝&quot;&gt;&lt;a href=&quot;#问题宝宝&quot; class=&quot;headerlink&quot; title=&quot;问题宝宝&quot;&gt;&lt;/a&gt;问题宝宝&lt;/h3&gt;&lt;h4 id=&quot;1-移动应用开发&quot;&gt;&lt;a href=&quot;#1-移动应用开发&quot; class=&quot;headerlink&quot; title=&quot;1 移动应用开发&quot;&gt;&lt;/a&gt;1 移动应用开发&lt;/h4&gt;&lt;p&gt;之前用Ionic写mobile app，移动app自然是少不了调用RESTful API的数据。&lt;br&gt;开发的时候用浏览器进行调试，然后console里不停的出现下面的提示(&lt;strong&gt;Access-Control-Allow-Origin&lt;/strong&gt;)：&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;XMLHttpRequest cannot &lt;span class=&quot;operator&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;load&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;http&lt;/span&gt;://samlino.&lt;span class=&quot;keyword&quot;&gt;local&lt;/span&gt;/cag/get_leads. &lt;span class=&quot;keyword&quot;&gt;No&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;Access-Control-Allow-Origin&#39;&lt;/span&gt; header &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;present&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;on&lt;/span&gt; the requested &lt;span class=&quot;keyword&quot;&gt;resource&lt;/span&gt;. Origin &lt;span class=&quot;string&quot;&gt;&#39;http://localhost:63342&#39;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; therefore &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; allowed &lt;span class=&quot;keyword&quot;&gt;access&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;而我当时的解决方法是，在chrome装了一个叫&lt;a href=&quot;https://chrome.google.com/webstore/detail/allow-control-allow-origi/nlfbmbojpeacfghkpbjhddihlkkiljbi&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Allow-Control-Allow-Origin&lt;/a&gt;的扩展，启用之后就不报错了。&lt;/p&gt;
&lt;p&gt;也不知道什么什么原理，反正就这么一直用着。（不思进取）&lt;/p&gt;
&lt;h4 id=&quot;2-网络应用开发&quot;&gt;&lt;a href=&quot;#2-网络应用开发&quot; class=&quot;headerlink&quot; title=&quot;2 网络应用开发&quot;&gt;&lt;/a&gt;2 网络应用开发&lt;/h4&gt;&lt;p&gt;后来写单页应用（SPA），静态文件的js里调用各大公司的API， github、facebook什么的，反正从来没有报过上面的错…&lt;br&gt;另外还写过用NodeJS做中间层，从NodeJS去API拿数据然后渲染再发到前端，也从来没报过错…&lt;/p&gt;
&lt;p&gt;最近的一个case是，我们有用AWS API Gateway, Lambda, DynamoDB搭建的API，API被调用的时候就会trigger一系列的任务。然后有个小哥偷懒不想写PHP，想在前端直接请求AWS的API。于是问题来了…&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浏览器不停的提示No ‘Access-Control-Allow-Origin’的错误， 拿不到任何返回的数据。&lt;/li&gt;
&lt;li&gt;但是！服务器该做的job却都做了！&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这根本不科学啊！！！所以？到底是什么鬼？！&lt;/p&gt;
&lt;h3 id=&quot;同源策略-Same-Origin-Policy&quot;&gt;&lt;a href=&quot;#同源策略-Same-Origin-Policy&quot; class=&quot;headerlink&quot; title=&quot;同源策略(Same Origin Policy)&quot;&gt;&lt;/a&gt;同源策略(Same Origin Policy)&lt;/h3&gt;&lt;p&gt;同源策略就是只有访问的内容来自&lt;strong&gt;相同协议、相同主机、相同端口&lt;/strong&gt;的内容&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;^1&lt;/a&gt;时，才会加载访问得到的内容。&lt;strong&gt;浏览器是同源策略的一种实现&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;协议：&lt;code&gt;location.protocol&lt;/code&gt;，http和https是两种不同的协议&lt;/li&gt;
&lt;li&gt;主机：&lt;code&gt;location.host&lt;/code&gt;，不同子域名之间都算跨域，例如www.baidu.com, tieba.baidu.com是两个不同的源&lt;/li&gt;
&lt;li&gt;端口：&lt;code&gt;location.port&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;CORS&quot;&gt;&lt;a href=&quot;#CORS&quot; class=&quot;headerlink&quot; title=&quot;CORS&quot;&gt;&lt;/a&gt;CORS&lt;/h3&gt;&lt;p&gt;之前脑子里大概有个&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CORS&lt;/a&gt;的概念，然后一直以为是服务器拒绝从浏览器跨域访问…因为要解决自己call自己不同域名下的API问题，就是去服务器设置一下header…但其实是都是浏览器在作怪…&lt;/p&gt;
&lt;p&gt;在浏览器中，允许跨域访问的资源的一些例子&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy#Cross-origin_network_access&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;^2&lt;/a&gt;：&lt;br&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;...&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;br&gt;&lt;code&gt;&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;...&amp;quot;&amp;gt;&lt;/code&gt;&lt;br&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;br&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;br&gt;&lt;code&gt;@font-face&lt;/code&gt;&lt;br&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;Response-Headers&quot;&gt;&lt;a href=&quot;#Response-Headers&quot; class=&quot;headerlink&quot; title=&quot;Response Headers&quot;&gt;&lt;/a&gt;Response Headers&lt;/h3&gt;&lt;p&gt;先看看可以在浏览器中跨域请求的别人家(github)的API返回的header：&lt;br&gt;&lt;figure class=&quot;highlight tp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Access-Control-Allow-Credentials:true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Access-Control-Allow-Origin:*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Access-Control-Expose-Headers:ETag, Link, &lt;span class=&quot;keyword&quot;&gt;X&lt;/span&gt;-GitHub-OTP, &lt;span class=&quot;keyword&quot;&gt;X&lt;/span&gt;-RateLimit-Limit, &lt;span class=&quot;keyword&quot;&gt;X&lt;/span&gt;-RateLimit-Remaining, &lt;span class=&quot;keyword&quot;&gt;X&lt;/span&gt;-RateLimit-Reset, &lt;span class=&quot;keyword&quot;&gt;X&lt;/span&gt;-OAuth-Scopes, &lt;span class=&quot;keyword&quot;&gt;X&lt;/span&gt;-Accepted-OAuth-Scopes, &lt;span class=&quot;keyword&quot;&gt;X&lt;/span&gt;-Poll-Interval&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;看看自家API返回的header&lt;br&gt;&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;Connection&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:keep-alive&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;Content&lt;/span&gt;-&lt;span class=&quot;constant&quot;&gt;Encoding&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:gzip&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;Content&lt;/span&gt;-&lt;span class=&quot;constant&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:text/html&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:Fri&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;22&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;Jan&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2016&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;07&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;07&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;01&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;GMT&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;差别就在于别人家的API返回了&lt;strong&gt;Access-Control-Allow-Origin:*&lt;/strong&gt;&lt;br&gt;浏览器读到这个头部之后，才会加载请求的结果。&lt;/p&gt;
&lt;h3 id=&quot;跨域的时候服务器收到请求了吗？&quot;&gt;&lt;a href=&quot;#跨域的时候服务器收到请求了吗？&quot; class=&quot;headerlink&quot; title=&quot;跨域的时候服务器收到请求了吗？&quot;&gt;&lt;/a&gt;跨域的时候服务器收到请求了吗？&lt;/h3&gt;&lt;p&gt;服务器当然收到请求了，不然怎么能返回头部…而且我上面举的诡异的例子中，请求trigger的job都完成了。&lt;/p&gt;
&lt;p&gt;所以也就是说，服务器其实收到了你的请求，并且给你返回了全部的数据，但是浏览器看到头部就把body藏起来了，然后抛出错误提示…&lt;/p&gt;
&lt;h3 id=&quot;为什么浏览器不允许跨域访问？&quot;&gt;&lt;a href=&quot;#为什么浏览器不允许跨域访问？&quot; class=&quot;headerlink&quot; title=&quot;为什么浏览器不允许跨域访问？&quot;&gt;&lt;/a&gt;为什么浏览器不允许跨域访问？&lt;/h3&gt;&lt;p&gt;当然是为了安全……但是这个有点不太好理解，api拿点数据有什么不安全的？！&lt;/p&gt;
&lt;p&gt;下面这个例子比较清楚的说明同源策略是如何避免安全问题的：&lt;a href=&quot;http://stackoverflow.com/questions/9222822/why-do-browser-apis-restrict-cross-domain-requests&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;^3&lt;/a&gt;&lt;br&gt;网站A：一个看起来跟银行网站几乎一样的假网站&lt;br&gt;网站B：真正的银行网站&lt;br&gt;如果没有同源策略：&lt;br&gt;1.当用户来到A网站，以为是真的银行网站，然后输入自己的账号、密码（此时用户的账号、密码已经被网站A获取了）&lt;br&gt;2.网站A利用ajax把账号密码发到真正的银行网站B，然后银行网站返回一个带有token的form需要用户输入手机验证码。&lt;br&gt;3.网站A获得这个form之后显示出来，让用户填入手机验证码……至此，网站A获得了账号、密码、手机验证码，已经可以登陆用户的账号了。&lt;/p&gt;
&lt;p&gt;而当有同源策略时，到第2步的时候，网站A根本无法获取银行网站返回的带token的form，所以就算有了账户和密码，也无法操作用户的账户。&lt;/p&gt;
&lt;p&gt;当然啦，银行的加密机制肯定没有我描述的这么弱智，不然还要U盾之类的东东干嘛，这只是一个为了方便理解安全问题而杜撰的例子…&lt;/p&gt;
&lt;h3 id=&quot;好奇宝宝&quot;&gt;&lt;a href=&quot;#好奇宝宝&quot; class=&quot;headerlink&quot; title=&quot;好奇宝宝&quot;&gt;&lt;/a&gt;好奇宝宝&lt;/h3&gt;&lt;p&gt;不知道chrome的这个插件&lt;a href=&quot;https://chrome.google.com/webstore/detail/allow-control-allow-origi/nlfbmbojpeacfghkpbjhddihlkkiljbi&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Allow-Control-Allow-Origin&lt;/a&gt;，是怎么实现允许跨域请求的。&lt;br&gt;之前发现启用插件的时候，github上的小图标全都不显示了…&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题宝宝&quot;&gt;&lt;a href=&quot;#问题宝宝&quot; class=&quot;headerlink&quot; title=&quot;问题宝宝&quot;&gt;&lt;/a&gt;问题宝宝&lt;/h3&gt;&lt;h4 id=&quot;1-移动应用开发&quot;&gt;&lt;a href=&quot;#1-移动应用开发&quot; class=&quot;headerlink&quot; title=&quot;1
    
    </summary>
    
    
      <category term="CORS" scheme="http://sabrinaluo.com/tech/tags/CORS/"/>
    
      <category term="corss domain" scheme="http://sabrinaluo.com/tech/tags/corss-domain/"/>
    
      <category term="同源策略" scheme="http://sabrinaluo.com/tech/tags/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"/>
    
      <category term="浏览器" scheme="http://sabrinaluo.com/tech/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="跨域" scheme="http://sabrinaluo.com/tech/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>递归实现按顺序执行Promise</title>
    <link href="http://sabrinaluo.com/tech/2016/01/18/sequentialize-promise-by-recursion/"/>
    <id>http://sabrinaluo.com/tech/2016/01/18/sequentialize-promise-by-recursion/</id>
    <published>2016-01-18T09:23:18.000Z</published>
    <updated>2016-04-21T10:01:55.395Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;2016-01-24更新&lt;/strong&gt;&lt;br&gt;我还是觉得嵌套多层的promise是反模式，不推荐使用，机智的我学会了另一种不嵌套不递归的方法，请看这里：&lt;br&gt;(Promise的顺序执行和并行执行](tech/2016/01/23/excecute-parallel-promise-and-sequential-promise)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以下为原文：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之前我一直有个疑问，当我有一堆promise的时候，怎么按顺序执行它们呢？&lt;/p&gt;
&lt;p&gt;网上搜到的大多数教程都是建一个数组&lt;code&gt;array&lt;/code&gt;，把promise对象放到数组里，然后数组中的promise全部执行完毕时调用&lt;code&gt;Promise.all(array)&lt;/code&gt;。然而这只适用于数组中的&lt;strong&gt;promise对象不互相依赖&lt;/strong&gt;的情况。&lt;/p&gt;
&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;我之前提到过一个典型的例子是Facebook的Graph API 中的分页问题（ &lt;a href=&quot;https://developers.facebook.com/docs/graph-api/using-graph-api#paging&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Cursor-based Pagination&lt;/a&gt;），API的Response如下：&lt;br&gt;&lt;figure class=&quot;highlight json&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &quot;&lt;span class=&quot;attribute&quot;&gt;data&lt;/span&gt;&quot;: &lt;span class=&quot;value&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     ... Endpoint data is here&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ]&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &quot;&lt;span class=&quot;attribute&quot;&gt;paging&lt;/span&gt;&quot;: &lt;span class=&quot;value&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &quot;&lt;span class=&quot;attribute&quot;&gt;cursors&lt;/span&gt;&quot;: &lt;span class=&quot;value&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &quot;&lt;span class=&quot;attribute&quot;&gt;after&lt;/span&gt;&quot;: &lt;span class=&quot;value&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;MTAxNTExOTQ1MjAwNzI5NDE=&quot;&lt;/span&gt;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &quot;&lt;span class=&quot;attribute&quot;&gt;before&lt;/span&gt;&quot;: &lt;span class=&quot;value&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;NDMyNzQyODI3OTQw&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&amp;#125;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &quot;&lt;span class=&quot;attribute&quot;&gt;previous&lt;/span&gt;&quot;: &lt;span class=&quot;value&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;https://graph.facebook.com/me/albums?limit=25&amp;amp;amp;before=NDMyNzQyODI3OTQw&quot;&lt;/span&gt;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &quot;&lt;span class=&quot;attribute&quot;&gt;next&lt;/span&gt;&quot;: &lt;span class=&quot;value&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;https://graph.facebook.com/me/albums?limit=25&amp;amp;amp;after=MTAxNTExOTQ1MjAwNzI5NDE=&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;简单的一个例子是，当我想要获取一个人的完整好友列表（Friend List），但是这个人好友太多了，分成了很多页。显然这些结果是互相依赖的。我必须先拿到第一页的&lt;code&gt;paging.next&lt;/code&gt;，才能进行下一次请求。（别跟我说改query string &lt;code&gt;limit&lt;/code&gt;后面的值，limit是有最大限制的=，=）&lt;/p&gt;
&lt;h3 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;解决方案&lt;/h3&gt;&lt;h5 id=&quot;当知道总共有多少页的时候&quot;&gt;&lt;a href=&quot;#当知道总共有多少页的时候&quot; class=&quot;headerlink&quot; title=&quot;当知道总共有多少页的时候&quot;&gt;&lt;/a&gt;当知道总共有多少页的时候&lt;/h5&gt;&lt;p&gt;(假设request是一个返回promise对象的函数,resolve的是上面的json)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;普通程序员这么做&lt;figure class=&quot;highlight lua&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var url = &lt;span class=&quot;string&quot;&gt;&#39;http://xxx&#39;&lt;/span&gt;; //first page&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;request(url)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .&lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(data)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; request(data.&lt;span class=&quot;built_in&quot;&gt;next&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .&lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(data)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; request(data.&lt;span class=&quot;built_in&quot;&gt;next&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;) //....&lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其实这么一直then下去也是可以的…&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二逼程序员这么做&lt;br&gt;回调函数层层嵌套…Callback Hell。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;当不知道总共多少页的时候&quot;&gt;&lt;a href=&quot;#当不知道总共多少页的时候&quot; class=&quot;headerlink&quot; title=&quot;当不知道总共多少页的时候&quot;&gt;&lt;/a&gt;当不知道总共多少页的时候&lt;/h5&gt;&lt;p&gt;不停then的方法就不行了，于是有了文艺的程序员&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文艺程序员这么做&lt;br&gt;首先要知道的一点是，当没有下一页的时候，返回的&lt;code&gt;next=null&lt;/code&gt;，于是我们就有了递归的终止条件。&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(url)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!url) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (url) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; request(url).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(data)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      run(data.paging.next);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; url = &lt;span class=&quot;string&quot;&gt;&#39;http://xxx&#39;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// first page&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;run(url);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;瞎扯&quot;&gt;&lt;a href=&quot;#瞎扯&quot; class=&quot;headerlink&quot; title=&quot;瞎扯&quot;&gt;&lt;/a&gt;瞎扯&lt;/h3&gt;&lt;p&gt;嵌套的Promise其实&lt;strong&gt;可能&lt;/strong&gt;是反模式（anti-pattern）&lt;a href=&quot;http://taoofcode.net/promise-anti-patterns/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;^1&lt;/a&gt;，但是本文中的情况，如果不递归用嵌套的promise，我实在想不出别的办法来了（ (๑•́ ₃ •̀)宝宝心里苦，但宝宝不说）&lt;/p&gt;
&lt;p&gt;为什么说可能是呢，因为谷歌一搜“promise anti pattern nesting”，总能搜出一大堆关于嵌套promise是反模式的文章。然而bluebird的wiki&lt;a href=&quot;https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;^2&lt;/a&gt;中，并没有提到嵌套的promise是反模式。&lt;/p&gt;
&lt;p&gt;所以到底是不是反模式，我也不知道=，=大概的想法是，在能不嵌套的时候就不要嵌套，否则还不如用callback。&lt;/p&gt;
&lt;p&gt;能不嵌套的情况是说，then的都是完全不同的promise，如果都是then类似的promise，那么，懒人还是递归吧…&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;2016-01-24更新&lt;/strong&gt;&lt;br&gt;我还是觉得嵌套多层的promise是反模式，不推荐使用，机智的我学会了另一种不嵌套不递归的方法，请看这里：&lt;br&gt;(Promise的顺序执行和并行执行](tech/2016/01/23/excecute-pa
    
    </summary>
    
    
      <category term="promise" scheme="http://sabrinaluo.com/tech/tags/promise/"/>
    
      <category term="递归" scheme="http://sabrinaluo.com/tech/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>对generator和yield的一些理解</title>
    <link href="http://sabrinaluo.com/tech/2016/01/12/ES6-generator-yield/"/>
    <id>http://sabrinaluo.com/tech/2016/01/12/ES6-generator-yield/</id>
    <published>2016-01-12T09:11:28.000Z</published>
    <updated>2016-04-21T10:01:55.391Z</updated>
    
    <content type="html">&lt;p&gt;于是也是入了ES6的坑，为什么只有babel这种ES6转ES5的工具，而没有ES5转ES6的工具呢？可能有，但是我不知道。如果有的话，就能把5转成6，起码看起来逼格高了一大截，也能让我这种还不习惯ES6的小白假装会写ES6…&lt;/p&gt;
&lt;p&gt;简单的看了一下相关的概念，觉得还不太理解…就好像最开始看&lt;em&gt;原型链&lt;/em&gt;一样，花了一年多才慢慢理解继承啊什么的，但&lt;code&gt;constructor&lt;/code&gt;和&lt;code&gt;__proto__&lt;/code&gt;之类的东东我也还（4声）没整明白…真是资质愚钝QAQ&lt;/p&gt;
&lt;h3 id=&quot;generator-function&quot;&gt;&lt;a href=&quot;#generator-function&quot; class=&quot;headerlink&quot; title=&quot;generator function&quot;&gt;&lt;/a&gt;generator function&lt;/h3&gt;&lt;p&gt;一个generator函数大概长这样：&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;function* &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.&lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;111&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  yield &lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.&lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;222&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  yield &lt;span class=&quot;number&quot;&gt;456&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.&lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;333&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var a = foo(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;//此时函数不会执行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a.next(); &lt;span class=&quot;comment&quot;&gt;//此时函数执行到第一句含有yield的语句时就暂停了，也就是只打印了 111&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a.next(); &lt;span class=&quot;comment&quot;&gt;//此时函数执行到第二句含有yield的语句时暂停，打印了 222&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a.next(); &lt;span class=&quot;comment&quot;&gt;//已经没有yield语句了，将会打印333，函数执行完毕&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a.next(); &lt;span class=&quot;comment&quot;&gt;//已经没有yiedl语句了，什么也不会打印&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义的时候多加一个星星号&lt;strong&gt;function*&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;generator函数中通常都会有yield，如果没有yield那就定义一个普通函数就好了&lt;/li&gt;
&lt;li&gt;函数不会立即执行，使用&lt;code&gt;.next()&lt;/code&gt;方法时，函数才会执行；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;yield&quot;&gt;&lt;a href=&quot;#yield&quot; class=&quot;headerlink&quot; title=&quot;yield&quot;&gt;&lt;/a&gt;yield&lt;/h3&gt;&lt;p&gt;yield到底是一个什么东东呢？操作符？对象？还是别的什么，这个我还没搞明白。&lt;/p&gt;
&lt;p&gt;看看阮一峰老师的这个例子，有助于理解参数的一些问题：&lt;br&gt;&lt;figure class=&quot;highlight crystal&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function* foo(x) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  var y = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; * (&lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; (x + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  var z = &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; (y / &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (x + y + z);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var a = foo(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a.&lt;span class=&quot;keyword&quot;&gt;next&lt;/span&gt;(); &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;Object&lt;/span&gt;&amp;#123;&lt;span class=&quot;symbol&quot;&gt;value:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;done:&lt;/span&gt;&lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a.&lt;span class=&quot;keyword&quot;&gt;next&lt;/span&gt;(); &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;Object&lt;/span&gt;&amp;#123;&lt;span class=&quot;symbol&quot;&gt;value:&lt;/span&gt;&lt;span class=&quot;constant&quot;&gt;NaN&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;done:&lt;/span&gt;&lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a.&lt;span class=&quot;keyword&quot;&gt;next&lt;/span&gt;(); &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;Object&lt;/span&gt;&amp;#123;&lt;span class=&quot;symbol&quot;&gt;value:&lt;/span&gt;&lt;span class=&quot;constant&quot;&gt;NaN&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;done:&lt;/span&gt;&lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var b = foo(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b.&lt;span class=&quot;keyword&quot;&gt;next&lt;/span&gt;(); &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt; &amp;#123; &lt;span class=&quot;symbol&quot;&gt;value:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;done:&lt;/span&gt;&lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt; &amp;#125; ，此时x=&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;，var y还没执行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b.&lt;span class=&quot;keyword&quot;&gt;next&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;); &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt; &amp;#123; &lt;span class=&quot;symbol&quot;&gt;value:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;done:&lt;/span&gt;&lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt; &amp;#125;，此时x=&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;，y=&lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;，var z还没执行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b.&lt;span class=&quot;keyword&quot;&gt;next&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;13&lt;/span&gt;); &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt; &amp;#123; &lt;span class=&quot;symbol&quot;&gt;value:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;done:&lt;/span&gt;&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt; &amp;#125;，此时x=&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;，y=&lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;，&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当上面的函数运行&lt;code&gt;b.next(12)&lt;/code&gt;这一句时，x=5，y=24，var z还没执行，返回对象为{ value:8, done:false }&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Q: 为什么y=24？&lt;br&gt;A: 因为第二个next方法的参数传给&lt;em&gt;上一个yield&lt;/em&gt;，也就是第一个yield，所以var y = 2 * 12&lt;/p&gt;
&lt;p&gt;Q: 为什么返回对象value为8？&lt;br&gt;A: 因为第二个yield后面跟的表达式是 y/3，y=24，所以返回的对象value为8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;yield是一个&lt;strong&gt;暂停的标记&lt;/strong&gt;，使用&lt;code&gt;.next()&lt;/code&gt;方法运行函数时，遇到yield就会暂停&lt;/li&gt;
&lt;li&gt;yield用在表达式中必须加括号扩起来，比如这样&lt;code&gt;var a = 1 + (yield 1+1)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;.next()&lt;/code&gt;方法时会返回一个对象，长这样：&lt;code&gt;{ value: xxx, done: false }&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;有两个key，一个是value，一个是done&lt;/li&gt;
&lt;li&gt;value的值是，该次暂停遇到的这个&lt;code&gt;yield&lt;/code&gt; 后面跟的表达式的值。比如上面的例子中第一次调用&lt;code&gt;b.next()&lt;/code&gt;时，遇到第一个yield而暂停，&lt;code&gt;var y = 2 * (yield (x + 1));&lt;/code&gt;，yield后面跟的表达式是(x+1)，所以返回的对象value是6&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;done&lt;/code&gt;为&lt;code&gt;true&lt;/code&gt;说明后面没有yield了，之后再调用&lt;code&gt;.next()&lt;/code&gt;方法返回的value都是&lt;code&gt;undefined&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果generator函数没有返回值，那么最后一个yield之后再调用的&lt;code&gt;.next()&lt;/code&gt;方法返回的就是&lt;code&gt;{ value:undefined, done: true }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果generator函数有返回值，那么最后一个yield之后再调用&lt;code&gt;.next()&lt;/code&gt;方法返回的对象value是函数的返回值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;.next()&lt;/code&gt;方法时，可以传入参数&lt;ul&gt;
&lt;li&gt;该参数是传给&lt;strong&gt;上一个yield&lt;/strong&gt;，所以第一次调用&lt;code&gt;.next()&lt;/code&gt;时不能传入参数。&lt;em&gt;可能会报错，也可能参数会被忽略，取决于浏览器是怎么实现的&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不传入参数时，yield语句返回的值为&lt;code&gt;undefined&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;瞎扯&quot;&gt;&lt;a href=&quot;#瞎扯&quot; class=&quot;headerlink&quot; title=&quot;瞎扯&quot;&gt;&lt;/a&gt;瞎扯&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;感觉yield像一个“函数”，执行的时候遇到这个函数就会暂停&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这个函数返回的值等于&lt;code&gt;.next(xxx)&lt;/code&gt;调用时传入的参数xxx，如果没有参数，返回值就是&lt;code&gt;undefined&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function* foo() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.log(&lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.log(&lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var a=foo();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a.&lt;span class=&quot;keyword&quot;&gt;next&lt;/span&gt;(); &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt; 遇到第一个&lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt;暂停，什么也不打印&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a.&lt;span class=&quot;keyword&quot;&gt;next&lt;/span&gt;(); &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt; 遇到第二个&lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt;暂停，打印上一句console.log(&lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt;)，由于没有传入参数，&lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt;返回undefined&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a.&lt;span class=&quot;keyword&quot;&gt;next&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;hello&#39;&lt;/span&gt;); &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt;后面没有&lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt;了，函数执行完毕，打印第二个console.log，由于传入参数，将会打印出hello&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;yield用在表达式中必须加括号扩起来，比如这样&lt;code&gt;var a = 1 + (yield 1+1)&lt;/code&gt;，有点类似于把一个函数写到表达式中要用括号括起来&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; + (&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;&amp;#125;());&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;好奇宝宝&quot;&gt;&lt;a href=&quot;#好奇宝宝&quot; class=&quot;headerlink&quot; title=&quot;好奇宝宝&quot;&gt;&lt;/a&gt;好奇宝宝&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;往&lt;code&gt;next()&lt;/code&gt;里传入参数的用法，在什么场景下适用？&lt;/li&gt;
&lt;li&gt;通常是不是都通过&lt;code&gt;.next().value&lt;/code&gt;来获取当前暂停的&lt;code&gt;yield&lt;/code&gt;后面的表达式？&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;于是也是入了ES6的坑，为什么只有babel这种ES6转ES5的工具，而没有ES5转ES6的工具呢？可能有，但是我不知道。如果有的话，就能把5转成6，起码看起来逼格高了一大截，也能让我这种还不习惯ES6的小白假装会写ES6…&lt;/p&gt;
&lt;p&gt;简单的看了一下相关的概念，觉得还不
    
    </summary>
    
    
      <category term="ES6" scheme="http://sabrinaluo.com/tech/tags/ES6/"/>
    
      <category term="generator" scheme="http://sabrinaluo.com/tech/tags/generator/"/>
    
      <category term="yield" scheme="http://sabrinaluo.com/tech/tags/yield/"/>
    
  </entry>
  
  <entry>
    <title>对JS类和继承的一些理解</title>
    <link href="http://sabrinaluo.com/tech/2015/12/31/understand-js-inheritance/"/>
    <id>http://sabrinaluo.com/tech/2015/12/31/understand-js-inheritance/</id>
    <published>2015-12-31T03:36:54.000Z</published>
    <updated>2016-04-21T10:01:55.395Z</updated>
    
    <content type="html">&lt;p&gt;本文只总结最常用的实现方法，不具体讨论各种实现方法的优缺点（这些具体可以看&lt;a href=&quot;http://book.douban.com/subject/10546125/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《JavaScript高级程序设计》&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;直到ES5，JS也还是一个没有类的语言，虽然ES6中可以使用class关键字，但据说也只是语法糖。(不知道好不好吃ԅ(¯﹃¯ԅ))&lt;/p&gt;
&lt;h3 id=&quot;类的实现&quot;&gt;&lt;a href=&quot;#类的实现&quot; class=&quot;headerlink&quot; title=&quot;类的实现&quot;&gt;&lt;/a&gt;类的实现&lt;/h3&gt;&lt;p&gt;类的两个基本元素就是&lt;strong&gt;属性&lt;/strong&gt;和&lt;strong&gt;方法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;JS中类的实现有很多种，构造函数模式、原型模式等等，各有各的优缺点，最常用的是混合了构造函数和原型模式的混合模式。&lt;br&gt;&lt;figure class=&quot;highlight fortran&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;/span&gt; Person(&lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  this.&lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Person.prototype.sayHi = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.&lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;Hi, &#39;&lt;/span&gt; + this.&lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;使用构造函数来构造&lt;strong&gt;属性&lt;/strong&gt;，然后往原型对象添加&lt;strong&gt;方法&lt;/strong&gt;。这样的好处是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个实例之间不用共享属性，拥有各自独立的属性。也就可以避免当属性为引用类型（数组、对象）时，修改一个实例的属性会影响到其他实例的情况。&lt;/li&gt;
&lt;li&gt;每个实例之间共用原型对象上的方法，实现了函数复用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;继承的实现&quot;&gt;&lt;a href=&quot;#继承的实现&quot; class=&quot;headerlink&quot; title=&quot;继承的实现&quot;&gt;&lt;/a&gt;继承的实现&lt;/h3&gt;&lt;p&gt;JS中继承的实现也有很多种，借用构造函数，原型链等等。&lt;br&gt;子类继承父类，当然继承的就是父类的&lt;strong&gt;属性和方法&lt;/strong&gt;。JS中继承的实现，最常用的也是混合模式。&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Student&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;name, age&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Person.call(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age = age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(Student.prototype.constructor); &lt;span class=&quot;comment&quot;&gt;// Student&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Student.prototype = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(Student.prototype.constructor); &lt;span class=&quot;comment&quot;&gt;// Person&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Student.prototype.constructor = Student; &lt;span class=&quot;comment&quot;&gt;// 重写constructor&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Student.prototype.sayAge = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;I&#39;m &quot;&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;strong&gt;借用构造函数&lt;/strong&gt;的方式来继承&lt;strong&gt;属性&lt;/strong&gt;，然后使用&lt;strong&gt;原型链&lt;/strong&gt;来继承&lt;strong&gt;方法&lt;/strong&gt;。通过将子类的原型对象指向父类的实例，子类的实例就可以通过原型链向上查找到父类原型上的方法。&lt;/p&gt;
&lt;h3 id=&quot;重写子类构造函数的意义&quot;&gt;&lt;a href=&quot;#重写子类构造函数的意义&quot; class=&quot;headerlink&quot; title=&quot;重写子类构造函数的意义&quot;&gt;&lt;/a&gt;重写子类构造函数的意义&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Student.prototype = new Person();&lt;/code&gt;这一步完全改变了Student原型对象的引用，&lt;code&gt;Student.prototype.constructor&lt;/code&gt; 变为了Person原型对象的constructor。&lt;br&gt;个人觉得重写&lt;code&gt;Student.prototype.constructor = Student;&lt;/code&gt;没有什么实际意义，可能只是&lt;strong&gt;约定俗成的一种潜规则&lt;/strong&gt;。&lt;br&gt;人们通常可能已经习惯了使用new操作符的时候，构造函数的一致性&lt;br&gt;&lt;figure class=&quot;highlight oxygene&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Student.prototype.constructor = Student; 在上面的代码中注释掉这一句&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; xiaobai = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Student(&lt;span class=&quot;string&quot;&gt;&#39;小白妹妹&#39;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;xiaobai.&lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// Person&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当你在代码中遇到上面这种情况，如果不去查看之前的代码的话，肯定会觉得奇怪，为什么明明通过Student构造函数new了一个Student实例，而这个实例，却说自己的构造函数是Person？！？！WTF？！&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;p&gt;[1] &lt;a href=&quot;http://stackoverflow.com/questions/4012998/what-it-the-significance-of-the-javascript-constructor-property&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://stackoverflow.com/questions/4012998/what-it-the-significance-of-the-javascript-constructor-property&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文只总结最常用的实现方法，不具体讨论各种实现方法的优缺点（这些具体可以看&lt;a href=&quot;http://book.douban.com/subject/10546125/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《JavaScript高级程序设计》
    
    </summary>
    
    
      <category term="JS" scheme="http://sabrinaluo.com/tech/tags/JS/"/>
    
      <category term="prototype" scheme="http://sabrinaluo.com/tech/tags/prototype/"/>
    
      <category term="原型" scheme="http://sabrinaluo.com/tech/tags/%E5%8E%9F%E5%9E%8B/"/>
    
      <category term="继承" scheme="http://sabrinaluo.com/tech/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>利用travis自动部署hexo搭建在github的博客</title>
    <link href="http://sabrinaluo.com/tech/2015/12/28/travis-github-hexo/"/>
    <id>http://sabrinaluo.com/tech/2015/12/28/travis-github-hexo/</id>
    <published>2015-12-28T04:00:56.000Z</published>
    <updated>2016-04-21T10:01:55.395Z</updated>
    
    <content type="html">&lt;p&gt;这篇应该属于不务正业系列…&lt;br&gt;自从知道了持续集成（Continuous Integration）这个概念之后感觉开启了新世界的大门。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://travis-ci.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Travis&lt;/a&gt;是一套持续集成的服务器解决方案，也就是等于把jenkins能够实现的都放在了云端，不用自己搭服务器安装了，懒人的福音～&lt;/p&gt;
&lt;p&gt;最初知道travis是因为总在github商看到这种小图标，虽然不知道是什么东东，但是觉得逼格特别高…&lt;br&gt;&lt;a href=&quot;https://travis-ci.org/sabrinaluo/tech&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://travis-ci.org/sabrinaluo/tech.svg?branch=master&quot; alt=&quot;Build Status&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于Hexo和github page这里就不讨论了，教程网上一搜一大堆。用travis属于进阶内容了，能搜到这篇文章的，应该也都具备了最基础的知识。&lt;/p&gt;
&lt;p&gt;为什么需要travis来自动部署博客呢，像我这种废话多的人，倾诉欲随时随地会喷发…然后如果当时手边没有电脑，或者有电脑了但不是我的电脑，欲火就被一盆水浇灭了…而有了travis之后呢，只要给我一台能上网的电脑，分分钟就能发博客并且更新到自己的网站…&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zespia.tw/blog/2015/01/21/continuous-deployment-to-github-with-travis/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;具体教程（来自Hexo的作者Tommy）&lt;/a&gt;网上已经有一些了，但不是很多，这里主要说一说其中容易遇到的坑。&lt;/p&gt;
&lt;h3 id=&quot;Prerequisite&quot;&gt;&lt;a href=&quot;#Prerequisite&quot; class=&quot;headerlink&quot; title=&quot;Prerequisite&quot;&gt;&lt;/a&gt;Prerequisite&lt;/h3&gt;&lt;p&gt;注册一个travis账号，绑定github，并为相应的repo开启travis服务&lt;br&gt;在repo中添加&lt;code&gt;.travis.yml&lt;/code&gt;文件，下面是我个人的配置。我是将source和public放在同一个repo的不同分支里，源文件放在master分支，生成后的网页放在gh-pages分支。&lt;br&gt;&lt;script src=&quot;//gist.github.com/d905eeed53d9368fdee6.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## 目录结构如下，其中.travis文件夹用于存放github的sshkey加密文件，以及ssh的相关配置
└── blog
    ├── _config.yml
    ├── package.json
    ├── README.md
    ├── scaffolds
    ├── source
    │   └── _posts
    ├── .travis
    │   ├── id_rsa.enc
    │   └── ssh_config
    └── .travis.yml
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;注意事项&quot;&gt;&lt;a href=&quot;#注意事项&quot; class=&quot;headerlink&quot; title=&quot;注意事项&quot;&gt;&lt;/a&gt;注意事项&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;before_install:
- openssl aes-256-cbc -K $encrypted_e011a6d7eebf_key -iv $encrypted_e011a6d7eebf_iv -in .travis/id_rsa.enc -out ~/.ssh/id_rsa -d
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;$encrypted_e011a6d7eebf_key&lt;/strong&gt;这一串加密的key每个人都不同，请不要直接复制。请使用&lt;br&gt;&lt;code&gt;$ travis encrypt-file ssh_key --add&lt;/code&gt; 这条命令将相应的key写入&lt;code&gt;.travis.yml&lt;/code&gt;中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;记得检查&lt;code&gt;.travis.yml&lt;/code&gt;文件&lt;/strong&gt;，因为在自动写入文件的过程中很可能出现了&lt;strong&gt;自动换行&lt;/strong&gt;的问题（我是linuxmint 用webstorm遇到了这个问题），如果有换行的问题把换行符删除即可，否则会导致travis在命令跑到这里的时候出问题使得building failed。&lt;/li&gt;
&lt;li&gt;另外如果有将相应的文件移到相应的文件夹中，请记得在命令中修改相应的path&lt;/li&gt;
&lt;li&gt;如果你最后deploy的不是master分支，请在&lt;code&gt;packag.json&lt;/code&gt;中使用下面的依赖&lt;pre&gt;&lt;code&gt;&amp;quot;hexo-deployer-git&amp;quot;: &amp;quot;hexojs/hexo-deployer-git#495fc6d&amp;quot;
&lt;/code&gt;&lt;/pre&gt;hexo-deployer-git在0.0.4及之前的版本都是hardcode了默认使用master分支来deploy，当使用非master分支来进行deploy时（本文例子中使用gh-pages分支中的内容）则会报错，上述版本修复了该问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;travis-yml文件解释&quot;&gt;&lt;a href=&quot;#travis-yml文件解释&quot; class=&quot;headerlink&quot; title=&quot;.travis.yml文件解释&quot;&gt;&lt;/a&gt;&lt;code&gt;.travis.yml&lt;/code&gt;文件解释&lt;/h3&gt;&lt;p&gt;整个配置其实是告诉travis：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用node 4.0版本来build我的程序&lt;/li&gt;
&lt;li&gt;只有当master分支有commit的时候才自动部署&lt;/li&gt;
&lt;li&gt;在安装之前先解密ssh key以便获得github的写权限（这样才能push到gh-pages分支）；全局安装hexo（这样才能直接执行hexo命令）；配置git设定（这样才能用git）&lt;/li&gt;
&lt;li&gt;克隆主题&lt;blockquote&gt;
&lt;p&gt;（如果想省略这一步，你可以把主题&lt;code&gt;themes&lt;/code&gt;文件夹也放在博客repo的master分支中）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;克隆gh-pages分支到&lt;code&gt;.deploy_git&lt;/code&gt;文件夹&lt;blockquote&gt;
&lt;p&gt;（hexo 默认会将生成的用于deploy的文件都放在这个文件夹；如果不需要gh-pages分支的相关commit记录，这一步可以省略。省略后该分支永远只有最近的一次commit…）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;跑一下&lt;code&gt;hexo g&lt;/code&gt;命令，看看是否会有错&lt;blockquote&gt;
&lt;p&gt;请注意，这一步并不能保证博客生成的样式问题，只是查看主题是否有错误。如果你每次都是克隆主题，并不能保证你克隆的版本每次都能顺利生成所有文件，可能会存在bug&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;如果能够顺利生成网页则执行&lt;code&gt;hexo d&lt;/code&gt;，将博客push到gh-pages分支 &lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这篇应该属于不务正业系列…&lt;br&gt;自从知道了持续集成（Continuous Integration）这个概念之后感觉开启了新世界的大门。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://travis-ci.org&quot; target=&quot;_blank&quot; rel=&quot;external
    
    </summary>
    
    
      <category term="github" scheme="http://sabrinaluo.com/tech/tags/github/"/>
    
      <category term="hexo" scheme="http://sabrinaluo.com/tech/tags/hexo/"/>
    
      <category term="travis" scheme="http://sabrinaluo.com/tech/tags/travis/"/>
    
      <category term="博客" scheme="http://sabrinaluo.com/tech/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="持续集成" scheme="http://sabrinaluo.com/tech/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
      <category term="自动部署" scheme="http://sabrinaluo.com/tech/tags/%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>git merge commits 如何合并多个提交为一个</title>
    <link href="http://sabrinaluo.com/tech/2015/12/24/how-to-merge-commits-with-git-rebase/"/>
    <id>http://sabrinaluo.com/tech/2015/12/24/how-to-merge-commits-with-git-rebase/</id>
    <published>2015-12-24T07:08:49.000Z</published>
    <updated>2016-04-21T10:01:55.395Z</updated>
    
    <content type="html">&lt;p&gt;因为我是那种经常改一个错别字就忙着要提交一次的人…所以总是会产生很多无意义的提交，于是合并多个提交为一个就成了我的刚性需求。&lt;/p&gt;
&lt;p&gt;关于合并多个提交，主要是要搞清楚&lt;code&gt;rebase&lt;/code&gt;的用法。&lt;/p&gt;
&lt;h3 id=&quot;查看提交历史，git-log&quot;&gt;&lt;a href=&quot;#查看提交历史，git-log&quot; class=&quot;headerlink&quot; title=&quot;查看提交历史，git log&quot;&gt;&lt;/a&gt;查看提交历史，git log&lt;/h3&gt;&lt;p&gt;首先你要知道自己想合并的是哪几个提交，可以使用&lt;code&gt;git log&lt;/code&gt;命令来查看提交历史，假如最近4条历史如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;commit ada2cd944fc81cf0051c6b6cac62fad9ae6830d3
commit 0e25f1237eeaf9ae02b5b48b888a844ed288e7e3
commit ddbd8fd1d52aec0bbedc65a1a0add159344d4ae2
commit 2aad0182a613b2e73b44ebbf0d5536126f714cb9
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;历史记录是按照时间排序的，时间近的排在前面。&lt;/p&gt;
&lt;h3 id=&quot;git-rebase&quot;&gt;&lt;a href=&quot;#git-rebase&quot; class=&quot;headerlink&quot; title=&quot;git rebase&quot;&gt;&lt;/a&gt;git rebase&lt;/h3&gt;&lt;p&gt;想要合并1-3条，有两个方法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从HEAD版本开始往过去数3个版本&lt;pre&gt;&lt;code&gt;git rebase -i HEAD~3
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;指名要合并的版本之前的版本号&lt;pre&gt;&lt;code&gt;git rebase -i 2aad018
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;请注意&lt;strong&gt;2aad018&lt;/strong&gt;这个版本是不参与合并的，可以把它当做一个坐标&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;选取要合并的提交&quot;&gt;&lt;a href=&quot;#选取要合并的提交&quot; class=&quot;headerlink&quot; title=&quot;选取要合并的提交&quot;&gt;&lt;/a&gt;选取要合并的提交&lt;/h3&gt;&lt;p&gt;执行了rebase命令之后，会弹出一个窗口，头几行如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pick ada2cd9
pick 0e25f12
pick ddbd8fd
...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将&lt;code&gt;pick&lt;/code&gt;改为&lt;code&gt;squash&lt;/code&gt;或者&lt;code&gt;s&lt;/code&gt;，之后保存并关闭文本编辑窗口即可。改完之后文本内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;s ada2cd9
s 0e25f12
s ddbd8fd
...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参考：&lt;br&gt;[1] &lt;a href=&quot;https://git-scm.com/docs/git-rebase&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://git-scm.com/docs/git-rebase&lt;/a&gt;&lt;br&gt;[2] &lt;a href=&quot;http://blog.csdn.net/yangcs2009/article/details/47166361&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/yangcs2009/article/details/47166361&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;因为我是那种经常改一个错别字就忙着要提交一次的人…所以总是会产生很多无意义的提交，于是合并多个提交为一个就成了我的刚性需求。&lt;/p&gt;
&lt;p&gt;关于合并多个提交，主要是要搞清楚&lt;code&gt;rebase&lt;/code&gt;的用法。&lt;/p&gt;
&lt;h3 id=&quot;查看提交历史，git-log&quot;
    
    </summary>
    
    
      <category term="git" scheme="http://sabrinaluo.com/tech/tags/git/"/>
    
      <category term="merge commits" scheme="http://sabrinaluo.com/tech/tags/merge-commits/"/>
    
      <category term="合并提交" scheme="http://sabrinaluo.com/tech/tags/%E5%90%88%E5%B9%B6%E6%8F%90%E4%BA%A4/"/>
    
  </entry>
  
  <entry>
    <title>git merge repo 如何合并两个仓库</title>
    <link href="http://sabrinaluo.com/tech/2015/12/24/how-to-merge-repos-with-git/"/>
    <id>http://sabrinaluo.com/tech/2015/12/24/how-to-merge-repos-with-git/</id>
    <published>2015-12-24T06:58:32.000Z</published>
    <updated>2016-04-21T10:01:55.395Z</updated>
    
    <content type="html">&lt;p&gt;为什么我每天都会有一些奇奇怪怪的需求…&lt;/p&gt;
&lt;p&gt;我之前在github上用hexo搭了一个静态博客，每次hexo deploy的时候，就会在gh-pages分支提交一个commit。但是由于hexo-deployer-git本身的逻辑是，每次都是强推&lt;code&gt;push -f&lt;/code&gt;，于是每当我换电脑（比如从家里换到公司里）的时候，我的commit记录就会丢失…但是像我这种虚荣心强的人，一个错别字都要commit一次来增加我在github commit的次数…所以，我家里的电脑和公司的电脑，两个repo的commit log都不能丢！！一个都不能少！！&lt;/p&gt;
&lt;h3 id=&quot;如何合并两个仓库&quot;&gt;&lt;a href=&quot;#如何合并两个仓库&quot; class=&quot;headerlink&quot; title=&quot;如何合并两个仓库&quot;&gt;&lt;/a&gt;如何合并两个仓库&lt;/h3&gt;&lt;p&gt;假设现在有两个repo：repo1，repo2，每个repo中都已经有一堆提交记录了，现在想把repo2中的记录合并到repo1中，命令如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; repo1
git remote add other ../repo2
git fetch other
git checkout -b repo2 other/master
git checkout master
git merge repo2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解释：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进入repo1文件夹&lt;/li&gt;
&lt;li&gt;添加repo2作为repo1的远程仓库，并命名为other&lt;/li&gt;
&lt;li&gt;将repo2的内容获取到repo1&lt;blockquote&gt;
&lt;p&gt;注意，使用fetch而不是pull，关于fetch和pull的区别&lt;a href=&quot;https://stackoverflow.com/questions/292357/what-are-the-differences-between-git-pull-and-git-fetch&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;请戳这里&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;在repo1中创建名为repo2的新分支，同时切换到该分支，并且使用上一步获取的内容中的master分支的内容&lt;/li&gt;
&lt;li&gt;切换到repo1的master分支&lt;/li&gt;
&lt;li&gt;将repo2分支的内容合并到master分支&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;一句话总结&quot;&gt;&lt;a href=&quot;#一句话总结&quot; class=&quot;headerlink&quot; title=&quot;一句话总结&quot;&gt;&lt;/a&gt;一句话总结&lt;/h3&gt;&lt;p&gt;将一个仓库的内容checkout到另一个仓库的一个分支，将该分支与master分支合并&lt;/p&gt;
&lt;p&gt;参考：&lt;br&gt;[1] &lt;a href=&quot;http://blog.csdn.net/gouboft/article/details/8450696&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/gouboft/article/details/8450696&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;为什么我每天都会有一些奇奇怪怪的需求…&lt;/p&gt;
&lt;p&gt;我之前在github上用hexo搭了一个静态博客，每次hexo deploy的时候，就会在gh-pages分支提交一个commit。但是由于hexo-deployer-git本身的逻辑是，每次都是强推&lt;code&gt;push
    
    </summary>
    
    
      <category term="git" scheme="http://sabrinaluo.com/tech/tags/git/"/>
    
      <category term="merge repo" scheme="http://sabrinaluo.com/tech/tags/merge-repo/"/>
    
      <category term="合并仓库" scheme="http://sabrinaluo.com/tech/tags/%E5%90%88%E5%B9%B6%E4%BB%93%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>对Promise中的resolve，reject，catch的理解</title>
    <link href="http://sabrinaluo.com/tech/2015/12/22/understand-resolve-reject-catch-of-promise/"/>
    <id>http://sabrinaluo.com/tech/2015/12/22/understand-resolve-reject-catch-of-promise/</id>
    <published>2015-12-22T03:36:07.000Z</published>
    <updated>2016-04-21T10:01:55.395Z</updated>
    
    <content type="html">&lt;p&gt;对promise这个概念之前已经有了一些浅显的理解，&lt;a href=&quot;http://sabrinaluo.com/tech/2015/12/01/promise/&quot;&gt;相关文章-&amp;gt;戳这里&lt;/a&gt;，最近又有了一些新的理解。&lt;/p&gt;
&lt;h3 id=&quot;then-的时候到底是在then什么…&quot;&gt;&lt;a href=&quot;#then-的时候到底是在then什么…&quot; class=&quot;headerlink&quot; title=&quot;.then()的时候到底是在then什么…&quot;&gt;&lt;/a&gt;.then()的时候到底是在then什么…&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;首先要理解…Promise是一个对象，有then()方法的对象&lt;/li&gt;
&lt;li&gt;then()的入参是一个函数，通常在promise链中，入参是&lt;strong&gt;一个返回promise的函数&lt;/strong&gt;，这句话好像有点拗口，就是说入参是一个函数，这个函数会return一个promise对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;如何破坏promise链&quot;&gt;&lt;a href=&quot;#如何破坏promise链&quot; class=&quot;headerlink&quot; title=&quot;如何破坏promise链&quot;&gt;&lt;/a&gt;如何破坏promise链&lt;/h3&gt;&lt;p&gt;如果有这样一个promise链：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p1().then(p2).then(p3)
  .then(function(data) {
    console.log(&amp;apos;data: &amp;apos; + data);
  })
  .catch(function(error) {
    console.log(&amp;apos;error: &amp;apos; + error);
  });

function p1() {
  return new Promise(function(resolve, reject) {
    console.log(&amp;apos;p1 resolved&amp;apos;);
    resolve(123);
  });
}

function p2() {
  return new Promise(function(resolve, reject) {
    console.log(&amp;apos;p2 rejected&amp;apos;);
    reject(456);
  });
}

function p3() {
  return new Promise(function(resolve, reject) {
    console.log(&amp;apos;p3 resolved&amp;apos;);
    resolve(789);
  });
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面这个例子，你看到的console.log会是这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p1 resolved
p2 rejected
error: 456
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;并没有看到&lt;code&gt;p3&lt;/code&gt;的log，而是看到了error message，也就是说：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在一个promise链中，只要任何一个promise被reject，promise链就被破坏了，reject之后的promise都不会再执行，而是直接调用&lt;code&gt;.catch&lt;/code&gt;方法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这也是为什么在standard practice中，一定要在最后加上&lt;code&gt;.catch&lt;/code&gt;的原因。通过&lt;code&gt;.catch&lt;/code&gt;能够清楚的判断出promise链在哪个环节出了问题。&lt;/p&gt;
&lt;h3 id=&quot;如何按顺序执行已经定义的promise&quot;&gt;&lt;a href=&quot;#如何按顺序执行已经定义的promise&quot; class=&quot;headerlink&quot; title=&quot;如何按顺序执行已经定义的promise&quot;&gt;&lt;/a&gt;如何按顺序执行已经定义的promise&lt;/h3&gt;&lt;p&gt;这个情况在什么时候会用到呢？比如你有一个队列，队列里有很多任务，这些任务并不互相依赖执行后返回的结果。每个任务完成的时间都是不确定的，并且计算资源只允许一次执行一个任务。简单的来说，就是&lt;strong&gt;做完A之后再去做B，并且AB是相互独立的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假如我现在有一堆promise对象，大概长这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//p2, p3与p1相似
//当doSomething()执行完毕的时候，调用resolve()
//使得当前promise状态转变为fulfilled即可
var p1 = new Promise(function(resolve, reject) {
  //do something here
  //when do something done
  resolve();
});

p1.then(function() {
    return p2
  })
  .then(function() {
    return p3
  })
  .catch()
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;请注意，前一部破坏Promise链中分定义的p1 p2 p3是&lt;strong&gt;函数&lt;/strong&gt;，而此部分定义的p1 p2 p3是&lt;strong&gt;对象！对象！对象！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;如前面提到，promise是一个有then方法的对象，因此p1可以直接调用then&lt;br&gt;Q:为什么开头调用不是&lt;code&gt;p1().then&lt;/code&gt;？&lt;br&gt;A: 因为p1是一个对象啊！！！对象啊！！！象啊！！！啊！！！&lt;/li&gt;
&lt;li&gt;然而promise链中then方法的入参是&lt;strong&gt;一个返回promise对象的函数&lt;/strong&gt;，p2并不是一个函数，因此不能then(p2)；&lt;/li&gt;
&lt;li&gt;但p2是一个promise对象，已经满足了then方法入参的一半需求，那么写一个函数并且返回p2，就满足了入参的全部需求&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;对promise这个概念之前已经有了一些浅显的理解，&lt;a href=&quot;http://sabrinaluo.com/tech/2015/12/01/promise/&quot;&gt;相关文章-&amp;gt;戳这里&lt;/a&gt;，最近又有了一些新的理解。&lt;/p&gt;
&lt;h3 id=&quot;then-的时候到底是在
    
    </summary>
    
    
      <category term="promise chain" scheme="http://sabrinaluo.com/tech/tags/promise-chain/"/>
    
      <category term="promise链" scheme="http://sabrinaluo.com/tech/tags/promise%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>JS变量提升(Hoisting)</title>
    <link href="http://sabrinaluo.com/tech/2015/12/21/hoisting/"/>
    <id>http://sabrinaluo.com/tech/2015/12/21/hoisting/</id>
    <published>2015-12-21T02:24:02.000Z</published>
    <updated>2016-04-21T10:01:55.395Z</updated>
    
    <content type="html">&lt;p&gt;写了无数JS也依旧没听过变量提升…&lt;/p&gt;
&lt;p&gt;变量提升(Hoisting)这个概念，我第一次见到是在万人膜拜的&lt;a href=&quot;https://github.com/airbnb/javascript&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Airbnb JS 代码风格&lt;/a&gt;中见到。看完这一节大概明白是在说什么，然后觉得非常奇怪，这个概念平时写代码什么情况下用的到呢？&lt;/p&gt;
&lt;p&gt;我写了这么久JS，从来也不会先用变量后定义的呀，而且别的语言好像根本没有这个概念，难怪我从来没有遇到相关问题，难怪我没听过这个概念。难怪写强类型语言的各大神都是JS一生黑…&lt;/p&gt;
&lt;p&gt;后来大概问了问各种前辈，纷纷表示，这个概念在面试的时候和检查别人Bug的时候才会用到… (︶︿︶)&lt;/p&gt;
&lt;p&gt;解释器是什么东东我还没搞明白…但是变量提升其实可以转换成另一个问题：&lt;br&gt;当你在定义一个变量的时候，解释器是怎么解析的？&lt;/p&gt;
&lt;p&gt;先看一个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function test(){
  console.log(a);
  var a = 123;
}
test(); //调用这个函数，你会看到console中输出的是undefined
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;function test(){
  var a = 123;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的代码，解释器是这么理解的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function test(){
  var a; 
  a = 123;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而最开始的例子中，解释器是这么理解的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function test(){
  var a;
  console.log(a);
  a = 123;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一句话总结：变量提升就是JS解释器在解析JS的时候会把所有变量的&lt;strong&gt;声明&lt;/strong&gt;提升到该变量作用域的最顶端。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请注意：&lt;strong&gt;只提升声明，不提升赋值&lt;/strong&gt;！&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;写了无数JS也依旧没听过变量提升…&lt;/p&gt;
&lt;p&gt;变量提升(Hoisting)这个概念，我第一次见到是在万人膜拜的&lt;a href=&quot;https://github.com/airbnb/javascript&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Ai
    
    </summary>
    
    
      <category term="hoisting" scheme="http://sabrinaluo.com/tech/tags/hoisting/"/>
    
      <category term="变量提升" scheme="http://sabrinaluo.com/tech/tags/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
</feed>
